From 8fd27d6e0831c5a5cc3a2da05350fa73621e1f35 Mon Sep 17 00:00:00 2001
From: Aaron Lin <aaron.dl.lin@intel.com>
Date: Wed, 2 Jul 2025 18:02:08 -0700
Subject: [PATCH 01/38] init SVS uncompressed data support

---
 faiss/CMakeLists.txt           |  21 ++++++-
 faiss/IndexSVSUncompressed.cpp | 107 +++++++++++++++++++++++++++++++++
 faiss/IndexSVSUncompressed.h   |  67 +++++++++++++++++++++
 tutorial/cpp/10-SVS.cpp        |  73 ++++++++++++++++++++++
 tutorial/cpp/CMakeLists.txt    |   3 +
 5 files changed, 269 insertions(+), 2 deletions(-)
 create mode 100644 faiss/IndexSVSUncompressed.cpp
 create mode 100644 faiss/IndexSVSUncompressed.h
 create mode 100644 tutorial/cpp/10-SVS.cpp

diff --git a/faiss/CMakeLists.txt b/faiss/CMakeLists.txt
index 0ad036967..78143e95f 100644
--- a/faiss/CMakeLists.txt
+++ b/faiss/CMakeLists.txt
@@ -47,6 +47,7 @@ set(FAISS_SRC
   IndexScalarQuantizer.cpp
   IndexShards.cpp
   IndexShardsIVF.cpp
+  IndexSVSUncompressed.cpp
   IndexNeuralNetCodec.cpp
   MatrixStats.cpp
   MetaIndexes.cpp
@@ -145,6 +146,7 @@ set(FAISS_HEADERS
   IndexScalarQuantizer.h
   IndexShards.h
   IndexShardsIVF.h
+  IndexSVSUncompressed.h
   MatrixStats.h
   MetaIndexes.h
   MetricType.h
@@ -250,7 +252,6 @@ endif()
 set(FAISS_HEADERS ${FAISS_HEADERS} PARENT_SCOPE)
 
 add_library(faiss ${FAISS_SRC})
-
 add_library(faiss_avx2 ${FAISS_SRC})
 if(NOT FAISS_OPT_LEVEL STREQUAL "avx2" AND NOT FAISS_OPT_LEVEL STREQUAL "avx512" AND NOT FAISS_OPT_LEVEL STREQUAL "avx512_spr")
   set_target_properties(faiss_avx2 PROPERTIES EXCLUDE_FROM_ALL TRUE)
@@ -320,9 +321,25 @@ if(NOT WIN32)
   endif()
 endif()
 
+# Experimental SVS cmake build
+include(FetchContent)
+set(SVS_URL "https://github.com/intel/ScalableVectorSearch/releases/download/v0.0.8-dev/svs-shared-library-0.0.8-NIGHTLY-20250630.tar.gz")
+FetchContent_Declare(
+    svs
+    URL "${SVS_URL}"
+)
+FetchContent_MakeAvailable(svs)
+list(APPEND CMAKE_PREFIX_PATH "${svs_SOURCE_DIR}")
+find_package(svs REQUIRED)
+
+target_link_libraries(faiss PUBLIC svs::svs)
+
 # Handle `#include <faiss/foo.h>`.
+# Handle `#include <svs/foo.h>`.
 target_include_directories(faiss PUBLIC
-  $<BUILD_INTERFACE:${PROJECT_SOURCE_DIR}>)
+  $<BUILD_INTERFACE:${svs_SOURCE_DIR}/include>
+  $<BUILD_INTERFACE:${PROJECT_SOURCE_DIR}>
+)
 # Handle `#include <faiss/foo.h>`.
 target_include_directories(faiss_avx2 PUBLIC
   $<BUILD_INTERFACE:${PROJECT_SOURCE_DIR}>)
diff --git a/faiss/IndexSVSUncompressed.cpp b/faiss/IndexSVSUncompressed.cpp
new file mode 100644
index 000000000..f2f612d43
--- /dev/null
+++ b/faiss/IndexSVSUncompressed.cpp
@@ -0,0 +1,107 @@
+/*
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+
+#include <faiss/IndexSVSUncompressed.h>
+#include "faiss/Index.h"
+
+namespace faiss {
+
+IndexSVSUncompressed::IndexSVSUncompressed(
+    idx_t d, 
+    MetricType metric,
+    idx_t num_threads,
+    idx_t graph_max_degree
+):Index(d, metric), num_threads{num_threads}, graph_max_degree{graph_max_degree} {
+}
+
+void IndexSVSUncompressed::add(idx_t n, const float* x) {
+
+    // construct sequential labels
+    std::vector<size_t> labels(n);
+    std::iota(labels.begin(), labels.end(), nlabels);
+    nlabels += n;
+
+
+    if(!impl) {
+        init_impl(n, x, labels);
+        return;
+    }
+
+    auto data = svs::data::ConstSimpleDataView<float>(x, n, d);
+    impl->add_points(data, labels);
+}
+
+void IndexSVSUncompressed::reset() {
+    impl.reset();
+    nlabels = 0;
+}
+
+IndexSVSUncompressed::~IndexSVSUncompressed() {
+}
+
+void IndexSVSUncompressed::search(
+    idx_t n,
+    const float* x,
+    idx_t k,
+    float* distances,
+    idx_t* labels,
+    const SearchParameters* params
+) const {
+    FAISS_THROW_IF_NOT(k > 0);
+
+    auto queries = svs::data::ConstSimpleDataView<float>(x, n, d);
+
+    // TODO: use params for SVS search parameters
+    auto sp = impl->get_search_parameters();
+    sp.buffer_config({search_window_size, search_buffer_capacity});
+    auto results = svs::QueryResult<size_t>{queries.size(), k};
+    impl->search(results.view(), queries, sp);
+
+    svs::threads::parallel_for(
+        impl->get_threadpool_handle(),
+        svs::threads::StaticPartition(n),
+        [&](auto is, auto SVS_UNUSED(tid)) {
+            for(auto i : is) {
+                for(idx_t j = 0; j < k; ++j) {
+                    labels[j + i * k] = results.index(i, j);
+                    distances[j + i * k] = results.distance(i, j);
+                }
+            }
+        }
+    );
+}
+
+void IndexSVSUncompressed::init_impl(idx_t n, const float* x, const std::vector<size_t>& labels) {
+    auto data = svs::data::SimpleData<float>(n, d);
+
+    auto threadpool = svs::threads::as_threadpool(num_threads);
+
+    svs::threads::parallel_for(
+        threadpool,
+        svs::threads::StaticPartition(n),
+        [&](auto is, auto SVS_UNUSED(tid)) {
+            for(auto i : is) {
+                data.set_datum(i, std::span<const float>(x + i * d, d));
+            }
+        }
+    );
+
+    svs::index::vamana::VamanaBuildParameters build_parameters{alpha, graph_max_degree, construction_window_size, max_candidate_pool_size, prune_to, use_full_search_history};
+
+    switch (metric_type) {
+        case METRIC_INNER_PRODUCT:
+          impl = std::make_unique<svs::DynamicVamana>(svs::DynamicVamana::build<float>(build_parameters, std::move(data), labels, svs::DistanceIP(), std::move(threadpool)));
+          break;
+        case METRIC_L2:
+          impl = std::make_unique<svs::DynamicVamana>(svs::DynamicVamana::build<float>(build_parameters, std::move(data), labels, svs::DistanceL2(), std::move(threadpool)));
+          break;
+        default:
+          FAISS_ASSERT(!"not supported SVS distance");
+    }
+}
+
+} // namespace faiss
diff --git a/faiss/IndexSVSUncompressed.h b/faiss/IndexSVSUncompressed.h
new file mode 100644
index 000000000..7537e931a
--- /dev/null
+++ b/faiss/IndexSVSUncompressed.h
@@ -0,0 +1,67 @@
+/*
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+
+#pragma once
+
+#include <vector>
+#include <numeric>
+
+#include "faiss/Index.h"
+#include <faiss/impl/FaissAssert.h>
+
+#include "svs/orchestrators/vamana.h"
+#include "svs/orchestrators/dynamic_vamana.h"
+
+namespace faiss {
+
+struct IndexSVSUncompressed : Index {
+
+  IndexSVSUncompressed(
+      idx_t d, 
+      MetricType metric = METRIC_L2,
+      idx_t num_threads = 32,
+      idx_t graph_max_degree = 64
+  );
+
+  ~IndexSVSUncompressed() override;
+
+  void add(idx_t n, const float* x) override;
+
+  void search(
+      idx_t n,
+      const float* x,
+      idx_t k,
+      float* distances,
+      idx_t* labels,
+      const SearchParameters* params = nullptr) const override;
+
+  void reset();
+
+  private:
+
+    void init_impl(idx_t n, const float* x, const std::vector<size_t>& labels);
+
+    // sequential labels
+    size_t nlabels{0};
+
+    std::unique_ptr<svs::DynamicVamana> impl;
+
+
+    size_t num_threads;
+    // default parameters
+    // can be tuned by providing APIs
+    idx_t graph_max_degree = 64;
+    float alpha = 1.2;
+    idx_t search_window_size = 10;
+    idx_t search_buffer_capacity = 10;
+    idx_t construction_window_size = 40;
+    idx_t max_candidate_pool_size = 200;
+    idx_t prune_to = 60;
+    bool use_full_search_history = true;
+};
+
+} // namespace faiss
diff --git a/tutorial/cpp/10-SVS.cpp b/tutorial/cpp/10-SVS.cpp
new file mode 100644
index 000000000..1b51a22e0
--- /dev/null
+++ b/tutorial/cpp/10-SVS.cpp
@@ -0,0 +1,73 @@
+/*
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+
+#include <cassert>
+#include <cstdio>
+#include <cstdlib>
+#include <random>
+
+#include <faiss/IndexSVSUncompressed.h>
+
+using idx_t = faiss::idx_t;
+
+int main() {
+    int d = 64;      // dimension
+    int nb = 100000; // database size
+    int nq = 10000;  // nb of queries
+
+    std::mt19937 rng;
+    std::uniform_real_distribution<> distrib;
+
+    float* xb = new float[d * nb];
+    float* xq = new float[d * nq];
+
+    for (int i = 0; i < nb; i++) {
+        for (int j = 0; j < d; j++)
+            xb[d * i + j] = distrib(rng);
+        xb[d * i] += i / 1000.;
+    }
+
+    for (int i = 0; i < nq; i++) {
+        for (int j = 0; j < d; j++)
+            xq[d * i + j] = distrib(rng);
+        xq[d * i] += i / 1000.;
+    }
+
+    int k = 4;
+
+    faiss::IndexSVSUncompressed index(d);
+    index.add(nb, xb);
+
+    { // search xq
+        idx_t* I = new idx_t[k * nq];
+        float* D = new float[k * nq];
+
+        index.search(nq, xq, k, D, I);
+
+        printf("I=\n");
+        for (int i = nq - 5; i < nq; i++) {
+            for (int j = 0; j < k; j++)
+                printf("%5zd ", I[i * k + j]);
+            printf("\n");
+        }
+
+        printf("D=\n");
+        for (int i = nq - 5; i < nq; i++) {
+            for (int j = 0; j < k; j++)
+                printf("%5f ", D[i * k + j]);
+            printf("\n");
+        }
+
+        delete[] I;
+        delete[] D;
+    }
+
+    delete[] xb;
+    delete[] xq;
+
+    return 0;
+}
diff --git a/tutorial/cpp/CMakeLists.txt b/tutorial/cpp/CMakeLists.txt
index 045c1bb09..701f07849 100644
--- a/tutorial/cpp/CMakeLists.txt
+++ b/tutorial/cpp/CMakeLists.txt
@@ -29,3 +29,6 @@ target_link_libraries(8-PQFastScanRefine PRIVATE faiss)
 
 add_executable(9-RefineComparison EXCLUDE_FROM_ALL 9-RefineComparison.cpp)
 target_link_libraries(9-RefineComparison PRIVATE faiss)
+
+add_executable(10-SVS EXCLUDE_FROM_ALL 10-SVS.cpp)
+target_link_libraries(10-SVS PRIVATE faiss)
-- 
2.39.5 (Apple Git-154)


From 0bd1fdd5e5bb14a5f8a19aeab436f4a14ddc3f94 Mon Sep 17 00:00:00 2001
From: Andreas Huber <andreas.huber@intel.com>
Date: Mon, 21 Jul 2025 03:03:03 -0700
Subject: [PATCH 02/38] initial naive additional of SVS i/o

---
 faiss/IndexSVSUncompressed.cpp | 233 +++++++++++++++++++++++++++------
 faiss/IndexSVSUncompressed.h   |  68 +++++-----
 faiss/impl/index_read.cpp      |  26 ++++
 faiss/impl/index_write.cpp     |  28 ++++
 tests/CMakeLists.txt           |   1 +
 tests/test_svs.cpp             |  54 ++++++++
 6 files changed, 331 insertions(+), 79 deletions(-)
 create mode 100644 tests/test_svs.cpp

diff --git a/faiss/IndexSVSUncompressed.cpp b/faiss/IndexSVSUncompressed.cpp
index f2f612d43..cff1d8ed7 100644
--- a/faiss/IndexSVSUncompressed.cpp
+++ b/faiss/IndexSVSUncompressed.cpp
@@ -8,25 +8,116 @@
 #include <faiss/IndexSVSUncompressed.h>
 #include "faiss/Index.h"
 
+#include "svs/core/data.h"
+
+#include <filesystem>
+#include <sstream>
+
 namespace faiss {
 
-IndexSVSUncompressed::IndexSVSUncompressed(
-    idx_t d, 
-    MetricType metric,
-    idx_t num_threads,
-    idx_t graph_max_degree
-):Index(d, metric), num_threads{num_threads}, graph_max_degree{graph_max_degree} {
+namespace detail {
+struct SVSTempDirectory {
+    std::filesystem::path root;
+    std::filesystem::path config;
+    std::filesystem::path graph;
+    std::filesystem::path data;
+
+    SVSTempDirectory() {
+        root = std::filesystem::temp_directory_path() /
+                ("faiss_svs_" + std::to_string(std::rand()));
+        config = root / "config";
+        graph = root / "graph";
+        data = root / "data";
+
+        std::filesystem::create_directories(config);
+        std::filesystem::create_directories(graph);
+        std::filesystem::create_directories(data);
+    }
+
+    ~SVSTempDirectory() {
+        std::error_code ec;
+        std::filesystem::remove_all(root, ec); // best-effort cleanup
+    }
+};
+
+void write_files_to_stream(const SVSTempDirectory& tmp, std::ostream& out) {
+    for (const auto& dir : {tmp.config, tmp.graph, tmp.data}) {
+        const std::string dir_name = dir.filename().string(); // "config", etc.
+        for (const auto& entry : std::filesystem::directory_iterator(dir)) {
+            const std::string filename = entry.path().filename().string();
+
+            const uint64_t dir_len = dir_name.size();
+            const uint64_t file_len = filename.size();
+            const uint64_t file_size = std::filesystem::file_size(entry.path());
+
+            out.write(reinterpret_cast<const char*>(&dir_len), sizeof(dir_len));
+            out.write(dir_name.data(), dir_len);
+
+            out.write(
+                    reinterpret_cast<const char*>(&file_len), sizeof(file_len));
+            out.write(filename.data(), file_len);
+
+            out.write(
+                    reinterpret_cast<const char*>(&file_size),
+                    sizeof(file_size));
+
+            std::ifstream in(entry.path(), std::ios::binary);
+            FAISS_THROW_IF_NOT_MSG(
+                    in, "Failed to open temp SVS file for reading");
+
+            out << in.rdbuf();
+        }
+    }
 }
 
-void IndexSVSUncompressed::add(idx_t n, const float* x) {
+void write_stream_to_files(std::istream& in, const SVSTempDirectory& tmp) {
+    while (in && in.peek() != EOF) {
+        uint64_t dir_len, file_len, file_size;
+
+        in.read(reinterpret_cast<char*>(&dir_len), sizeof(dir_len));
+        std::string dir_name(dir_len, '\0');
+        in.read(dir_name.data(), dir_len);
+
+        in.read(reinterpret_cast<char*>(&file_len), sizeof(file_len));
+        std::string filename(file_len, '\0');
+        in.read(filename.data(), file_len);
+
+        in.read(reinterpret_cast<char*>(&file_size), sizeof(file_size));
+        std::vector<char> buffer(file_size);
+        in.read(buffer.data(), file_size);
+
+        std::filesystem::path base;
+        if (dir_name == "config") {
+            base = tmp.config;
+        } else if (dir_name == "graph") {
+            base = tmp.graph;
+        } else if (dir_name == "data") {
+            base = tmp.data;
+        } else {
+            FAISS_THROW_IF_NOT_MSG(false, "Unknown SVS subdirectory name");
+        }
+
+        std::filesystem::path full_path = base / filename;
+        std::ofstream out(full_path, std::ios::binary);
+        FAISS_THROW_IF_NOT_MSG(out, "Failed to open temp SVS file for writing");
+        out.write(buffer.data(), buffer.size());
+    }
+}
+
+} // namespace detail
 
+IndexSVSUncompressed::IndexSVSUncompressed() = default;
+
+IndexSVSUncompressed::IndexSVSUncompressed(idx_t d, MetricType metric)
+        : Index(d, metric) {}
+
+void IndexSVSUncompressed::add(idx_t n, const float* x) {
     // construct sequential labels
     std::vector<size_t> labels(n);
     std::iota(labels.begin(), labels.end(), nlabels);
     nlabels += n;
 
-
-    if(!impl) {
+    if (!impl) {
         init_impl(n, x, labels);
         return;
     }
@@ -40,17 +131,15 @@ void IndexSVSUncompressed::reset() {
     nlabels = 0;
 }
 
-IndexSVSUncompressed::~IndexSVSUncompressed() {
-}
+IndexSVSUncompressed::~IndexSVSUncompressed() {}
 
 void IndexSVSUncompressed::search(
-    idx_t n,
-    const float* x,
-    idx_t k,
-    float* distances,
-    idx_t* labels,
-    const SearchParameters* params
-) const {
+        idx_t n,
+        const float* x,
+        idx_t k,
+        float* distances,
+        idx_t* labels,
+        const SearchParameters* params) const {
     FAISS_THROW_IF_NOT(k > 0);
 
     auto queries = svs::data::ConstSimpleDataView<float>(x, n, d);
@@ -62,45 +151,103 @@ void IndexSVSUncompressed::search(
     impl->search(results.view(), queries, sp);
 
     svs::threads::parallel_for(
-        impl->get_threadpool_handle(),
-        svs::threads::StaticPartition(n),
-        [&](auto is, auto SVS_UNUSED(tid)) {
-            for(auto i : is) {
-                for(idx_t j = 0; j < k; ++j) {
-                    labels[j + i * k] = results.index(i, j);
-                    distances[j + i * k] = results.distance(i, j);
+            impl->get_threadpool_handle(),
+            svs::threads::StaticPartition(n),
+            [&](auto is, auto SVS_UNUSED(tid)) {
+                for (auto i : is) {
+                    for (idx_t j = 0; j < k; ++j) {
+                        labels[j + i * k] = results.index(i, j);
+                        distances[j + i * k] = results.distance(i, j);
+                    }
                 }
-            }
-        }
-    );
+            });
 }
 
-void IndexSVSUncompressed::init_impl(idx_t n, const float* x, const std::vector<size_t>& labels) {
+void IndexSVSUncompressed::init_impl(
+        idx_t n,
+        const float* x,
+        const std::vector<size_t>& labels) {
     auto data = svs::data::SimpleData<float>(n, d);
 
     auto threadpool = svs::threads::as_threadpool(num_threads);
 
     svs::threads::parallel_for(
-        threadpool,
-        svs::threads::StaticPartition(n),
-        [&](auto is, auto SVS_UNUSED(tid)) {
-            for(auto i : is) {
-                data.set_datum(i, std::span<const float>(x + i * d, d));
-            }
-        }
-    );
+            threadpool,
+            svs::threads::StaticPartition(n),
+            [&](auto is, auto SVS_UNUSED(tid)) {
+                for (auto i : is) {
+                    data.set_datum(i, std::span<const float>(x + i * d, d));
+                }
+            });
+
+    svs::index::vamana::VamanaBuildParameters build_parameters{
+            alpha,
+            graph_max_degree,
+            construction_window_size,
+            max_candidate_pool_size,
+            prune_to,
+            use_full_search_history};
+
+    switch (metric_type) {
+        case METRIC_INNER_PRODUCT:
+            impl = std::make_unique<svs::DynamicVamana>(
+                    svs::DynamicVamana::build<float>(
+                            build_parameters,
+                            std::move(data),
+                            labels,
+                            svs::DistanceIP(),
+                            std::move(threadpool)));
+            break;
+        case METRIC_L2:
+            impl = std::make_unique<svs::DynamicVamana>(
+                    svs::DynamicVamana::build<float>(
+                            build_parameters,
+                            std::move(data),
+                            labels,
+                            svs::DistanceL2(),
+                            std::move(threadpool)));
+            break;
+        default:
+            FAISS_ASSERT(!"not supported SVS distance");
+    }
+}
+
+void IndexSVSUncompressed::serialize_impl(std::ostream& out) const {
+    FAISS_THROW_IF_NOT_MSG(
+            impl, "Cannot serialize: SVS index not initialized.");
+
+    // Write index to temporary files and concatenate the contents
+    detail::SVSTempDirectory tmp;
+    impl->save(tmp.config, tmp.graph, tmp.data);
+    detail::write_files_to_stream(tmp, out);
+}
 
-    svs::index::vamana::VamanaBuildParameters build_parameters{alpha, graph_max_degree, construction_window_size, max_candidate_pool_size, prune_to, use_full_search_history};
+void IndexSVSUncompressed::deserialize_impl(std::istream& in) {
+    // Write stream to files that can be read by DynamicVamana::assemble()
+    detail::SVSTempDirectory tmp;
+    detail::write_stream_to_files(in, tmp);
 
     switch (metric_type) {
         case METRIC_INNER_PRODUCT:
-          impl = std::make_unique<svs::DynamicVamana>(svs::DynamicVamana::build<float>(build_parameters, std::move(data), labels, svs::DistanceIP(), std::move(threadpool)));
-          break;
+            impl = std::make_unique<svs::DynamicVamana>(
+                    svs::DynamicVamana::assemble<float>(
+                            tmp.config.string(),
+                            svs::GraphLoader(tmp.graph.string()),
+                            svs::VectorDataLoader<float>(tmp.data.string()),
+                            svs::distance::DistanceIP(),
+                            num_threads));
+            break;
         case METRIC_L2:
-          impl = std::make_unique<svs::DynamicVamana>(svs::DynamicVamana::build<float>(build_parameters, std::move(data), labels, svs::DistanceL2(), std::move(threadpool)));
-          break;
+            impl = std::make_unique<svs::DynamicVamana>(
+                    svs::DynamicVamana::assemble<float>(
+                            tmp.config.string(),
+                            svs::GraphLoader(tmp.graph.string()),
+                            svs::VectorDataLoader<float>(tmp.data.string()),
+                            svs::distance::DistanceL2(),
+                            num_threads));
+            break;
         default:
-          FAISS_ASSERT(!"not supported SVS distance");
+            FAISS_ASSERT(!"not supported SVS distance");
     }
 }
 
diff --git a/faiss/IndexSVSUncompressed.h b/faiss/IndexSVSUncompressed.h
index 7537e931a..cea53ad1c 100644
--- a/faiss/IndexSVSUncompressed.h
+++ b/faiss/IndexSVSUncompressed.h
@@ -7,61 +7,57 @@
 
 #pragma once
 
-#include <vector>
 #include <numeric>
+#include <vector>
 
-#include "faiss/Index.h"
 #include <faiss/impl/FaissAssert.h>
+#include "faiss/Index.h"
 
-#include "svs/orchestrators/vamana.h"
 #include "svs/orchestrators/dynamic_vamana.h"
+#include "svs/orchestrators/vamana.h"
 
 namespace faiss {
 
 struct IndexSVSUncompressed : Index {
+    size_t num_threads = 32;
+    // default parameters -- can be tuned by providing APIs
+    idx_t graph_max_degree = 64;
+    float alpha = 1.2;
+    idx_t search_window_size = 10;
+    idx_t search_buffer_capacity = 10;
+    idx_t construction_window_size = 40;
+    idx_t max_candidate_pool_size = 200;
+    idx_t prune_to = 60;
+    bool use_full_search_history = true;
 
-  IndexSVSUncompressed(
-      idx_t d, 
-      MetricType metric = METRIC_L2,
-      idx_t num_threads = 32,
-      idx_t graph_max_degree = 64
-  );
-
-  ~IndexSVSUncompressed() override;
+    // sequential labels
+    size_t nlabels{0};
 
-  void add(idx_t n, const float* x) override;
+    IndexSVSUncompressed();
 
-  void search(
-      idx_t n,
-      const float* x,
-      idx_t k,
-      float* distances,
-      idx_t* labels,
-      const SearchParameters* params = nullptr) const override;
+    IndexSVSUncompressed(idx_t d, MetricType metric = METRIC_L2);
 
-  void reset();
+    ~IndexSVSUncompressed() override;
 
-  private:
+    void add(idx_t n, const float* x) override;
 
-    void init_impl(idx_t n, const float* x, const std::vector<size_t>& labels);
+    void search(
+            idx_t n,
+            const float* x,
+            idx_t k,
+            float* distances,
+            idx_t* labels,
+            const SearchParameters* params = nullptr) const override;
 
-    // sequential labels
-    size_t nlabels{0};
+    void reset();
 
-    std::unique_ptr<svs::DynamicVamana> impl;
+    void serialize_impl(std::ostream& out) const;
+    void deserialize_impl(std::istream& in);
 
+   private:
+    void init_impl(idx_t n, const float* x, const std::vector<size_t>& labels);
 
-    size_t num_threads;
-    // default parameters
-    // can be tuned by providing APIs
-    idx_t graph_max_degree = 64;
-    float alpha = 1.2;
-    idx_t search_window_size = 10;
-    idx_t search_buffer_capacity = 10;
-    idx_t construction_window_size = 40;
-    idx_t max_candidate_pool_size = 200;
-    idx_t prune_to = 60;
-    bool use_full_search_history = true;
+    std::unique_ptr<svs::DynamicVamana> impl;
 };
 
 } // namespace faiss
diff --git a/faiss/impl/index_read.cpp b/faiss/impl/index_read.cpp
index 2e453c857..a4cd68418 100644
--- a/faiss/impl/index_read.cpp
+++ b/faiss/impl/index_read.cpp
@@ -45,6 +45,7 @@
 #include <faiss/IndexRaBitQ.h>
 #include <faiss/IndexRefine.h>
 #include <faiss/IndexRowwiseMinMax.h>
+#include <faiss/IndexSVSUncompressed.h>
 #include <faiss/IndexScalarQuantizer.h>
 #include <faiss/MetaIndexes.h>
 #include <faiss/VectorTransform.h>
@@ -1227,6 +1228,31 @@ Index* read_index(IOReader* f, int io_flags) {
         READ1(ivrq->qb);
         read_InvertedLists(ivrq, f, io_flags);
         idx = ivrq;
+    } else if (h == fourcc("SvUC")) {
+        auto svsuc = new IndexSVSUncompressed();
+
+        // Read class properties
+        READ1(svsuc->d);
+        READ1(svsuc->metric_type);
+        READ1(svsuc->num_threads);
+        READ1(svsuc->graph_max_degree);
+        READ1(svsuc->alpha);
+        READ1(svsuc->search_window_size);
+        READ1(svsuc->search_buffer_capacity);
+        READ1(svsuc->construction_window_size);
+        READ1(svsuc->max_candidate_pool_size);
+        READ1(svsuc->prune_to);
+        READ1(svsuc->use_full_search_history);
+
+        // Read the binary blob from which impl will be reconstructed
+        uint64_t blob_size;
+        READ1(blob_size);
+        std::string blob(blob_size, '\0');
+        READANDCHECK(blob.data(), blob_size);
+        std::stringstream ss(std::move(blob));
+        svsuc->deserialize_impl(ss);
+
+        idx = svsuc;
     } else {
         FAISS_THROW_FMT(
                 "Index type 0x%08x (\"%s\") not recognized",
diff --git a/faiss/impl/index_write.cpp b/faiss/impl/index_write.cpp
index 14f8f9a85..6fe4513b3 100644
--- a/faiss/impl/index_write.cpp
+++ b/faiss/impl/index_write.cpp
@@ -43,6 +43,7 @@
 #include <faiss/IndexRaBitQ.h>
 #include <faiss/IndexRefine.h>
 #include <faiss/IndexRowwiseMinMax.h>
+#include <faiss/IndexSVSUncompressed.h>
 #include <faiss/IndexScalarQuantizer.h>
 #include <faiss/MetaIndexes.h>
 #include <faiss/VectorTransform.h>
@@ -879,6 +880,33 @@ void write_index(const Index* idx, IOWriter* f, int io_flags) {
         WRITE1(ivrq->by_residual);
         WRITE1(ivrq->qb);
         write_InvertedLists(ivrq->invlists, f);
+    } else if (
+            const IndexSVSUncompressed* svsuc =
+                    dynamic_cast<const IndexSVSUncompressed*>(idx)) {
+        uint32_t h = fourcc("SvUC"); // TODO: clarify fourcc code for SVS
+        // Write header tag
+        WRITE1(h);
+
+        WRITE1(svsuc->d);
+        WRITE1(svsuc->metric_type);
+        WRITE1(svsuc->num_threads);
+        WRITE1(svsuc->graph_max_degree);
+        WRITE1(svsuc->alpha);
+        WRITE1(svsuc->search_window_size);
+        WRITE1(svsuc->search_buffer_capacity);
+        WRITE1(svsuc->construction_window_size);
+        WRITE1(svsuc->max_candidate_pool_size);
+        WRITE1(svsuc->prune_to);
+        WRITE1(svsuc->use_full_search_history);
+
+        std::stringstream ss;
+        svsuc->serialize_impl(ss);
+        std::string blob = ss.str();
+
+        // Write blob size and contents
+        uint64_t blob_size = blob.size();
+        WRITE1(blob_size);
+        WRITEANDCHECK(blob.data(), blob_size);
     } else {
         FAISS_THROW_MSG("don't know how to serialize this type of index");
     }
diff --git a/tests/CMakeLists.txt b/tests/CMakeLists.txt
index 285b9090e..3c37c7e64 100644
--- a/tests/CMakeLists.txt
+++ b/tests/CMakeLists.txt
@@ -38,6 +38,7 @@ set(FAISS_TEST_SRC
   test_hamming.cpp
   test_mmap.cpp
   test_zerocopy.cpp
+  test_svs.cpp  # TODO: should be guarded by FAISS_ENABLE_SVS
 )
 
 add_executable(faiss_test ${FAISS_TEST_SRC})
diff --git a/tests/test_svs.cpp b/tests/test_svs.cpp
new file mode 100644
index 000000000..75877041c
--- /dev/null
+++ b/tests/test_svs.cpp
@@ -0,0 +1,54 @@
+/*
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+
+#include <faiss/Index.h>
+#include <faiss/IndexSVSUncompressed.h>
+#include <faiss/index_io.h>
+#include <gtest/gtest.h>
+
+TEST(SVSIO, WriteAndReadIndex) {
+    const faiss::idx_t d = 64;
+    faiss::IndexSVSUncompressed index(d);
+    std::vector<float> xb(d * 100);
+    std::mt19937 gen(123);
+    std::uniform_real_distribution<float> dis(0.0f, 1.0f);
+    for (size_t i = 0; i < xb.size(); ++i) {
+        xb[i] = dis(gen);
+    }
+    index.add(100, xb.data());
+
+    const std::string path = "/tmp/test_svs_index.faiss";
+
+    // Serialize
+    ASSERT_NO_THROW({ faiss::write_index(&index, path.c_str()); });
+
+    // Deserialize
+    faiss::IndexSVSUncompressed* loaded = nullptr;
+    ASSERT_NO_THROW({
+        loaded = dynamic_cast<faiss::IndexSVSUncompressed*>(
+                faiss::read_index(path.c_str()));
+    });
+
+    // Basic checks
+    ASSERT_NE(loaded, nullptr);
+    EXPECT_EQ(loaded->d, index.d);
+    EXPECT_EQ(loaded->metric_type, index.metric_type);
+    EXPECT_EQ(loaded->num_threads, index.num_threads);
+    EXPECT_EQ(loaded->graph_max_degree, index.graph_max_degree);
+    EXPECT_EQ(loaded->alpha, index.alpha);
+    EXPECT_EQ(loaded->search_window_size, index.search_window_size);
+    EXPECT_EQ(loaded->search_buffer_capacity, index.search_buffer_capacity);
+    EXPECT_EQ(loaded->construction_window_size, index.construction_window_size);
+    EXPECT_EQ(loaded->max_candidate_pool_size, index.max_candidate_pool_size);
+    EXPECT_EQ(loaded->prune_to, index.prune_to);
+    EXPECT_EQ(loaded->use_full_search_history, index.use_full_search_history);
+
+    // Question: Save/load of SVS indices is tested within SVS. Do we still want
+    // to validate `loaded->impl`?
+
+    delete loaded;
+}
-- 
2.39.5 (Apple Git-154)


From 6885f300bfedc3293698bdc25d27dc33c3e0a29e Mon Sep 17 00:00:00 2001
From: Andreas Huber <andreas.huber@intel.com>
Date: Mon, 21 Jul 2025 04:38:05 -0700
Subject: [PATCH 03/38] use Tempfilename

---
 tests/test_svs.cpp | 13 ++++++++++---
 1 file changed, 10 insertions(+), 3 deletions(-)

diff --git a/tests/test_svs.cpp b/tests/test_svs.cpp
index 75877041c..cc900c326 100644
--- a/tests/test_svs.cpp
+++ b/tests/test_svs.cpp
@@ -10,6 +10,12 @@
 #include <faiss/index_io.h>
 #include <gtest/gtest.h>
 
+#include "test_util.h"
+
+namespace {
+pthread_mutex_t temp_file_mutex = PTHREAD_MUTEX_INITIALIZER;
+}
+
 TEST(SVSIO, WriteAndReadIndex) {
     const faiss::idx_t d = 64;
     faiss::IndexSVSUncompressed index(d);
@@ -21,16 +27,17 @@ TEST(SVSIO, WriteAndReadIndex) {
     }
     index.add(100, xb.data());
 
-    const std::string path = "/tmp/test_svs_index.faiss";
+    std::string temp_filename_template = "/tmp/faiss_svs_test_XXXXXX";
+    Tempfilename filename(&temp_file_mutex, temp_filename_template);
 
     // Serialize
-    ASSERT_NO_THROW({ faiss::write_index(&index, path.c_str()); });
+    ASSERT_NO_THROW({ faiss::write_index(&index, filename.c_str()); });
 
     // Deserialize
     faiss::IndexSVSUncompressed* loaded = nullptr;
     ASSERT_NO_THROW({
         loaded = dynamic_cast<faiss::IndexSVSUncompressed*>(
-                faiss::read_index(path.c_str()));
+                faiss::read_index(filename.c_str()));
     });
 
     // Basic checks
-- 
2.39.5 (Apple Git-154)


From 02159407a5f4f7d00085d3de0bb8fca0e906f858 Mon Sep 17 00:00:00 2001
From: Andreas Huber <andreas.huber@intel.com>
Date: Mon, 21 Jul 2025 04:38:19 -0700
Subject: [PATCH 04/38] Add I/O to example

---
 tutorial/cpp/10-SVS.cpp | 38 ++++++++++++++++++++++++++++++++++++++
 1 file changed, 38 insertions(+)

diff --git a/tutorial/cpp/10-SVS.cpp b/tutorial/cpp/10-SVS.cpp
index 1b51a22e0..1243d107c 100644
--- a/tutorial/cpp/10-SVS.cpp
+++ b/tutorial/cpp/10-SVS.cpp
@@ -11,6 +11,7 @@
 #include <random>
 
 #include <faiss/IndexSVSUncompressed.h>
+#include <faiss/index_io.h>
 
 using idx_t = faiss::idx_t;
 
@@ -66,8 +67,45 @@ int main() {
         delete[] D;
     }
 
+    std::cout << "Persisting index to disk and reloading." << std::endl;
+
+    faiss::write_index(&index, "/tmp/test_svs_index.faiss");
+    faiss::IndexSVSUncompressed* reloaded =
+            dynamic_cast<faiss::IndexSVSUncompressed*>(
+                    faiss::read_index("/tmp/test_svs_index.faiss"));
+    FAISS_THROW_IF_NOT_MSG(reloaded, "Failed to reload index from disk");
+
+    { // search xq
+        idx_t* I = new idx_t[k * nq];
+        float* D = new float[k * nq];
+
+        reloaded->search(nq, xq, k, D, I);
+
+        printf("I=\n");
+        for (int i = nq - 5; i < nq; i++) {
+            for (int j = 0; j < k; j++)
+                printf("%5zd ", I[i * k + j]);
+            printf("\n");
+        }
+
+        printf("D=\n");
+        for (int i = nq - 5; i < nq; i++) {
+            for (int j = 0; j < k; j++)
+                printf("%5f ", D[i * k + j]);
+            printf("\n");
+        }
+
+        delete[] I;
+        delete[] D;
+    }
+
+    delete reloaded;
+
     delete[] xb;
     delete[] xq;
 
+    // delete the temporary file
+    std::remove("/tmp/test_svs_index.faiss");
+
     return 0;
 }
-- 
2.39.5 (Apple Git-154)


From d4d12261ffb41a1c027b79c7bd72940cb5c09c95 Mon Sep 17 00:00:00 2001
From: Aaron Lin <aaron.dl.lin@intel.com>
Date: Tue, 22 Jul 2025 10:21:34 -0700
Subject: [PATCH 05/38] revise, add LVQ, and python bindings

---
 faiss/CMakeLists.txt                          |  10 +-
 ...{IndexSVSUncompressed.cpp => IndexSVS.cpp} | 123 ++++++++++--------
 faiss/{IndexSVSUncompressed.h => IndexSVS.h}  |  49 +++----
 faiss/IndexSVSLVQ4x4.cpp                      |  68 ++++++++++
 faiss/IndexSVSLVQ4x4.h                        |  44 +++++++
 faiss/python/__init__.py                      |   2 +
 faiss/python/swigfaiss.swig                   |   8 ++
 tutorial/cpp/10-SVS.cpp                       |   6 +-
 tutorial/cpp/11-SVSLVQ4x4.cpp                 |  74 +++++++++++
 tutorial/cpp/CMakeLists.txt                   |   6 +
 tutorial/python/10-SVS.py                     |  38 ++++++
 11 files changed, 342 insertions(+), 86 deletions(-)
 rename faiss/{IndexSVSUncompressed.cpp => IndexSVS.cpp} (76%)
 rename faiss/{IndexSVSUncompressed.h => IndexSVS.h} (54%)
 create mode 100644 faiss/IndexSVSLVQ4x4.cpp
 create mode 100644 faiss/IndexSVSLVQ4x4.h
 create mode 100644 tutorial/cpp/11-SVSLVQ4x4.cpp
 create mode 100644 tutorial/python/10-SVS.py

diff --git a/faiss/CMakeLists.txt b/faiss/CMakeLists.txt
index 78143e95f..937967b9e 100644
--- a/faiss/CMakeLists.txt
+++ b/faiss/CMakeLists.txt
@@ -47,7 +47,9 @@ set(FAISS_SRC
   IndexScalarQuantizer.cpp
   IndexShards.cpp
   IndexShardsIVF.cpp
-  IndexSVSUncompressed.cpp
+  IndexSVS.cpp
+  IndexSVSLVQ4x4.cpp
+  #IndexSVSLeanVec4x4.cpp
   IndexNeuralNetCodec.cpp
   MatrixStats.cpp
   MetaIndexes.cpp
@@ -146,7 +148,9 @@ set(FAISS_HEADERS
   IndexScalarQuantizer.h
   IndexShards.h
   IndexShardsIVF.h
-  IndexSVSUncompressed.h
+  IndexSVS.h
+  IndexSVSLVQ4x4.h
+  #IndexSVSLeanVec4x4.h
   MatrixStats.h
   MetaIndexes.h
   MetricType.h
@@ -332,7 +336,7 @@ FetchContent_MakeAvailable(svs)
 list(APPEND CMAKE_PREFIX_PATH "${svs_SOURCE_DIR}")
 find_package(svs REQUIRED)
 
-target_link_libraries(faiss PUBLIC svs::svs)
+target_link_libraries(faiss PUBLIC svs::svs svs::svs_shared_library)
 
 # Handle `#include <faiss/foo.h>`.
 # Handle `#include <svs/foo.h>`.
diff --git a/faiss/IndexSVSUncompressed.cpp b/faiss/IndexSVS.cpp
similarity index 76%
rename from faiss/IndexSVSUncompressed.cpp
rename to faiss/IndexSVS.cpp
index cff1d8ed7..7e2bf23c4 100644
--- a/faiss/IndexSVSUncompressed.cpp
+++ b/faiss/IndexSVS.cpp
@@ -5,7 +5,7 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/IndexSVSUncompressed.h>
+#include <faiss/IndexSVS.h>
 #include "faiss/Index.h"
 
 #include "svs/core/data.h"
@@ -106,34 +106,47 @@ void write_stream_to_files(std::istream& in, const SVSTempDirectory& tmp) {
 
 } // namespace detail
 
-IndexSVSUncompressed::IndexSVSUncompressed() = default;
+IndexSVS::IndexSVS() : Index{}, num_threads{1}, graph_max_degree{64} {}
 
-IndexSVSUncompressed::IndexSVSUncompressed(idx_t d, MetricType metric)
-        : Index(d, metric) {}
+IndexSVS::IndexSVS(idx_t d, MetricType metric) : Index(d, metric) {}
 
-void IndexSVSUncompressed::add(idx_t n, const float* x) {
-    // construct sequential labels
-    std::vector<size_t> labels(n);
-    std::iota(labels.begin(), labels.end(), nlabels);
-    nlabels += n;
+IndexSVS::~IndexSVS() {
+    if (impl) {
+        delete impl;
+    }
+}
 
+void IndexSVS::add(idx_t n, const float* x) {
     if (!impl) {
-        init_impl(n, x, labels);
+        init_impl(n, x);
         return;
     }
 
+    // construct sequential labels
+    std::vector<size_t> labels(n);
+
+    svs::threads::parallel_for(
+            impl->get_threadpool_handle(),
+            svs::threads::StaticPartition(n),
+            [&](auto is, auto SVS_UNUSED(tid)) {
+                for (auto i : is) {
+                    labels[i] = ntotal + i;
+                }
+            });
+    ntotal += n;
+
     auto data = svs::data::ConstSimpleDataView<float>(x, n, d);
     impl->add_points(data, labels);
 }
 
-void IndexSVSUncompressed::reset() {
-    impl.reset();
-    nlabels = 0;
+void IndexSVS::reset() {
+    if (impl) {
+        delete impl;
+    }
+    ntotal = 0;
 }
 
-IndexSVSUncompressed::~IndexSVSUncompressed() {}
-
-void IndexSVSUncompressed::search(
+void IndexSVS::search(
         idx_t n,
         const float* x,
         idx_t k,
@@ -141,34 +154,25 @@ void IndexSVSUncompressed::search(
         idx_t* labels,
         const SearchParameters* params) const {
     FAISS_THROW_IF_NOT(k > 0);
+    FAISS_THROW_IF_NOT(is_trained);
 
     auto queries = svs::data::ConstSimpleDataView<float>(x, n, d);
 
     // TODO: use params for SVS search parameters
     auto sp = impl->get_search_parameters();
     sp.buffer_config({search_window_size, search_buffer_capacity});
-    auto results = svs::QueryResult<size_t>{queries.size(), k};
-    impl->search(results.view(), queries, sp);
-
-    svs::threads::parallel_for(
-            impl->get_threadpool_handle(),
-            svs::threads::StaticPartition(n),
-            [&](auto is, auto SVS_UNUSED(tid)) {
-                for (auto i : is) {
-                    for (idx_t j = 0; j < k; ++j) {
-                        labels[j + i * k] = results.index(i, j);
-                        distances[j + i * k] = results.distance(i, j);
-                    }
-                }
-            });
+    // TODO: faiss use int64_t as label whereas SVS uses size_t?
+    auto results = svs::QueryResultView<size_t>{
+            svs::MatrixView<size_t>{
+                    svs::make_dims(n, k),
+                    static_cast<size_t*>(static_cast<void*>(labels))},
+            svs::MatrixView<float>{svs::make_dims(n, k), distances}};
+    impl->search(results, queries, sp);
 }
 
-void IndexSVSUncompressed::init_impl(
-        idx_t n,
-        const float* x,
-        const std::vector<size_t>& labels) {
+void IndexSVS::init_impl(idx_t n, const float* x) {
+    std::vector<size_t> labels(n);
     auto data = svs::data::SimpleData<float>(n, d);
-
     auto threadpool = svs::threads::as_threadpool(num_threads);
 
     svs::threads::parallel_for(
@@ -177,8 +181,10 @@ void IndexSVSUncompressed::init_impl(
             [&](auto is, auto SVS_UNUSED(tid)) {
                 for (auto i : is) {
                     data.set_datum(i, std::span<const float>(x + i * d, d));
+                    labels[i] = ntotal + i;
                 }
             });
+    ntotal += n;
 
     svs::index::vamana::VamanaBuildParameters build_parameters{
             alpha,
@@ -190,20 +196,20 @@ void IndexSVSUncompressed::init_impl(
 
     switch (metric_type) {
         case METRIC_INNER_PRODUCT:
-            impl = std::make_unique<svs::DynamicVamana>(
+            impl = new svs::DynamicVamana(
                     svs::DynamicVamana::build<float>(
-                            build_parameters,
+                            std::move(build_parameters),
                             std::move(data),
-                            labels,
+                            std::move(labels),
                             svs::DistanceIP(),
                             std::move(threadpool)));
             break;
         case METRIC_L2:
-            impl = std::make_unique<svs::DynamicVamana>(
+            impl = new svs::DynamicVamana(
                     svs::DynamicVamana::build<float>(
-                            build_parameters,
+                            std::move(build_parameters),
                             std::move(data),
-                            labels,
+                            std::move(labels),
                             svs::DistanceL2(),
                             std::move(threadpool)));
             break;
@@ -212,7 +218,7 @@ void IndexSVSUncompressed::init_impl(
     }
 }
 
-void IndexSVSUncompressed::serialize_impl(std::ostream& out) const {
+void IndexSVS::serialize_impl(std::ostream& out) const {
     FAISS_THROW_IF_NOT_MSG(
             impl, "Cannot serialize: SVS index not initialized.");
 
@@ -222,29 +228,32 @@ void IndexSVSUncompressed::serialize_impl(std::ostream& out) const {
     detail::write_files_to_stream(tmp, out);
 }
 
-void IndexSVSUncompressed::deserialize_impl(std::istream& in) {
+void IndexSVS::deserialize_impl(std::istream& in) {
+    FAISS_THROW_IF_MSG(
+            impl, "Cannot deserialize: SVS index already initialized.");
+
     // Write stream to files that can be read by DynamicVamana::assemble()
     detail::SVSTempDirectory tmp;
     detail::write_stream_to_files(in, tmp);
 
     switch (metric_type) {
         case METRIC_INNER_PRODUCT:
-            impl = std::make_unique<svs::DynamicVamana>(
-                    svs::DynamicVamana::assemble<float>(
-                            tmp.config.string(),
-                            svs::GraphLoader(tmp.graph.string()),
-                            svs::VectorDataLoader<float>(tmp.data.string()),
-                            svs::distance::DistanceIP(),
-                            num_threads));
+            impl = new svs::DynamicVamana(
+                    svs::DynamicVamana::build<float>(
+                            build_parameters,
+                            std::move(data),
+                            labels,
+                            svs::DistanceIP(),
+                            std::move(threadpool)));
             break;
         case METRIC_L2:
-            impl = std::make_unique<svs::DynamicVamana>(
-                    svs::DynamicVamana::assemble<float>(
-                            tmp.config.string(),
-                            svs::GraphLoader(tmp.graph.string()),
-                            svs::VectorDataLoader<float>(tmp.data.string()),
-                            svs::distance::DistanceL2(),
-                            num_threads));
+            impl = new svs::DynamicVamana(
+                    svs::DynamicVamana::build<float>(
+                            build_parameters,
+                            std::move(data),
+                            labels,
+                            svs::DistanceL2(),
+                            std::move(threadpool)));
             break;
         default:
             FAISS_ASSERT(!"not supported SVS distance");
diff --git a/faiss/IndexSVSUncompressed.h b/faiss/IndexSVS.h
similarity index 54%
rename from faiss/IndexSVSUncompressed.h
rename to faiss/IndexSVS.h
index cea53ad1c..bccaebeff 100644
--- a/faiss/IndexSVSUncompressed.h
+++ b/faiss/IndexSVS.h
@@ -18,26 +18,17 @@
 
 namespace faiss {
 
-struct IndexSVSUncompressed : Index {
-    size_t num_threads = 32;
-    // default parameters -- can be tuned by providing APIs
-    idx_t graph_max_degree = 64;
-    float alpha = 1.2;
-    idx_t search_window_size = 10;
-    idx_t search_buffer_capacity = 10;
-    idx_t construction_window_size = 40;
-    idx_t max_candidate_pool_size = 200;
-    idx_t prune_to = 60;
-    bool use_full_search_history = true;
-
-    // sequential labels
-    size_t nlabels{0};
-
-    IndexSVSUncompressed();
+struct IndexSVS : Index {
 
-    IndexSVSUncompressed(idx_t d, MetricType metric = METRIC_L2);
+  IndexSVS(
+      idx_t d,
+      MetricType metric = METRIC_L2,
+      idx_t num_threads = 1,
+      idx_t graph_max_degree = 64
+  );
+    // rn OMP_NUM_THREADS
 
-    ~IndexSVSUncompressed() override;
+  ~IndexSVS() override;
 
     void add(idx_t n, const float* x) override;
 
@@ -51,13 +42,25 @@ struct IndexSVSUncompressed : Index {
 
     void reset();
 
-    void serialize_impl(std::ostream& out) const;
-    void deserialize_impl(std::istream& in);
+  private:
 
-   private:
-    void init_impl(idx_t n, const float* x, const std::vector<size_t>& labels);
+    virtual void init_impl(idx_t n, const float* x);
 
-    std::unique_ptr<svs::DynamicVamana> impl;
+    // sequential labels
+    size_t nlabels{0};
+
+    svs::DynamicVamana* impl{nullptr};
+
+    size_t num_threads;
+    idx_t graph_max_degree;
+    // default parameters
+    float alpha = 1.2;
+    size_t search_window_size = 10;
+    size_t search_buffer_capacity = 10;
+    size_t construction_window_size = 40;
+    size_t max_candidate_pool_size = 200;
+    size_t prune_to = 60;
+    bool use_full_search_history = true;
 };
 
 } // namespace faiss
diff --git a/faiss/IndexSVSLVQ4x4.cpp b/faiss/IndexSVSLVQ4x4.cpp
new file mode 100644
index 000000000..08ca9da1c
--- /dev/null
+++ b/faiss/IndexSVSLVQ4x4.cpp
@@ -0,0 +1,68 @@
+/*
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+
+#include <faiss/IndexSVSLVQ4x4.h>
+
+namespace faiss {
+
+IndexSVSLVQ4x4::IndexSVSLVQ4x4(
+    idx_t d, 
+    MetricType metric,
+    size_t num_threads,
+    size_t graph_max_degree
+): IndexSVS(d, metric, num_threads, graph_max_degree) {
+}
+
+IndexSVSLVQ4x4::~IndexSVSLVQ4x4() {
+}
+
+void IndexSVSLVQ4x4::init_impl(idx_t n, const float* x) {
+
+    // TODO: support ConstSimpleDataView in SVS shared/static lib
+    const auto data = svs::data::SimpleDataView<float>(const_cast<float*>(x), n, d);
+    std::vector<size_t> labels(n);
+    auto threadpool = svs::threads::as_threadpool(num_threads);
+    auto compressed_data = storage_type::compress(data, threadpool, 0, blocked_alloc_type{});
+
+    svs::threads::parallel_for(
+        threadpool,
+        svs::threads::StaticPartition(n),
+        [&](auto is, auto SVS_UNUSED(tid)) {
+            for(auto i : is) {
+                labels[i] = ntotal + i;
+            }
+        }
+    );
+    ntotal += n;
+
+
+    svs::index::vamana::VamanaBuildParameters build_parameters{alpha, graph_max_degree, construction_window_size, max_candidate_pool_size, prune_to, use_full_search_history};
+    switch (metric_type) {
+        case METRIC_INNER_PRODUCT:
+          impl = new svs::DynamicVamana(svs::DynamicVamana::build<float>(
+                std::move(build_parameters),
+                std::move(compressed_data), 
+                std::move(labels),
+                svs::DistanceIP(),
+                std::move(threadpool))
+              );
+          break;
+        case METRIC_L2:
+          impl = new svs::DynamicVamana(svs::DynamicVamana::build<float>(
+                std::move(build_parameters),
+                std::move(compressed_data),
+                std::move(labels),
+                svs::DistanceL2(),
+                std::move(threadpool))
+              );
+          break;
+        default:
+          FAISS_ASSERT(!"not supported SVS distance");
+    }
+}
+
+} // namespace faiss
diff --git a/faiss/IndexSVSLVQ4x4.h b/faiss/IndexSVSLVQ4x4.h
new file mode 100644
index 000000000..d51f28fe9
--- /dev/null
+++ b/faiss/IndexSVSLVQ4x4.h
@@ -0,0 +1,44 @@
+/*
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+
+#pragma once
+
+#include <faiss/IndexSVS.h>
+
+#include "svs/extensions/vamana/lvq.h"
+
+namespace faiss {
+
+  // LVQ 4x0
+  // LVQ 4x4
+  // LVQ 4x8
+  //
+  //
+  // allocator
+  // threadpool
+
+struct IndexSVSLVQ4x4 : IndexSVS {
+
+  using blocked_alloc_type = svs::data::Blocked<svs::lib::Allocator<std::byte>>;
+
+  using strategy_type = svs::quantization::lvq::Turbo<16, 8>;
+
+  using storage_type = svs::quantization::lvq::LVQDataset<4, 4, svs::Dynamic, strategy_type, blocked_alloc_type>;
+
+  IndexSVSLVQ4x4(
+      idx_t d, 
+      MetricType metric = METRIC_L2,
+      size_t num_threads = 32,
+      size_t graph_max_degree = 64
+  );
+
+  ~IndexSVSLVQ4x4() override;
+
+  void init_impl(idx_t n, const float* x) override;
+};
+
+} // namespace faiss
diff --git a/faiss/python/__init__.py b/faiss/python/__init__.py
index 7266da71f..89daf3e02 100644
--- a/faiss/python/__init__.py
+++ b/faiss/python/__init__.py
@@ -220,6 +220,8 @@ add_ref_in_constructor(IDSelectorTranslated, slice(2))
 add_ref_in_constructor(IDSelectorXOr, slice(2))
 add_ref_in_constructor(IndexIVFIndependentQuantizer, slice(3))
 
+add_ref_in_constructor(IndexSVS, 0)
+
 # seems really marginal...
 # remove_ref_from_method(IndexReplicas, 'removeIndex', 0)
 
diff --git a/faiss/python/swigfaiss.swig b/faiss/python/swigfaiss.swig
index 061cb497e..348112bac 100644
--- a/faiss/python/swigfaiss.swig
+++ b/faiss/python/swigfaiss.swig
@@ -194,6 +194,9 @@ typedef uint64_t size_t;
 #include <faiss/IndexRaBitQ.h>
 #include <faiss/IndexIVFRaBitQ.h>
 
+#include <faiss/IndexSVS.h>
+#include <faiss/IndexSVSLVQ4x4.h>
+
 %}
 
 /********************************************************
@@ -680,6 +683,9 @@ struct faiss::simd16uint16 {};
 
 %include <faiss/utils/approx_topk/mode.h>
 
+%include  <faiss/IndexSVS.h>
+%include  <faiss/IndexSVSLVQ4x4.h>
+
 #ifdef GPU_WRAPPER
 
 #ifdef FAISS_ENABLE_ROCM
@@ -826,6 +832,8 @@ struct faiss::simd16uint16 {};
     DOWNCAST ( IndexRandom )
     DOWNCAST ( IndexRowwiseMinMax )
     DOWNCAST ( IndexRowwiseMinMaxFP16 )
+    DOWNCAST ( IndexSVSLVQ4x4 )
+    DOWNCAST ( IndexSVS )
 #ifdef GPU_WRAPPER
 #ifdef FAISS_ENABLE_CUVS
     DOWNCAST_GPU ( GpuIndexCagra )
diff --git a/tutorial/cpp/10-SVS.cpp b/tutorial/cpp/10-SVS.cpp
index 1243d107c..48c761984 100644
--- a/tutorial/cpp/10-SVS.cpp
+++ b/tutorial/cpp/10-SVS.cpp
@@ -10,7 +10,7 @@
 #include <cstdlib>
 #include <random>
 
-#include <faiss/IndexSVSUncompressed.h>
+#include <faiss/IndexSVS.h>
 #include <faiss/index_io.h>
 
 using idx_t = faiss::idx_t;
@@ -40,14 +40,14 @@ int main() {
 
     int k = 4;
 
-    faiss::IndexSVSUncompressed index(d);
+    faiss::IndexSVS index(d);
     index.add(nb, xb);
 
     { // search xq
         idx_t* I = new idx_t[k * nq];
         float* D = new float[k * nq];
 
-        index.search(nq, xq, k, D, I);
+        index.search(nq, xb, k, D, I);
 
         printf("I=\n");
         for (int i = nq - 5; i < nq; i++) {
diff --git a/tutorial/cpp/11-SVSLVQ4x4.cpp b/tutorial/cpp/11-SVSLVQ4x4.cpp
new file mode 100644
index 000000000..b22389359
--- /dev/null
+++ b/tutorial/cpp/11-SVSLVQ4x4.cpp
@@ -0,0 +1,74 @@
+/*
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+
+#include <cassert>
+#include <cstdio>
+#include <cstdlib>
+#include <random>
+
+#include <faiss/IndexSVSLVQ4x4.h>
+
+using idx_t = faiss::idx_t;
+
+int main() {
+    int d = 64;      // dimension
+    int nb = 100000; // database size
+    int nq = 10000;  // nb of queries
+
+    std::mt19937 rng;
+    std::uniform_real_distribution<> distrib;
+
+    float* xb = new float[d * nb];
+    float* xq = new float[d * nq];
+
+    for (int i = 0; i < nb; i++) {
+        for (int j = 0; j < d; j++)
+            xb[d * i + j] = distrib(rng);
+        xb[d * i] += i / 1000.;
+    }
+
+    for (int i = 0; i < nq; i++) {
+        for (int j = 0; j < d; j++)
+            xq[d * i + j] = distrib(rng);
+        xq[d * i] += i / 1000.;
+    }
+
+    int k = 4;
+
+    faiss::IndexSVSLVQ4x4 index(d);
+    index.add(nb, xb);
+
+    { // search xq
+        idx_t* I = new idx_t[k * nq];
+        float* D = new float[k * nq];
+
+        index.search(nq, xq, k, D, I);
+
+        printf("I=\n");
+        for (int i = nq - 5; i < nq; i++) {
+            for (int j = 0; j < k; j++)
+                printf("%5zd ", I[i * k + j]);
+            printf("\n");
+        }
+
+        printf("D=\n");
+        for (int i = nq - 5; i < nq; i++) {
+            for (int j = 0; j < k; j++)
+                printf("%5f ", D[i * k + j]);
+            printf("\n");
+        }
+
+        delete[] I;
+        delete[] D;
+    }
+
+    delete[] xb;
+    delete[] xq;
+
+    return 0;
+}
+
diff --git a/tutorial/cpp/CMakeLists.txt b/tutorial/cpp/CMakeLists.txt
index 701f07849..ded59b585 100644
--- a/tutorial/cpp/CMakeLists.txt
+++ b/tutorial/cpp/CMakeLists.txt
@@ -32,3 +32,9 @@ target_link_libraries(9-RefineComparison PRIVATE faiss)
 
 add_executable(10-SVS EXCLUDE_FROM_ALL 10-SVS.cpp)
 target_link_libraries(10-SVS PRIVATE faiss)
+
+add_executable(11-SVSLVQ4x4 EXCLUDE_FROM_ALL 11-SVSLVQ4x4.cpp)
+target_link_libraries(11-SVSLVQ4x4 PRIVATE faiss)
+
+add_executable(12-SVSLeanVec4x4 EXCLUDE_FROM_ALL 12-SVSLeanVec4x4.cpp)
+target_link_libraries(12-SVSLeanVec4x4 PRIVATE faiss)
diff --git a/tutorial/python/10-SVS.py b/tutorial/python/10-SVS.py
new file mode 100644
index 000000000..181345c31
--- /dev/null
+++ b/tutorial/python/10-SVS.py
@@ -0,0 +1,38 @@
+# Copyright (c) Meta Platforms, Inc. and affiliates.
+#
+# This source code is licensed under the MIT license found in the
+# LICENSE file in the root directory of this source tree.
+
+import numpy as np
+
+d = 64                           # dimension
+nb = 100000                      # database size
+nq = 10000                       # nb of queries
+np.random.seed(1234)             # make reproducible
+xb = np.random.random((nb, d)).astype('float32')
+xb[:, 0] += np.arange(nb) / 1000.
+xq = np.random.random((nq, d)).astype('float32')
+xq[:, 0] += np.arange(nq) / 1000.
+
+import faiss                        # make faiss available
+index = faiss.IndexSVS(d, num_threads)           # build the index
+
+# index = faiss.IndexSVSLVQ4x4(d)   # build the SVSLVQ4x4 index
+# index = faiss.IndexSVSLVQ4x8(d)   # build the SVSLVQ4x4 index
+# index = faiss.IndexSVSLVQ8x0(d)   # build the SVSLVQ4x4 index
+
+# index = faiss.IndexSVSLeanVec4x4(d)   # build the SVSLVQ4x4 index
+# index = faiss.IndexSVSLeanVec4x8(d)   # build the SVSLVQ4x4 index
+
+print(index.is_trained)
+index.add(xb)                  # add vectors to the index
+print(index.ntotal)
+
+k = 4                          # we want to see 4 nearest neighbors
+D, I = index.search(xb[:5], k) # sanity check
+print(I)
+print(D)
+D, I = index.search(xq, k)     # actual search
+print(I[:5])                   # neighbors of the 5 first queries
+print(I[-5:])                  # neighbors of the 5 last queries
+
-- 
2.39.5 (Apple Git-154)


From 48904f3119883d87b39f29407f83652e14bf00af Mon Sep 17 00:00:00 2001
From: Aaron Lin <aaron.dl.lin@intel.com>
Date: Tue, 22 Jul 2025 10:22:28 -0700
Subject: [PATCH 06/38] on going work

---
 faiss/IndexSVSFlat.cpp            | 115 ++++++++++++++++++++++++++++++
 faiss/IndexSVSFlat.h              |  54 ++++++++++++++
 faiss/IndexSVSLVQ4x8.cpp          |  24 +++++++
 faiss/IndexSVSLVQ4x8.h            |  33 +++++++++
 faiss/IndexSVSLeanVec4x4.cpp      |  84 ++++++++++++++++++++++
 faiss/IndexSVSLeanVec4x4.h        |  45 ++++++++++++
 tutorial/cpp/12-SVSLeanVec4x4.cpp |  74 +++++++++++++++++++
 7 files changed, 429 insertions(+)
 create mode 100644 faiss/IndexSVSFlat.cpp
 create mode 100644 faiss/IndexSVSFlat.h
 create mode 100644 faiss/IndexSVSLVQ4x8.cpp
 create mode 100644 faiss/IndexSVSLVQ4x8.h
 create mode 100644 faiss/IndexSVSLeanVec4x4.cpp
 create mode 100644 faiss/IndexSVSLeanVec4x4.h
 create mode 100644 tutorial/cpp/12-SVSLeanVec4x4.cpp

diff --git a/faiss/IndexSVSFlat.cpp b/faiss/IndexSVSFlat.cpp
new file mode 100644
index 000000000..4498dd0e9
--- /dev/null
+++ b/faiss/IndexSVSFlat.cpp
@@ -0,0 +1,115 @@
+/*
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+
+#include <faiss/IndexSVSFlat.h>
+#include "faiss/Index.h"
+
+namespace faiss {
+
+IndexSVSFlat::IndexSVSFlat(
+    idx_t d, 
+    MetricType metric,
+    idx_t num_threads,
+):Index(d, metric), num_threads{num_threads} {
+}
+
+void IndexSVSFlat::add(idx_t n, const float* x) {
+
+    if(!impl) {
+        init_impl(n, x);
+        return;
+    }
+
+    // construct sequential labels
+    std::vector<size_t> labels(n);
+
+    svs::threads::parallel_for(
+        impl->get_threadpool_handle(),
+        svs::threads::StaticPartition(n),
+        [&](auto is, auto SVS_UNUSED(tid)) {
+            for(auto i : is) {
+                labels[i] = nlabels + i;
+            }
+        }
+    );
+
+    auto data = svs::data::ConstSimpleDataView<float>(x, n, d);
+    impl->add_points(data, labels);
+}
+
+void IndexSVSFlat::reset() {
+    impl.reset();
+}
+
+IndexSVSFlat::~IndexSVSFlat() {
+}
+
+void IndexSVSFlat::search(
+    idx_t n,
+    const float* x,
+    idx_t k,
+    float* distances,
+    idx_t* labels,
+    const SearchParameters* params
+) const {
+    FAISS_THROW_IF_NOT(k > 0);
+
+    auto queries = svs::data::ConstSimpleDataView<float>(x, n, d);
+
+    auto results = svs::QueryResult<size_t>{queries.size(), k};
+    // TODO: Tuable Flat parameters 
+    impl->search(results.view(), queries, {});
+
+    svs::threads::parallel_for(
+        impl->get_threadpool_handle(),
+        svs::threads::StaticPartition(n),
+        [&](auto is, auto SVS_UNUSED(tid)) {
+            for(auto i : is) {
+                for(idx_t j = 0; j < k; ++j) {
+                    labels[j + i * k] = results.index(i, j);
+                    distances[j + i * k] = results.distance(i, j);
+                }
+            }
+        }
+    );
+}
+
+void IndexSVSFlat::init_impl(idx_t n, const float* x) {
+    auto data = svs::data::SimpleData<float>(n, d);
+    auto threadpool = svs::threads::as_threadpool(num_threads);
+
+    svs::threads::parallel_for(
+        threadpool,
+        svs::threads::StaticPartition(n),
+        [&](auto is, auto SVS_UNUSED(tid)) {
+            for(auto i : is) {
+                data.set_datum(i, std::span<const float>(x + i * d, d));
+            }
+        }
+    );
+
+    switch (metric_type) {
+        case METRIC_INNER_PRODUCT:
+          impl = std::make_unique<svs::index::flat::FlatIndex>(
+                std::move(data), 
+                svs::DistanceIP(),
+                std::move(threadpool)
+              );
+          break;
+        case METRIC_L2:
+          impl = std::make_unique<svs::index::flat::FlatIndex>(
+                std::move(data),
+                svs::DistanceL2(),
+                std::move(threadpool)
+              );
+          break;
+        default:
+          FAISS_ASSERT(!"not supported SVS distance");
+    }
+}
+
+} // namespace faiss
diff --git a/faiss/IndexSVSFlat.h b/faiss/IndexSVSFlat.h
new file mode 100644
index 000000000..906405230
--- /dev/null
+++ b/faiss/IndexSVSFlat.h
@@ -0,0 +1,54 @@
+/*
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+
+#pragma once
+
+#include <vector>
+#include <numeric>
+
+#include "faiss/Index.h"
+#include <faiss/impl/FaissAssert.h>
+
+#include "svs/index/flat/flat.h"
+
+namespace faiss {
+
+struct IndexSVSFlatFlat : IndexSVS {
+
+  IndexSVSFlat(
+      idx_t d, 
+      MetricType metric = METRIC_L2,
+      idx_t num_threads = 32,
+      idx_t graph_max_degree = 64
+  );
+
+  ~IndexSVSFlat() override;
+
+  void add(idx_t n, const float* x) override;
+
+  void search(
+      idx_t n,
+      const float* x,
+      idx_t k,
+      float* distances,
+      idx_t* labels,
+      const SearchParameters* params = nullptr) const override;
+
+  void reset();
+
+  virtual void init_impl(idx_t n, const float* x);
+
+  // sequential labels
+  size_t nlabels{0};
+
+  std::unique_ptr<svs::DynamicVamana> impl;
+
+
+  size_t num_threads;
+};
+
+} // namespace faiss
diff --git a/faiss/IndexSVSLVQ4x8.cpp b/faiss/IndexSVSLVQ4x8.cpp
new file mode 100644
index 000000000..39ae81b6d
--- /dev/null
+++ b/faiss/IndexSVSLVQ4x8.cpp
@@ -0,0 +1,24 @@
+
+/*
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+
+#include <faiss/IndexSVSLVQ4x8.h>
+
+namespace faiss {
+
+IndexSVSLVQ4x8::IndexSVSLVQ4x8(
+    idx_t d, 
+    MetricType metric,
+    idx_t num_threads,
+    idx_t graph_max_degree
+): IndexSVSLVQ4x4(d, metric, num_threads, graph_max_degree) {
+}
+
+IndexSVSLVQ4x8::~IndexSVSLVQ4x8() {
+}
+
+} // namespace faiss
diff --git a/faiss/IndexSVSLVQ4x8.h b/faiss/IndexSVSLVQ4x8.h
new file mode 100644
index 000000000..91ab61c16
--- /dev/null
+++ b/faiss/IndexSVSLVQ4x8.h
@@ -0,0 +1,33 @@
+
+/*
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+
+#pragma once
+#include <faiss/IndexSVSLVQ4x4.h>
+
+namespace faiss {
+
+struct IndexSVSLVQ4x8 : IndexSVSLVQ4x4 {
+
+  using blocked_alloc_type = svs::data::Blocked<svs::lib::Allocator<std::byte>>;
+
+  using strategy_type = svs::quantization::lvq::Turbo<16, 8>;
+
+  using storage_type = svs::quantization::lvq::LVQDataset<4, 8, svs::Dynamic, strategy_type, blocked_alloc_type>;
+
+  IndexSVSLVQ4x8(
+      idx_t d, 
+      MetricType metric = METRIC_L2,
+      idx_t num_threads = 32,
+      idx_t graph_max_degree = 64
+  );
+
+  ~IndexSVSLVQ4x8() override;
+
+};
+
+} // namespace faiss
diff --git a/faiss/IndexSVSLeanVec4x4.cpp b/faiss/IndexSVSLeanVec4x4.cpp
new file mode 100644
index 000000000..e4753b5cf
--- /dev/null
+++ b/faiss/IndexSVSLeanVec4x4.cpp
@@ -0,0 +1,84 @@
+/*
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+
+#include <faiss/IndexSVSLeanVec4x4.h>
+
+namespace faiss {
+
+IndexSVSLeanVec4x4::IndexSVSLeanVec4x4(
+    idx_t d, 
+    MetricType metric,
+    size_t num_threads,
+    size_t graph_max_degree,
+    size_t leanvec_dims
+): IndexSVS(d, metric, num_threads, graph_max_degree) {
+    leanvec_d = leanvec_dims == 0 ? d / 2 : leanvec_d;
+    is_trained = false;
+}
+
+IndexSVSLeanVec4x4::~IndexSVSLeanVec4x4() {
+}
+
+void IndexSVSLeanVec4x4::train(idx_t n, const float* x) {
+    auto data = svs::data::ConstSimpleDataView<float>(x, n, d);
+    auto means = utils::compute_medioid(data, num_threads);
+    leanvec_matrix = compute_leanvec_matrix<svs::Dynamic, svs::Dynamic>(data, means, num_threads, leanvec_d);
+    is_trained = true;
+}
+
+void IndexSVSLeanVec4x4::reset() {
+    is_trained = false;
+    IndexSVS::reset();
+}
+
+void IndexSVSLeanVec4x4::init_impl(idx_t n, const float* x) {
+
+    // TODO: support ConstSimpleDataView in SVS shared/static lib
+    const auto data = svs::data::SimpleDataView<float>(const_cast<float*>(x), n, d);
+    std::vector<size_t> labels(n);
+    auto threadpool = svs::threads::as_threadpool(num_threads);
+    auto compressed_data = storage_type::reduce(data, leanvec_matrix, threadpool, 0, leanvec_d, blocked_alloc_type{});
+
+    svs::threads::parallel_for(
+        threadpool,
+        svs::threads::StaticPartition(n),
+        [&](auto is, auto SVS_UNUSED(tid)) {
+            for(auto i : is) {
+                labels[i] = ntotal + i;
+            }
+        }
+    );
+    ntotal += n;
+
+
+    svs::index::vamana::VamanaBuildParameters build_parameters{alpha, graph_max_degree, construction_window_size, max_candidate_pool_size, prune_to, use_full_search_history};
+
+    switch (metric_type) {
+        case METRIC_INNER_PRODUCT:
+          impl = std::make_unique<svs::DynamicVamana>(svs::DynamicVamana::build<float>(
+                std::move(build_parameters),
+                std::move(compressed_data),
+                std::move(labels),
+                svs::DistanceIP(),
+                std::move(threadpool))
+              );
+          break;
+        case METRIC_L2:
+          impl = std::make_unique<svs::DynamicVamana>(svs::DynamicVamana::build<float>(
+                std::move(build_parameters),
+                std::move(compressed_data),
+                std::move(labels),
+                svs::DistanceL2(),
+                std::move(threadpool))
+              );
+          break;
+        default:
+          FAISS_ASSERT(!"not supported SVS distance");
+    }
+}
+
+} // namespace faiss
diff --git a/faiss/IndexSVSLeanVec4x4.h b/faiss/IndexSVSLeanVec4x4.h
new file mode 100644
index 000000000..0e11c2e04
--- /dev/null
+++ b/faiss/IndexSVSLeanVec4x4.h
@@ -0,0 +1,45 @@
+/*
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+
+#pragma once
+
+#include <faiss/IndexSVS.h>
+
+#include "svs/extensions/vamana/leanvec.h"
+
+namespace faiss {
+
+struct IndexSVSLeanVec4x4 : IndexSVS {
+
+  using blocked_alloc_type = svs::data::Blocked<svs::lib::Allocator<std::byte>>;
+
+  using storage_type = svs::leanvec::LeanDataset<svs::leanvec::UsingLVQ<4>, svs::leanvec::UsingLVQ<4>, svs::Dynamic, svs::Dynamic, blocked_alloc_type>;
+
+  using leanvec_matrix_type = svs::data::SimpleData<float>;
+
+  IndexSVSLeanVec4x4(
+      idx_t d, 
+      MetricType metric = METRIC_L2,
+      size_t num_threads = 32,
+      size_t graph_max_degree = 64,
+      size_t leanvec_dims = 0
+  );
+
+  ~IndexSVSLeanVec4x4() override;
+
+  void reset() override;
+
+  void train(idx_t n, const float* x) override;
+
+  void init_impl(idx_t n, const float* x) override;
+
+  size_t leanvec_d;
+
+  leanvec_matrix_type* leanvec_matrix;
+};
+
+} // namespace faiss
diff --git a/tutorial/cpp/12-SVSLeanVec4x4.cpp b/tutorial/cpp/12-SVSLeanVec4x4.cpp
new file mode 100644
index 000000000..8a247ce0d
--- /dev/null
+++ b/tutorial/cpp/12-SVSLeanVec4x4.cpp
@@ -0,0 +1,74 @@
+/*
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+
+#include <cassert>
+#include <cstdio>
+#include <cstdlib>
+#include <random>
+
+#include <faiss/IndexSVSLeanVec4x4.h>
+
+using idx_t = faiss::idx_t;
+
+int main() {
+    int d = 64;      // dimension
+    int nb = 100000; // database size
+    int nq = 10000;  // nb of queries
+
+    std::mt19937 rng;
+    std::uniform_real_distribution<> distrib;
+
+    float* xb = new float[d * nb];
+    float* xq = new float[d * nq];
+
+    for (int i = 0; i < nb; i++) {
+        for (int j = 0; j < d; j++)
+            xb[d * i + j] = distrib(rng);
+        xb[d * i] += i / 1000.;
+    }
+
+    for (int i = 0; i < nq; i++) {
+        for (int j = 0; j < d; j++)
+            xq[d * i + j] = distrib(rng);
+        xq[d * i] += i / 1000.;
+    }
+
+    int k = 4;
+
+    faiss::IndexSVSLeanVec4x4 index(d);
+    index.add(nb, xb);
+
+    { // search xq
+        idx_t* I = new idx_t[k * nq];
+        float* D = new float[k * nq];
+
+        index.search(nq, xq, k, D, I);
+
+        printf("I=\n");
+        for (int i = nq - 5; i < nq; i++) {
+            for (int j = 0; j < k; j++)
+                printf("%5zd ", I[i * k + j]);
+            printf("\n");
+        }
+
+        printf("D=\n");
+        for (int i = nq - 5; i < nq; i++) {
+            for (int j = 0; j < k; j++)
+                printf("%5f ", D[i * k + j]);
+            printf("\n");
+        }
+
+        delete[] I;
+        delete[] D;
+    }
+
+    delete[] xb;
+    delete[] xq;
+
+    return 0;
+}
+
-- 
2.39.5 (Apple Git-154)


From b4c768ab19aa546e80bb792a0ef27c690e5949e4 Mon Sep 17 00:00:00 2001
From: Andreas Huber <andreas.huber@intel.com>
Date: Wed, 23 Jul 2025 04:41:49 -0700
Subject: [PATCH 07/38] cleanup after cherry-picking aaron's latest commits

---
 faiss/IndexSVS.cpp              | 54 +++++++++---------
 faiss/IndexSVS.h                | 48 ++++++++--------
 faiss/IndexSVSLVQ4x4.cpp        | 75 ++++++++++++-------------
 faiss/IndexSVSLVQ4x4.h          | 35 ++++++------
 faiss/IndexSVSLVQ4x8.cpp        | 12 +---
 faiss/IndexSVSLVQ4x8.h          | 19 +++----
 faiss/impl/index_read.cpp       | 30 +++++-----
 faiss/impl/index_write.cpp      | 30 +++++-----
 tutorial/cpp/10-SVS.cpp         |  7 +--
 tutorial/cpp/13-tmp-svscomp.cpp | 98 +++++++++++++++++++++++++++++++++
 tutorial/cpp/CMakeLists.txt     |  3 +
 11 files changed, 244 insertions(+), 167 deletions(-)
 create mode 100644 tutorial/cpp/13-tmp-svscomp.cpp

diff --git a/faiss/IndexSVS.cpp b/faiss/IndexSVS.cpp
index 7e2bf23c4..7920df926 100644
--- a/faiss/IndexSVS.cpp
+++ b/faiss/IndexSVS.cpp
@@ -106,7 +106,7 @@ void write_stream_to_files(std::istream& in, const SVSTempDirectory& tmp) {
 
 } // namespace detail
 
-IndexSVS::IndexSVS() : Index{}, num_threads{1}, graph_max_degree{64} {}
+IndexSVS::IndexSVS() : Index{} {}
 
 IndexSVS::IndexSVS(idx_t d, MetricType metric) : Index(d, metric) {}
 
@@ -196,22 +196,20 @@ void IndexSVS::init_impl(idx_t n, const float* x) {
 
     switch (metric_type) {
         case METRIC_INNER_PRODUCT:
-            impl = new svs::DynamicVamana(
-                    svs::DynamicVamana::build<float>(
-                            std::move(build_parameters),
-                            std::move(data),
-                            std::move(labels),
-                            svs::DistanceIP(),
-                            std::move(threadpool)));
+            impl = new svs::DynamicVamana(svs::DynamicVamana::build<float>(
+                    std::move(build_parameters),
+                    std::move(data),
+                    std::move(labels),
+                    svs::DistanceIP(),
+                    std::move(threadpool)));
             break;
         case METRIC_L2:
-            impl = new svs::DynamicVamana(
-                    svs::DynamicVamana::build<float>(
-                            std::move(build_parameters),
-                            std::move(data),
-                            std::move(labels),
-                            svs::DistanceL2(),
-                            std::move(threadpool)));
+            impl = new svs::DynamicVamana(svs::DynamicVamana::build<float>(
+                    std::move(build_parameters),
+                    std::move(data),
+                    std::move(labels),
+                    svs::DistanceL2(),
+                    std::move(threadpool)));
             break;
         default:
             FAISS_ASSERT(!"not supported SVS distance");
@@ -238,22 +236,20 @@ void IndexSVS::deserialize_impl(std::istream& in) {
 
     switch (metric_type) {
         case METRIC_INNER_PRODUCT:
-            impl = new svs::DynamicVamana(
-                    svs::DynamicVamana::build<float>(
-                            build_parameters,
-                            std::move(data),
-                            labels,
-                            svs::DistanceIP(),
-                            std::move(threadpool)));
+            impl = new svs::DynamicVamana(svs::DynamicVamana::assemble<float>(
+                    tmp.config.string(),
+                    svs::GraphLoader(tmp.graph.string()),
+                    svs::VectorDataLoader<float>(tmp.data.string()),
+                    svs::distance::DistanceIP(),
+                    num_threads));
             break;
         case METRIC_L2:
-            impl = new svs::DynamicVamana(
-                    svs::DynamicVamana::build<float>(
-                            build_parameters,
-                            std::move(data),
-                            labels,
-                            svs::DistanceL2(),
-                            std::move(threadpool)));
+            impl = new svs::DynamicVamana(svs::DynamicVamana::assemble<float>(
+                    tmp.config.string(),
+                    svs::GraphLoader(tmp.graph.string()),
+                    svs::VectorDataLoader<float>(tmp.data.string()),
+                    svs::distance::DistanceL2(),
+                    num_threads));
             break;
         default:
             FAISS_ASSERT(!"not supported SVS distance");
diff --git a/faiss/IndexSVS.h b/faiss/IndexSVS.h
index bccaebeff..82bafb7cb 100644
--- a/faiss/IndexSVS.h
+++ b/faiss/IndexSVS.h
@@ -19,16 +19,25 @@
 namespace faiss {
 
 struct IndexSVS : Index {
+    // sequential labels
+    size_t nlabels{0};
 
-  IndexSVS(
-      idx_t d,
-      MetricType metric = METRIC_L2,
-      idx_t num_threads = 1,
-      idx_t graph_max_degree = 64
-  );
-    // rn OMP_NUM_THREADS
+    // default parameters
+    size_t num_threads = 1;
+    size_t graph_max_degree = 64;
+    float alpha = 1.2;
+    size_t search_window_size = 10;
+    size_t search_buffer_capacity = 10;
+    size_t construction_window_size = 40;
+    size_t max_candidate_pool_size = 200;
+    size_t prune_to = 60;
+    bool use_full_search_history = true;
 
-  ~IndexSVS() override;
+    IndexSVS();
+
+    IndexSVS(idx_t d, MetricType metric = METRIC_L2);
+
+    ~IndexSVS() override;
 
     void add(idx_t n, const float* x) override;
 
@@ -40,27 +49,16 @@ struct IndexSVS : Index {
             idx_t* labels,
             const SearchParameters* params = nullptr) const override;
 
-    void reset();
-
-  private:
+    void reset() override;
 
-    virtual void init_impl(idx_t n, const float* x);
-
-    // sequential labels
-    size_t nlabels{0};
+    void serialize_impl(std::ostream& out) const;
+    void deserialize_impl(std::istream& in);
 
+   protected:
     svs::DynamicVamana* impl{nullptr};
 
-    size_t num_threads;
-    idx_t graph_max_degree;
-    // default parameters
-    float alpha = 1.2;
-    size_t search_window_size = 10;
-    size_t search_buffer_capacity = 10;
-    size_t construction_window_size = 40;
-    size_t max_candidate_pool_size = 200;
-    size_t prune_to = 60;
-    bool use_full_search_history = true;
+   private:
+    virtual void init_impl(idx_t n, const float* x);
 };
 
 } // namespace faiss
diff --git a/faiss/IndexSVSLVQ4x4.cpp b/faiss/IndexSVSLVQ4x4.cpp
index 08ca9da1c..88a2c3586 100644
--- a/faiss/IndexSVSLVQ4x4.cpp
+++ b/faiss/IndexSVSLVQ4x4.cpp
@@ -9,59 +9,56 @@
 
 namespace faiss {
 
-IndexSVSLVQ4x4::IndexSVSLVQ4x4(
-    idx_t d, 
-    MetricType metric,
-    size_t num_threads,
-    size_t graph_max_degree
-): IndexSVS(d, metric, num_threads, graph_max_degree) {
-}
+IndexSVSLVQ4x4::IndexSVSLVQ4x4(idx_t d, MetricType metric)
+        : IndexSVS(d, metric) {}
 
-IndexSVSLVQ4x4::~IndexSVSLVQ4x4() {
-}
+IndexSVSLVQ4x4::~IndexSVSLVQ4x4() {}
 
 void IndexSVSLVQ4x4::init_impl(idx_t n, const float* x) {
-
     // TODO: support ConstSimpleDataView in SVS shared/static lib
-    const auto data = svs::data::SimpleDataView<float>(const_cast<float*>(x), n, d);
+    const auto data =
+            svs::data::SimpleDataView<float>(const_cast<float*>(x), n, d);
     std::vector<size_t> labels(n);
     auto threadpool = svs::threads::as_threadpool(num_threads);
-    auto compressed_data = storage_type::compress(data, threadpool, 0, blocked_alloc_type{});
+    auto compressed_data =
+            storage_type::compress(data, threadpool, 0, blocked_alloc_type{});
 
     svs::threads::parallel_for(
-        threadpool,
-        svs::threads::StaticPartition(n),
-        [&](auto is, auto SVS_UNUSED(tid)) {
-            for(auto i : is) {
-                labels[i] = ntotal + i;
-            }
-        }
-    );
+            threadpool,
+            svs::threads::StaticPartition(n),
+            [&](auto is, auto SVS_UNUSED(tid)) {
+                for (auto i : is) {
+                    labels[i] = ntotal + i;
+                }
+            });
     ntotal += n;
 
-
-    svs::index::vamana::VamanaBuildParameters build_parameters{alpha, graph_max_degree, construction_window_size, max_candidate_pool_size, prune_to, use_full_search_history};
+    svs::index::vamana::VamanaBuildParameters build_parameters{
+            alpha,
+            graph_max_degree,
+            construction_window_size,
+            max_candidate_pool_size,
+            prune_to,
+            use_full_search_history};
     switch (metric_type) {
         case METRIC_INNER_PRODUCT:
-          impl = new svs::DynamicVamana(svs::DynamicVamana::build<float>(
-                std::move(build_parameters),
-                std::move(compressed_data), 
-                std::move(labels),
-                svs::DistanceIP(),
-                std::move(threadpool))
-              );
-          break;
+            impl = new svs::DynamicVamana(svs::DynamicVamana::build<float>(
+                    std::move(build_parameters),
+                    std::move(compressed_data),
+                    std::move(labels),
+                    svs::DistanceIP(),
+                    std::move(threadpool)));
+            break;
         case METRIC_L2:
-          impl = new svs::DynamicVamana(svs::DynamicVamana::build<float>(
-                std::move(build_parameters),
-                std::move(compressed_data),
-                std::move(labels),
-                svs::DistanceL2(),
-                std::move(threadpool))
-              );
-          break;
+            impl = new svs::DynamicVamana(svs::DynamicVamana::build<float>(
+                    std::move(build_parameters),
+                    std::move(compressed_data),
+                    std::move(labels),
+                    svs::DistanceL2(),
+                    std::move(threadpool)));
+            break;
         default:
-          FAISS_ASSERT(!"not supported SVS distance");
+            FAISS_ASSERT(!"not supported SVS distance");
     }
 }
 
diff --git a/faiss/IndexSVSLVQ4x4.h b/faiss/IndexSVSLVQ4x4.h
index d51f28fe9..128df8505 100644
--- a/faiss/IndexSVSLVQ4x4.h
+++ b/faiss/IndexSVSLVQ4x4.h
@@ -13,32 +13,29 @@
 
 namespace faiss {
 
-  // LVQ 4x0
-  // LVQ 4x4
-  // LVQ 4x8
-  //
-  //
-  // allocator
-  // threadpool
+// LVQ 4x0
+// LVQ 4x4
+// LVQ 4x8
+//
+//
+// allocator
+// threadpool
 
 struct IndexSVSLVQ4x4 : IndexSVS {
+    using blocked_alloc_type =
+            svs::data::Blocked<svs::lib::Allocator<std::byte>>;
 
-  using blocked_alloc_type = svs::data::Blocked<svs::lib::Allocator<std::byte>>;
+    using strategy_type = svs::quantization::lvq::Turbo<16, 8>;
 
-  using strategy_type = svs::quantization::lvq::Turbo<16, 8>;
+    using storage_type = svs::quantization::lvq::
+            LVQDataset<4, 4, svs::Dynamic, strategy_type, blocked_alloc_type>;
 
-  using storage_type = svs::quantization::lvq::LVQDataset<4, 4, svs::Dynamic, strategy_type, blocked_alloc_type>;
+    IndexSVSLVQ4x4() = default;
+    IndexSVSLVQ4x4(idx_t d, MetricType metric = METRIC_L2);
 
-  IndexSVSLVQ4x4(
-      idx_t d, 
-      MetricType metric = METRIC_L2,
-      size_t num_threads = 32,
-      size_t graph_max_degree = 64
-  );
+    ~IndexSVSLVQ4x4() override;
 
-  ~IndexSVSLVQ4x4() override;
-
-  void init_impl(idx_t n, const float* x) override;
+    void init_impl(idx_t n, const float* x) override;
 };
 
 } // namespace faiss
diff --git a/faiss/IndexSVSLVQ4x8.cpp b/faiss/IndexSVSLVQ4x8.cpp
index 39ae81b6d..e10ea3195 100644
--- a/faiss/IndexSVSLVQ4x8.cpp
+++ b/faiss/IndexSVSLVQ4x8.cpp
@@ -10,15 +10,9 @@
 
 namespace faiss {
 
-IndexSVSLVQ4x8::IndexSVSLVQ4x8(
-    idx_t d, 
-    MetricType metric,
-    idx_t num_threads,
-    idx_t graph_max_degree
-): IndexSVSLVQ4x4(d, metric, num_threads, graph_max_degree) {
-}
+IndexSVSLVQ4x8::IndexSVSLVQ4x8(idx_t d, MetricType metric)
+        : IndexSVSLVQ4x4(d, metric) {}
 
-IndexSVSLVQ4x8::~IndexSVSLVQ4x8() {
-}
+IndexSVSLVQ4x8::~IndexSVSLVQ4x8() {}
 
 } // namespace faiss
diff --git a/faiss/IndexSVSLVQ4x8.h b/faiss/IndexSVSLVQ4x8.h
index 91ab61c16..2c81921ca 100644
--- a/faiss/IndexSVSLVQ4x8.h
+++ b/faiss/IndexSVSLVQ4x8.h
@@ -12,22 +12,19 @@
 namespace faiss {
 
 struct IndexSVSLVQ4x8 : IndexSVSLVQ4x4 {
+    using blocked_alloc_type =
+            svs::data::Blocked<svs::lib::Allocator<std::byte>>;
 
-  using blocked_alloc_type = svs::data::Blocked<svs::lib::Allocator<std::byte>>;
+    using strategy_type = svs::quantization::lvq::Turbo<16, 8>;
 
-  using strategy_type = svs::quantization::lvq::Turbo<16, 8>;
+    using storage_type = svs::quantization::lvq::
+            LVQDataset<4, 8, svs::Dynamic, strategy_type, blocked_alloc_type>;
 
-  using storage_type = svs::quantization::lvq::LVQDataset<4, 8, svs::Dynamic, strategy_type, blocked_alloc_type>;
+    IndexSVSLVQ4x8() = default;
 
-  IndexSVSLVQ4x8(
-      idx_t d, 
-      MetricType metric = METRIC_L2,
-      idx_t num_threads = 32,
-      idx_t graph_max_degree = 64
-  );
-
-  ~IndexSVSLVQ4x8() override;
+    IndexSVSLVQ4x8(idx_t d, MetricType metric = METRIC_L2);
 
+    ~IndexSVSLVQ4x8() override;
 };
 
 } // namespace faiss
diff --git a/faiss/impl/index_read.cpp b/faiss/impl/index_read.cpp
index a4cd68418..beb6500dc 100644
--- a/faiss/impl/index_read.cpp
+++ b/faiss/impl/index_read.cpp
@@ -45,7 +45,7 @@
 #include <faiss/IndexRaBitQ.h>
 #include <faiss/IndexRefine.h>
 #include <faiss/IndexRowwiseMinMax.h>
-#include <faiss/IndexSVSUncompressed.h>
+#include <faiss/IndexSVS.h>
 #include <faiss/IndexScalarQuantizer.h>
 #include <faiss/MetaIndexes.h>
 #include <faiss/VectorTransform.h>
@@ -1229,20 +1229,20 @@ Index* read_index(IOReader* f, int io_flags) {
         read_InvertedLists(ivrq, f, io_flags);
         idx = ivrq;
     } else if (h == fourcc("SvUC")) {
-        auto svsuc = new IndexSVSUncompressed();
+        auto svs = new IndexSVS();
 
         // Read class properties
-        READ1(svsuc->d);
-        READ1(svsuc->metric_type);
-        READ1(svsuc->num_threads);
-        READ1(svsuc->graph_max_degree);
-        READ1(svsuc->alpha);
-        READ1(svsuc->search_window_size);
-        READ1(svsuc->search_buffer_capacity);
-        READ1(svsuc->construction_window_size);
-        READ1(svsuc->max_candidate_pool_size);
-        READ1(svsuc->prune_to);
-        READ1(svsuc->use_full_search_history);
+        READ1(svs->d);
+        READ1(svs->metric_type);
+        READ1(svs->num_threads);
+        READ1(svs->graph_max_degree);
+        READ1(svs->alpha);
+        READ1(svs->search_window_size);
+        READ1(svs->search_buffer_capacity);
+        READ1(svs->construction_window_size);
+        READ1(svs->max_candidate_pool_size);
+        READ1(svs->prune_to);
+        READ1(svs->use_full_search_history);
 
         // Read the binary blob from which impl will be reconstructed
         uint64_t blob_size;
@@ -1250,9 +1250,9 @@ Index* read_index(IOReader* f, int io_flags) {
         std::string blob(blob_size, '\0');
         READANDCHECK(blob.data(), blob_size);
         std::stringstream ss(std::move(blob));
-        svsuc->deserialize_impl(ss);
+        svs->deserialize_impl(ss);
 
-        idx = svsuc;
+        idx = svs;
     } else {
         FAISS_THROW_FMT(
                 "Index type 0x%08x (\"%s\") not recognized",
diff --git a/faiss/impl/index_write.cpp b/faiss/impl/index_write.cpp
index 6fe4513b3..ba25a04d0 100644
--- a/faiss/impl/index_write.cpp
+++ b/faiss/impl/index_write.cpp
@@ -43,7 +43,7 @@
 #include <faiss/IndexRaBitQ.h>
 #include <faiss/IndexRefine.h>
 #include <faiss/IndexRowwiseMinMax.h>
-#include <faiss/IndexSVSUncompressed.h>
+#include <faiss/IndexSVS.h>
 #include <faiss/IndexScalarQuantizer.h>
 #include <faiss/MetaIndexes.h>
 #include <faiss/VectorTransform.h>
@@ -880,27 +880,25 @@ void write_index(const Index* idx, IOWriter* f, int io_flags) {
         WRITE1(ivrq->by_residual);
         WRITE1(ivrq->qb);
         write_InvertedLists(ivrq->invlists, f);
-    } else if (
-            const IndexSVSUncompressed* svsuc =
-                    dynamic_cast<const IndexSVSUncompressed*>(idx)) {
+    } else if (const IndexSVS* svs = dynamic_cast<const IndexSVS*>(idx)) {
         uint32_t h = fourcc("SvUC"); // TODO: clarify fourcc code for SVS
         // Write header tag
         WRITE1(h);
 
-        WRITE1(svsuc->d);
-        WRITE1(svsuc->metric_type);
-        WRITE1(svsuc->num_threads);
-        WRITE1(svsuc->graph_max_degree);
-        WRITE1(svsuc->alpha);
-        WRITE1(svsuc->search_window_size);
-        WRITE1(svsuc->search_buffer_capacity);
-        WRITE1(svsuc->construction_window_size);
-        WRITE1(svsuc->max_candidate_pool_size);
-        WRITE1(svsuc->prune_to);
-        WRITE1(svsuc->use_full_search_history);
+        WRITE1(svs->d);
+        WRITE1(svs->metric_type);
+        WRITE1(svs->num_threads);
+        WRITE1(svs->graph_max_degree);
+        WRITE1(svs->alpha);
+        WRITE1(svs->search_window_size);
+        WRITE1(svs->search_buffer_capacity);
+        WRITE1(svs->construction_window_size);
+        WRITE1(svs->max_candidate_pool_size);
+        WRITE1(svs->prune_to);
+        WRITE1(svs->use_full_search_history);
 
         std::stringstream ss;
-        svsuc->serialize_impl(ss);
+        svs->serialize_impl(ss);
         std::string blob = ss.str();
 
         // Write blob size and contents
diff --git a/tutorial/cpp/10-SVS.cpp b/tutorial/cpp/10-SVS.cpp
index 48c761984..c3f91cf4b 100644
--- a/tutorial/cpp/10-SVS.cpp
+++ b/tutorial/cpp/10-SVS.cpp
@@ -70,16 +70,15 @@ int main() {
     std::cout << "Persisting index to disk and reloading." << std::endl;
 
     faiss::write_index(&index, "/tmp/test_svs_index.faiss");
-    faiss::IndexSVSUncompressed* reloaded =
-            dynamic_cast<faiss::IndexSVSUncompressed*>(
-                    faiss::read_index("/tmp/test_svs_index.faiss"));
+    faiss::IndexSVS* reloaded = dynamic_cast<faiss::IndexSVS*>(
+            faiss::read_index("/tmp/test_svs_index.faiss"));
     FAISS_THROW_IF_NOT_MSG(reloaded, "Failed to reload index from disk");
 
     { // search xq
         idx_t* I = new idx_t[k * nq];
         float* D = new float[k * nq];
 
-        reloaded->search(nq, xq, k, D, I);
+        reloaded->search(nq, xb, k, D, I);
 
         printf("I=\n");
         for (int i = nq - 5; i < nq; i++) {
diff --git a/tutorial/cpp/13-tmp-svscomp.cpp b/tutorial/cpp/13-tmp-svscomp.cpp
new file mode 100644
index 000000000..a6c440e80
--- /dev/null
+++ b/tutorial/cpp/13-tmp-svscomp.cpp
@@ -0,0 +1,98 @@
+/*
+ * Example: IndexSVSUncompressed search on BigANN with QPS metric
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
+ * Licensed under the MIT license.
+ */
+
+#include <faiss/IndexSVSUncompressed.h>
+#include <faiss/index_io.h>
+#include <cassert>
+#include <chrono>
+#include <cstdio>
+#include <cstdlib>
+#include <iostream>
+#include <vector>
+
+// Helper to read float32 fvecs file
+void read_fvecs(
+        const char* filename,
+        std::vector<float>& data,
+        size_t& d,
+        size_t& n) {
+    FILE* f = fopen(filename, "rb");
+    assert(f);
+    int dim;
+    fread(&dim, sizeof(int), 1, f);
+    fseek(f, 0, SEEK_SET);
+    std::vector<int> buf(1);
+    size_t filesize = 0;
+    while (fread(buf.data(), sizeof(int), 1, f) == 1) {
+        fseek(f, dim * sizeof(float), SEEK_CUR);
+        filesize++;
+    }
+    n = filesize;
+    d = dim;
+    data.resize(n * d);
+    fseek(f, 0, SEEK_SET);
+    for (size_t i = 0; i < n; i++) {
+        fread(buf.data(), sizeof(int), 1, f);
+        fread(&data[i * d], sizeof(float), d, f);
+    }
+    fclose(f);
+}
+
+int main() {
+    // Paths to deep-10m f32 dataset files
+    const char* db_file = "/export/data/datasets/deep/deep_10m_f32.fvecs";
+    const char* query_file = "/export/data/datasets/deep/deep_queries.fvecs";
+    size_t d, nb, nq;
+    std::vector<float> xb, xq;
+
+    std::cout << "Loading database vectors..." << std::endl;
+    read_fvecs(db_file, xb, d, nb);
+    std::cout << "Loaded " << nb << " vectors of dimension " << d << std::endl;
+
+    std::cout << "Loading query vectors..." << std::endl;
+    size_t d2;
+    read_fvecs(query_file, xq, d2, nq);
+    assert(d == d2);
+    std::cout << "Loaded " << nq << " query vectors." << std::endl;
+
+    int k = 10; // number of nearest neighbors
+    faiss::IndexSVSUncompressed index(d);
+    index.num_threads = 72;
+    std::cout << "Adding database vectors to index..." << std::endl;
+    auto t_build0 = std::chrono::high_resolution_clock::now();
+    index.add(nb, xb.data());
+    auto t_build1 = std::chrono::high_resolution_clock::now();
+    double build_time =
+            std::chrono::duration_cast<std::chrono::duration<double>>(
+                    t_build1 - t_build0)
+                    .count();
+    std::cout << "Index build time (add): " << build_time << " seconds"
+              << std::endl;
+
+    std::cout << "Searching queries and measuring QPS..." << std::endl;
+    std::vector<faiss::idx_t> I(k * nq);
+    std::vector<float> D(k * nq);
+    auto t0 = std::chrono::high_resolution_clock::now();
+    index.search(nq, xq.data(), k, D.data(), I.data());
+    auto t1 = std::chrono::high_resolution_clock::now();
+    double elapsed =
+            std::chrono::duration_cast<std::chrono::duration<double>>(t1 - t0)
+                    .count();
+    double qps = nq / elapsed;
+    std::cout << "Queries per second: " << qps << std::endl;
+
+    // Print results for last 5 queries
+    // std::cout << "Results for last 5 queries:" << std::endl;
+    // for (size_t i = nq - 5; i < nq; i++) {
+    //     std::cout << "Query " << i << ": ";
+    //     for (int j = 0; j < k; j++) {
+    //         std::cout << I[i * k + j] << " ";
+    //     }
+    //     std::cout << std::endl;
+    // }
+
+    return 0;
+}
diff --git a/tutorial/cpp/CMakeLists.txt b/tutorial/cpp/CMakeLists.txt
index ded59b585..7a563c23a 100644
--- a/tutorial/cpp/CMakeLists.txt
+++ b/tutorial/cpp/CMakeLists.txt
@@ -38,3 +38,6 @@ target_link_libraries(11-SVSLVQ4x4 PRIVATE faiss)
 
 add_executable(12-SVSLeanVec4x4 EXCLUDE_FROM_ALL 12-SVSLeanVec4x4.cpp)
 target_link_libraries(12-SVSLeanVec4x4 PRIVATE faiss)
+
+add_executable(13-tmp-svscomp EXCLUDE_FROM_ALL 13-tmp-svscomp.cpp)
+target_link_libraries(13-tmp-svscomp PRIVATE faiss)
-- 
2.39.5 (Apple Git-154)


From 5cf26a9e630120924904baa639020dd2fed849ee Mon Sep 17 00:00:00 2001
From: Andreas Huber <andreas.huber@intel.com>
Date: Fri, 25 Jul 2025 05:22:58 -0700
Subject: [PATCH 08/38] First implementation of IndexSVSFlat

---
 faiss/CMakeLists.txt        |   1 +
 faiss/IndexSVS.cpp          |   3 +-
 faiss/IndexSVS.h            |   9 +--
 faiss/IndexSVSFlat.cpp      | 110 +++++++++++++++---------------------
 faiss/IndexSVSFlat.h        |  55 +++++++++---------
 faiss/IndexSVSLVQ4x4.cpp    |   4 +-
 faiss/python/swigfaiss.swig |   3 +
 tutorial/python/10-SVS.py   |  20 ++++++-
 8 files changed, 101 insertions(+), 104 deletions(-)

diff --git a/faiss/CMakeLists.txt b/faiss/CMakeLists.txt
index 937967b9e..74c5325c3 100644
--- a/faiss/CMakeLists.txt
+++ b/faiss/CMakeLists.txt
@@ -49,6 +49,7 @@ set(FAISS_SRC
   IndexShardsIVF.cpp
   IndexSVS.cpp
   IndexSVSLVQ4x4.cpp
+  IndexSVSFlat.cpp
   #IndexSVSLeanVec4x4.cpp
   IndexNeuralNetCodec.cpp
   MatrixStats.cpp
diff --git a/faiss/IndexSVS.cpp b/faiss/IndexSVS.cpp
index 7920df926..962ab7085 100644
--- a/faiss/IndexSVS.cpp
+++ b/faiss/IndexSVS.cpp
@@ -5,10 +5,11 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/IndexSVS.h>
+#include "faiss/IndexSVS.h"
 #include "faiss/Index.h"
 
 #include "svs/core/data.h"
+#include "svs/orchestrators/dynamic_vamana.h"
 
 #include <filesystem>
 #include <sstream>
diff --git a/faiss/IndexSVS.h b/faiss/IndexSVS.h
index 82bafb7cb..33d65d454 100644
--- a/faiss/IndexSVS.h
+++ b/faiss/IndexSVS.h
@@ -10,11 +10,12 @@
 #include <numeric>
 #include <vector>
 
-#include <faiss/impl/FaissAssert.h>
 #include "faiss/Index.h"
+#include "faiss/impl/FaissAssert.h"
 
-#include "svs/orchestrators/dynamic_vamana.h"
-#include "svs/orchestrators/vamana.h"
+namespace svs {
+class DynamicVamana;
+}
 
 namespace faiss {
 
@@ -37,7 +38,7 @@ struct IndexSVS : Index {
 
     IndexSVS(idx_t d, MetricType metric = METRIC_L2);
 
-    ~IndexSVS() override;
+    virtual ~IndexSVS() override;
 
     void add(idx_t n, const float* x) override;
 
diff --git a/faiss/IndexSVSFlat.cpp b/faiss/IndexSVSFlat.cpp
index 4498dd0e9..4ab4efe42 100644
--- a/faiss/IndexSVSFlat.cpp
+++ b/faiss/IndexSVSFlat.cpp
@@ -8,74 +8,59 @@
 #include <faiss/IndexSVSFlat.h>
 #include "faiss/Index.h"
 
+#include "faiss/impl/FaissAssert.h"
+#include "svs/core/data.h"
+#include "svs/core/query_result.h"
+#include "svs/orchestrators/exhaustive.h"
+
 namespace faiss {
 
-IndexSVSFlat::IndexSVSFlat(
-    idx_t d, 
-    MetricType metric,
-    idx_t num_threads,
-):Index(d, metric), num_threads{num_threads} {
-}
+IndexSVSFlat::IndexSVSFlat(idx_t d, MetricType metric) : Index(d, metric) {}
 
 void IndexSVSFlat::add(idx_t n, const float* x) {
-
-    if(!impl) {
+    if (!impl) {
         init_impl(n, x);
         return;
     }
 
-    // construct sequential labels
-    std::vector<size_t> labels(n);
-
-    svs::threads::parallel_for(
-        impl->get_threadpool_handle(),
-        svs::threads::StaticPartition(n),
-        [&](auto is, auto SVS_UNUSED(tid)) {
-            for(auto i : is) {
-                labels[i] = nlabels + i;
-            }
-        }
-    );
-
-    auto data = svs::data::ConstSimpleDataView<float>(x, n, d);
-    impl->add_points(data, labels);
+    FAISS_THROW_MSG(
+            "IndexSVSFlat does not support adding points after initialization");
 }
 
 void IndexSVSFlat::reset() {
-    impl.reset();
+    delete impl;
+    impl = nullptr;
 }
 
-IndexSVSFlat::~IndexSVSFlat() {
-}
+IndexSVSFlat::~IndexSVSFlat() {}
 
 void IndexSVSFlat::search(
-    idx_t n,
-    const float* x,
-    idx_t k,
-    float* distances,
-    idx_t* labels,
-    const SearchParameters* params
-) const {
+        idx_t n,
+        const float* x,
+        idx_t k,
+        float* distances,
+        idx_t* labels,
+        const SearchParameters* params) const {
     FAISS_THROW_IF_NOT(k > 0);
 
     auto queries = svs::data::ConstSimpleDataView<float>(x, n, d);
 
-    auto results = svs::QueryResult<size_t>{queries.size(), k};
-    // TODO: Tuable Flat parameters 
+    auto results =
+            svs::QueryResult<size_t>{queries.size(), static_cast<size_t>(k)};
+    // TODO: Tuable Flat parameters
     impl->search(results.view(), queries, {});
 
     svs::threads::parallel_for(
-        impl->get_threadpool_handle(),
-        svs::threads::StaticPartition(n),
-        [&](auto is, auto SVS_UNUSED(tid)) {
-            for(auto i : is) {
-                for(idx_t j = 0; j < k; ++j) {
-                    labels[j + i * k] = results.index(i, j);
-                    distances[j + i * k] = results.distance(i, j);
+            impl->get_threadpool_handle(),
+            svs::threads::StaticPartition(n),
+            [&](auto is, auto SVS_UNUSED(tid)) {
+                for (auto i : is) {
+                    for (idx_t j = 0; j < k; ++j) {
+                        labels[j + i * k] = results.index(i, j);
+                        distances[j + i * k] = results.distance(i, j);
+                    }
                 }
-            }
-        }
-    );
+            });
 }
 
 void IndexSVSFlat::init_impl(idx_t n, const float* x) {
@@ -83,32 +68,25 @@ void IndexSVSFlat::init_impl(idx_t n, const float* x) {
     auto threadpool = svs::threads::as_threadpool(num_threads);
 
     svs::threads::parallel_for(
-        threadpool,
-        svs::threads::StaticPartition(n),
-        [&](auto is, auto SVS_UNUSED(tid)) {
-            for(auto i : is) {
-                data.set_datum(i, std::span<const float>(x + i * d, d));
-            }
-        }
-    );
+            threadpool,
+            svs::threads::StaticPartition(n),
+            [&](auto is, auto SVS_UNUSED(tid)) {
+                for (auto i : is) {
+                    data.set_datum(i, std::span<const float>(x + i * d, d));
+                }
+            });
 
     switch (metric_type) {
         case METRIC_INNER_PRODUCT:
-          impl = std::make_unique<svs::index::flat::FlatIndex>(
-                std::move(data), 
-                svs::DistanceIP(),
-                std::move(threadpool)
-              );
-          break;
+            impl = new svs::Flat(svs::Flat::assemble<float>(
+                    std::move(data), svs::DistanceIP(), std::move(threadpool)));
+            break;
         case METRIC_L2:
-          impl = std::make_unique<svs::index::flat::FlatIndex>(
-                std::move(data),
-                svs::DistanceL2(),
-                std::move(threadpool)
-              );
-          break;
+            impl = new svs::Flat(svs::Flat::assemble<float>(
+                    std::move(data), svs::DistanceL2(), std::move(threadpool)));
+            break;
         default:
-          FAISS_ASSERT(!"not supported SVS distance");
+            FAISS_ASSERT(!"not supported SVS distance");
     }
 }
 
diff --git a/faiss/IndexSVSFlat.h b/faiss/IndexSVSFlat.h
index 906405230..78da51892 100644
--- a/faiss/IndexSVSFlat.h
+++ b/faiss/IndexSVSFlat.h
@@ -7,48 +7,47 @@
 
 #pragma once
 
-#include <vector>
+#include <memory>
 #include <numeric>
+#include <variant>
+#include <vector>
 
 #include "faiss/Index.h"
-#include <faiss/impl/FaissAssert.h>
-
-#include "svs/index/flat/flat.h"
 
-namespace faiss {
-
-struct IndexSVSFlatFlat : IndexSVS {
+#include "svs/core/distance.h"
 
-  IndexSVSFlat(
-      idx_t d, 
-      MetricType metric = METRIC_L2,
-      idx_t num_threads = 32,
-      idx_t graph_max_degree = 64
-  );
+namespace svs {
+class Flat;
+}
 
-  ~IndexSVSFlat() override;
+namespace faiss {
 
-  void add(idx_t n, const float* x) override;
+struct IndexSVSFlat : Index {
+    // sequential labels
+    size_t nlabels{0};
+    size_t num_threads = 1;
 
-  void search(
-      idx_t n,
-      const float* x,
-      idx_t k,
-      float* distances,
-      idx_t* labels,
-      const SearchParameters* params = nullptr) const override;
+    IndexSVSFlat() = default;
+    IndexSVSFlat(idx_t d, MetricType metric = METRIC_L2);
 
-  void reset();
+    ~IndexSVSFlat();
 
-  virtual void init_impl(idx_t n, const float* x);
+    void add(idx_t n, const float* x) override;
 
-  // sequential labels
-  size_t nlabels{0};
+    void search(
+            idx_t n,
+            const float* x,
+            idx_t k,
+            float* distances,
+            idx_t* labels,
+            const SearchParameters* params = nullptr) const override;
 
-  std::unique_ptr<svs::DynamicVamana> impl;
+    void reset() override;
 
+   protected:
+    void init_impl(idx_t n, const float* x);
 
-  size_t num_threads;
+    svs::Flat* impl{nullptr};
 };
 
 } // namespace faiss
diff --git a/faiss/IndexSVSLVQ4x4.cpp b/faiss/IndexSVSLVQ4x4.cpp
index 88a2c3586..d72424abf 100644
--- a/faiss/IndexSVSLVQ4x4.cpp
+++ b/faiss/IndexSVSLVQ4x4.cpp
@@ -5,8 +5,8 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/IndexSVSLVQ4x4.h>
-
+#include "faiss/IndexSVSLVQ4x4.h"
+#include "svs/orchestrators/dynamic_vamana.h"
 namespace faiss {
 
 IndexSVSLVQ4x4::IndexSVSLVQ4x4(idx_t d, MetricType metric)
diff --git a/faiss/python/swigfaiss.swig b/faiss/python/swigfaiss.swig
index 348112bac..0ef7fac18 100644
--- a/faiss/python/swigfaiss.swig
+++ b/faiss/python/swigfaiss.swig
@@ -195,6 +195,7 @@ typedef uint64_t size_t;
 #include <faiss/IndexIVFRaBitQ.h>
 
 #include <faiss/IndexSVS.h>
+#include <faiss/IndexSVSFlat.h>
 #include <faiss/IndexSVSLVQ4x4.h>
 
 %}
@@ -684,6 +685,7 @@ struct faiss::simd16uint16 {};
 %include <faiss/utils/approx_topk/mode.h>
 
 %include  <faiss/IndexSVS.h>
+%include  <faiss/IndexSVSFlat.h>
 %include  <faiss/IndexSVSLVQ4x4.h>
 
 #ifdef GPU_WRAPPER
@@ -832,6 +834,7 @@ struct faiss::simd16uint16 {};
     DOWNCAST ( IndexRandom )
     DOWNCAST ( IndexRowwiseMinMax )
     DOWNCAST ( IndexRowwiseMinMaxFP16 )
+    DOWNCAST ( IndexSVSFlat )
     DOWNCAST ( IndexSVSLVQ4x4 )
     DOWNCAST ( IndexSVS )
 #ifdef GPU_WRAPPER
diff --git a/tutorial/python/10-SVS.py b/tutorial/python/10-SVS.py
index 181345c31..630cb4b70 100644
--- a/tutorial/python/10-SVS.py
+++ b/tutorial/python/10-SVS.py
@@ -6,16 +6,18 @@
 import numpy as np
 
 d = 64                           # dimension
-nb = 100000                      # database size
-nq = 10000                       # nb of queries
+nb = 1000                        # database size
+nq = 5                           # nb of queries
 np.random.seed(1234)             # make reproducible
 xb = np.random.random((nb, d)).astype('float32')
 xb[:, 0] += np.arange(nb) / 1000.
 xq = np.random.random((nq, d)).astype('float32')
 xq[:, 0] += np.arange(nq) / 1000.
 
+"""
 import faiss                        # make faiss available
-index = faiss.IndexSVS(d, num_threads)           # build the index
+index = faiss.IndexSVS(d)           # build the index
+index.num_threads = 72
 
 # index = faiss.IndexSVSLVQ4x4(d)   # build the SVSLVQ4x4 index
 # index = faiss.IndexSVSLVQ4x8(d)   # build the SVSLVQ4x4 index
@@ -35,4 +37,16 @@ print(D)
 D, I = index.search(xq, k)     # actual search
 print(I[:5])                   # neighbors of the 5 first queries
 print(I[-5:])                  # neighbors of the 5 last queries
+"""
 
+import faiss
+import svs
+
+idx = faiss.IndexSVSFlat(d, faiss.METRIC_L2)
+idx.add(xb)
+D, I = idx.search(xq, 4)
+print(I)
+
+idx = svs.Flat(xb, svs.DistanceType.L2)
+I, D = idx.search(xq, 4)
+print(I)
\ No newline at end of file
-- 
2.39.5 (Apple Git-154)


From 11b44f7cf4a81f312ef646fb9e0d6df5991ed01d Mon Sep 17 00:00:00 2001
From: Andreas Huber <andreas.huber@intel.com>
Date: Tue, 29 Jul 2025 01:48:25 -0700
Subject: [PATCH 09/38] implement first feedback

---
 faiss/IndexSVS.cpp         |  5 ++++-
 faiss/IndexSVS.h           |  7 ++++---
 faiss/IndexSVSFlat.h       |  7 ++++---
 faiss/impl/index_read.cpp  | 25 ++++++++++++++++---------
 faiss/impl/index_write.cpp | 15 +++++++++++++--
 tutorial/python/10-SVS.py  | 38 +++++++++++++++++---------------------
 6 files changed, 58 insertions(+), 39 deletions(-)

diff --git a/faiss/IndexSVS.cpp b/faiss/IndexSVS.cpp
index 962ab7085..c3dfd6be0 100644
--- a/faiss/IndexSVS.cpp
+++ b/faiss/IndexSVS.cpp
@@ -7,6 +7,7 @@
 
 #include "faiss/IndexSVS.h"
 #include "faiss/Index.h"
+#include "faiss/MetricType.h"
 
 #include "svs/core/data.h"
 #include "svs/orchestrators/dynamic_vamana.h"
@@ -109,7 +110,9 @@ void write_stream_to_files(std::istream& in, const SVSTempDirectory& tmp) {
 
 IndexSVS::IndexSVS() : Index{} {}
 
-IndexSVS::IndexSVS(idx_t d, MetricType metric) : Index(d, metric) {}
+IndexSVS::IndexSVS(idx_t d, MetricType metric) : Index(d, metric) {
+    alpha = metric == METRIC_L2 ? 1.2f : 0.95f;
+}
 
 IndexSVS::~IndexSVS() {
     if (impl) {
diff --git a/faiss/IndexSVS.h b/faiss/IndexSVS.h
index 33d65d454..0bfd82ffb 100644
--- a/faiss/IndexSVS.h
+++ b/faiss/IndexSVS.h
@@ -52,14 +52,15 @@ struct IndexSVS : Index {
 
     void reset() override;
 
+    /* Serialization and deserialization helpers */
     void serialize_impl(std::ostream& out) const;
     void deserialize_impl(std::istream& in);
 
-   protected:
+    /* The actual SVS implementation */
     svs::DynamicVamana* impl{nullptr};
 
-   private:
-    virtual void init_impl(idx_t n, const float* x);
+    /* Initializes the implementation, using the provided data */
+    void init_impl(idx_t n, const float* x);
 };
 
 } // namespace faiss
diff --git a/faiss/IndexSVSFlat.h b/faiss/IndexSVSFlat.h
index 78da51892..00ec4f864 100644
--- a/faiss/IndexSVSFlat.h
+++ b/faiss/IndexSVSFlat.h
@@ -44,10 +44,11 @@ struct IndexSVSFlat : Index {
 
     void reset() override;
 
-   protected:
-    void init_impl(idx_t n, const float* x);
-
+    /* The actual SVS implementation */
     svs::Flat* impl{nullptr};
+
+    /* Initializes the implementation, using the provided data */
+    virtual void init_impl(idx_t n, const float* x);
 };
 
 } // namespace faiss
diff --git a/faiss/impl/index_read.cpp b/faiss/impl/index_read.cpp
index beb6500dc..c504fc658 100644
--- a/faiss/impl/index_read.cpp
+++ b/faiss/impl/index_read.cpp
@@ -1228,7 +1228,8 @@ Index* read_index(IOReader* f, int io_flags) {
         READ1(ivrq->qb);
         read_InvertedLists(ivrq, f, io_flags);
         idx = ivrq;
-    } else if (h == fourcc("SvUC")) {
+    } else if (h == fourcc("ISVD") || h == fourcc("IS44")) {
+        // SVS dynamic vamana
         auto svs = new IndexSVS();
 
         // Read class properties
@@ -1251,16 +1252,22 @@ Index* read_index(IOReader* f, int io_flags) {
         READANDCHECK(blob.data(), blob_size);
         std::stringstream ss(std::move(blob));
         svs->deserialize_impl(ss);
-
         idx = svs;
-    } else {
-        FAISS_THROW_FMT(
-                "Index type 0x%08x (\"%s\") not recognized",
-                h,
-                fourcc_inv_printable(h).c_str());
-        idx = nullptr;
+    } else if (h == fourcc("ISVS")) {
+        // SVS static vamana
+    } else if (h == fourcc("ISVF")) {
+        // SVS Flat
+        auto svs = new IndexSVSFlat();
     }
-    return idx;
+}
+else {
+    FAISS_THROW_FMT(
+            "Index type 0x%08x (\"%s\") not recognized",
+            h,
+            fourcc_inv_printable(h).c_str());
+    idx = nullptr;
+}
+return idx;
 }
 
 Index* read_index(FILE* f, int io_flags) {
diff --git a/faiss/impl/index_write.cpp b/faiss/impl/index_write.cpp
index ba25a04d0..4b48fd6d5 100644
--- a/faiss/impl/index_write.cpp
+++ b/faiss/impl/index_write.cpp
@@ -44,6 +44,8 @@
 #include <faiss/IndexRefine.h>
 #include <faiss/IndexRowwiseMinMax.h>
 #include <faiss/IndexSVS.h>
+#include <faiss/IndexSVSFlat.h>
+#include <faiss/IndexSVSLVQ4x4.h>
 #include <faiss/IndexScalarQuantizer.h>
 #include <faiss/MetaIndexes.h>
 #include <faiss/VectorTransform.h>
@@ -881,8 +883,15 @@ void write_index(const Index* idx, IOWriter* f, int io_flags) {
         WRITE1(ivrq->qb);
         write_InvertedLists(ivrq->invlists, f);
     } else if (const IndexSVS* svs = dynamic_cast<const IndexSVS*>(idx)) {
-        uint32_t h = fourcc("SvUC"); // TODO: clarify fourcc code for SVS
-        // Write header tag
+        uint32_t h;
+
+        if (dynamic_cast<const IndexSVSLVQ4x4*>(idx)) {
+            // LVQ4x4
+            h = fourcc("IS44");
+        } else {
+            // dynamic vamana
+            h = fourcc("ISVD");
+        }
         WRITE1(h);
 
         WRITE1(svs->d);
@@ -905,6 +914,8 @@ void write_index(const Index* idx, IOWriter* f, int io_flags) {
         uint64_t blob_size = blob.size();
         WRITE1(blob_size);
         WRITEANDCHECK(blob.data(), blob_size);
+    } else if (
+            const IndexSVSFlat* svs = dynamic_cast<const IndexSVSFlat*>(idx)) {
     } else {
         FAISS_THROW_MSG("don't know how to serialize this type of index");
     }
diff --git a/tutorial/python/10-SVS.py b/tutorial/python/10-SVS.py
index 630cb4b70..7bd5b1377 100644
--- a/tutorial/python/10-SVS.py
+++ b/tutorial/python/10-SVS.py
@@ -6,47 +6,43 @@
 import numpy as np
 
 d = 64                           # dimension
-nb = 1000                        # database size
-nq = 5                           # nb of queries
+nb = 100000                      # database size
+nq = 10000                       # nb of queries
 np.random.seed(1234)             # make reproducible
 xb = np.random.random((nb, d)).astype('float32')
 xb[:, 0] += np.arange(nb) / 1000.
 xq = np.random.random((nq, d)).astype('float32')
 xq[:, 0] += np.arange(nq) / 1000.
 
-"""
 import faiss                        # make faiss available
-index = faiss.IndexSVS(d)           # build the index
+index = faiss.IndexSVS(d)           # build the index (DynamicVamana, float32)
 index.num_threads = 72
 
-# index = faiss.IndexSVSLVQ4x4(d)   # build the SVSLVQ4x4 index
-# index = faiss.IndexSVSLVQ4x8(d)   # build the SVSLVQ4x4 index
-# index = faiss.IndexSVSLVQ8x0(d)   # build the SVSLVQ4x4 index
-
-# index = faiss.IndexSVSLeanVec4x4(d)   # build the SVSLVQ4x4 index
-# index = faiss.IndexSVSLeanVec4x8(d)   # build the SVSLVQ4x4 index
+# index = faiss.IndexSVSFlat(d)     # build the SVSFlat index
+# index = faiss.IndexSVSLVQ(d)      # build the SVSLVQ index, quantization parameters
+# index = faiss.IndexSVSLeanVec(d)   # build the SVSLeanVec index, quantization parameters
 
 print(index.is_trained)
 index.add(xb)                  # add vectors to the index
 print(index.ntotal)
 
 k = 4                          # we want to see 4 nearest neighbors
+
+print(f"{k} nearest neighbors of the first 5 vectors")
 D, I = index.search(xb[:5], k) # sanity check
 print(I)
 print(D)
 D, I = index.search(xq, k)     # actual search
+print(f"{k} nearest neighbors of the 5 first query vectors")
 print(I[:5])                   # neighbors of the 5 first queries
+print(f"{k} nearest neighbors of the 5 last query vectors")
 print(I[-5:])                  # neighbors of the 5 last queries
-"""
-
-import faiss
-import svs
 
-idx = faiss.IndexSVSFlat(d, faiss.METRIC_L2)
-idx.add(xb)
-D, I = idx.search(xq, 4)
-print(I)
+faiss.write_index(index, "index.faiss")
+reloaded = faiss.read_index("index.faiss")
 
-idx = svs.Flat(xb, svs.DistanceType.L2)
-I, D = idx.search(xq, 4)
-print(I)
\ No newline at end of file
+D, I = reloaded.search(xq, k)  # search with the reloaded
+print(f"{k} nearest neighbors of the 5 first query vectors (after reloading)")
+print(I[:5])                   # neighbors of the 5 first queries
+print(f"{k} nearest neighbors of the 5 last query vectors (after reloading)")
+print(I[-5:])                  # neighbors of the 5 last queries
-- 
2.39.5 (Apple Git-154)


From 0df0771164f1fe815a1ddc8c0b01cdb94fb40bfd Mon Sep 17 00:00:00 2001
From: Andreas Huber <andreas.huber@intel.com>
Date: Wed, 30 Jul 2025 00:55:03 -0700
Subject: [PATCH 10/38] Fix tests for LVQ4x4

---
 faiss/IndexSVS.cpp         | 58 ++++++++++++++++----------------------
 faiss/IndexSVS.h           | 23 +++++++++++++--
 faiss/IndexSVSLVQ4x4.cpp   | 30 ++++++++++++++++++++
 faiss/IndexSVSLVQ4x4.h     |  2 ++
 faiss/IndexSVSLeanVec4x4.h | 38 ++++++++++++++-----------
 faiss/impl/index_read.cpp  | 21 +++++++-------
 tests/test_svs.cpp         | 26 ++++++++++-------
 7 files changed, 125 insertions(+), 73 deletions(-)

diff --git a/faiss/IndexSVS.cpp b/faiss/IndexSVS.cpp
index c3dfd6be0..b026fa2a9 100644
--- a/faiss/IndexSVS.cpp
+++ b/faiss/IndexSVS.cpp
@@ -12,39 +12,29 @@
 #include "svs/core/data.h"
 #include "svs/orchestrators/dynamic_vamana.h"
 
-#include <filesystem>
-#include <sstream>
-
 namespace faiss {
 
 namespace detail {
-struct SVSTempDirectory {
-    std::filesystem::path root;
-    std::filesystem::path config;
-    std::filesystem::path graph;
-    std::filesystem::path data;
-
-    SVSTempDirectory() {
-        root = std::filesystem::temp_directory_path() /
-                ("faiss_svs_" + std::to_string(std::rand()));
-        config = root / "config";
-        graph = root / "graph";
-        data = root / "data";
-
-        std::filesystem::create_directories(config);
-        std::filesystem::create_directories(graph);
-        std::filesystem::create_directories(data);
-    }
+SVSTempDirectory::SVSTempDirectory() {
+    root = std::filesystem::temp_directory_path() /
+            ("faiss_svs_" + std::to_string(std::rand()));
+    config = root / "config";
+    graph = root / "graph";
+    data = root / "data";
+
+    std::filesystem::create_directories(config);
+    std::filesystem::create_directories(graph);
+    std::filesystem::create_directories(data);
+}
 
-    ~SVSTempDirectory() {
-        std::error_code ec;
-        std::filesystem::remove_all(root, ec); // best-effort cleanup
-    }
-};
+SVSTempDirectory::~SVSTempDirectory() {
+    std::error_code ec;
+    std::filesystem::remove_all(root, ec); // best-effort cleanup
+}
 
-void write_files_to_stream(const SVSTempDirectory& tmp, std::ostream& out) {
-    for (const auto& dir : {tmp.config, tmp.graph, tmp.data}) {
-        const std::string dir_name = dir.filename().string(); // "config", etc.
+void SVSTempDirectory::write_files_to_stream(std::ostream& out) const {
+    for (const auto& dir : {config, graph, data}) {
+        const std::string dir_name = dir.filename().string();
         for (const auto& entry : std::filesystem::directory_iterator(dir)) {
             const std::string filename = entry.path().filename().string();
 
@@ -72,7 +62,7 @@ void write_files_to_stream(const SVSTempDirectory& tmp, std::ostream& out) {
     }
 }
 
-void write_stream_to_files(std::istream& in, const SVSTempDirectory& tmp) {
+void SVSTempDirectory::write_stream_to_files(std::istream& in) const {
     while (in && in.peek() != EOF) {
         uint64_t dir_len, file_len, file_size;
 
@@ -90,11 +80,11 @@ void write_stream_to_files(std::istream& in, const SVSTempDirectory& tmp) {
 
         std::filesystem::path base;
         if (dir_name == "config") {
-            base = tmp.config;
+            base = config;
         } else if (dir_name == "graph") {
-            base = tmp.graph;
+            base = graph;
         } else if (dir_name == "data") {
-            base = tmp.data;
+            base = data;
         } else {
             FAISS_THROW_IF_NOT_MSG(false, "Unknown SVS subdirectory name");
         }
@@ -227,7 +217,7 @@ void IndexSVS::serialize_impl(std::ostream& out) const {
     // Write index to temporary files and concatenate the contents
     detail::SVSTempDirectory tmp;
     impl->save(tmp.config, tmp.graph, tmp.data);
-    detail::write_files_to_stream(tmp, out);
+    tmp.write_files_to_stream(out);
 }
 
 void IndexSVS::deserialize_impl(std::istream& in) {
@@ -236,7 +226,7 @@ void IndexSVS::deserialize_impl(std::istream& in) {
 
     // Write stream to files that can be read by DynamicVamana::assemble()
     detail::SVSTempDirectory tmp;
-    detail::write_stream_to_files(in, tmp);
+    tmp.write_stream_to_files(in);
 
     switch (metric_type) {
         case METRIC_INNER_PRODUCT:
diff --git a/faiss/IndexSVS.h b/faiss/IndexSVS.h
index 0bfd82ffb..7c38bf6d8 100644
--- a/faiss/IndexSVS.h
+++ b/faiss/IndexSVS.h
@@ -8,8 +8,12 @@
 #pragma once
 
 #include <numeric>
+#include <utility>
 #include <vector>
 
+#include <filesystem>
+#include <sstream>
+
 #include "faiss/Index.h"
 #include "faiss/impl/FaissAssert.h"
 
@@ -19,6 +23,21 @@ class DynamicVamana;
 
 namespace faiss {
 
+namespace detail {
+struct SVSTempDirectory {
+    std::filesystem::path root;
+    std::filesystem::path config;
+    std::filesystem::path graph;
+    std::filesystem::path data;
+
+    SVSTempDirectory();
+    ~SVSTempDirectory();
+
+    void write_files_to_stream(std::ostream& out) const;
+    void write_stream_to_files(std::istream& in) const;
+};
+} // namespace detail
+
 struct IndexSVS : Index {
     // sequential labels
     size_t nlabels{0};
@@ -54,13 +73,13 @@ struct IndexSVS : Index {
 
     /* Serialization and deserialization helpers */
     void serialize_impl(std::ostream& out) const;
-    void deserialize_impl(std::istream& in);
+    virtual void deserialize_impl(std::istream& in);
 
     /* The actual SVS implementation */
     svs::DynamicVamana* impl{nullptr};
 
     /* Initializes the implementation, using the provided data */
-    void init_impl(idx_t n, const float* x);
+    virtual void init_impl(idx_t n, const float* x);
 };
 
 } // namespace faiss
diff --git a/faiss/IndexSVSLVQ4x4.cpp b/faiss/IndexSVSLVQ4x4.cpp
index d72424abf..97a4654f7 100644
--- a/faiss/IndexSVSLVQ4x4.cpp
+++ b/faiss/IndexSVSLVQ4x4.cpp
@@ -62,4 +62,34 @@ void IndexSVSLVQ4x4::init_impl(idx_t n, const float* x) {
     }
 }
 
+void IndexSVSLVQ4x4::deserialize_impl(std::istream& in) {
+    FAISS_THROW_IF_MSG(
+            impl, "Cannot deserialize: SVS index already initialized.");
+
+    // Write stream to files that can be read by DynamicVamana::assemble()
+    detail::SVSTempDirectory tmp;
+    tmp.write_stream_to_files(in);
+
+    switch (metric_type) {
+        case METRIC_INNER_PRODUCT:
+            impl = new svs::DynamicVamana(svs::DynamicVamana::assemble<float>(
+                    tmp.config.string(),
+                    svs::GraphLoader(tmp.graph.string()),
+                    svs::lib::load_from_disk<storage_type>(tmp.data.string()),
+                    svs::distance::DistanceIP(),
+                    num_threads));
+            break;
+        case METRIC_L2:
+            impl = new svs::DynamicVamana(svs::DynamicVamana::assemble<float>(
+                    tmp.config.string(),
+                    svs::GraphLoader(tmp.graph.string()),
+                    svs::lib::load_from_disk<storage_type>(tmp.data.string()),
+                    svs::distance::DistanceL2(),
+                    num_threads));
+            break;
+        default:
+            FAISS_ASSERT(!"not supported SVS distance");
+    }
+}
+
 } // namespace faiss
diff --git a/faiss/IndexSVSLVQ4x4.h b/faiss/IndexSVSLVQ4x4.h
index 128df8505..8fa0f51dc 100644
--- a/faiss/IndexSVSLVQ4x4.h
+++ b/faiss/IndexSVSLVQ4x4.h
@@ -36,6 +36,8 @@ struct IndexSVSLVQ4x4 : IndexSVS {
     ~IndexSVSLVQ4x4() override;
 
     void init_impl(idx_t n, const float* x) override;
+
+    void deserialize_impl(std::istream& in) override;
 };
 
 } // namespace faiss
diff --git a/faiss/IndexSVSLeanVec4x4.h b/faiss/IndexSVSLeanVec4x4.h
index 0e11c2e04..a2422066b 100644
--- a/faiss/IndexSVSLeanVec4x4.h
+++ b/faiss/IndexSVSLeanVec4x4.h
@@ -14,32 +14,36 @@
 namespace faiss {
 
 struct IndexSVSLeanVec4x4 : IndexSVS {
+    using blocked_alloc_type =
+            svs::data::Blocked<svs::lib::Allocator<std::byte>>;
 
-  using blocked_alloc_type = svs::data::Blocked<svs::lib::Allocator<std::byte>>;
+    using storage_type = svs::leanvec::LeanDataset<
+            svs::leanvec::UsingLVQ<4>,
+            svs::leanvec::UsingLVQ<4>,
+            svs::Dynamic,
+            svs::Dynamic,
+            blocked_alloc_type>;
 
-  using storage_type = svs::leanvec::LeanDataset<svs::leanvec::UsingLVQ<4>, svs::leanvec::UsingLVQ<4>, svs::Dynamic, svs::Dynamic, blocked_alloc_type>;
+    using leanvec_matrix_type = svs::data::SimpleData<float>;
 
-  using leanvec_matrix_type = svs::data::SimpleData<float>;
+    IndexSVSLeanVec4x4(
+            idx_t d,
+            MetricType metric = METRIC_L2,
+            size_t num_threads = 32,
+            size_t graph_max_degree = 64,
+            size_t leanvec_dims = 0);
 
-  IndexSVSLeanVec4x4(
-      idx_t d, 
-      MetricType metric = METRIC_L2,
-      size_t num_threads = 32,
-      size_t graph_max_degree = 64,
-      size_t leanvec_dims = 0
-  );
+    ~IndexSVSLeanVec4x4() override;
 
-  ~IndexSVSLeanVec4x4() override;
+    void reset() override;
 
-  void reset() override;
+    void train(idx_t n, const float* x) override;
 
-  void train(idx_t n, const float* x) override;
+    void init_impl(idx_t n, const float* x) override;
 
-  void init_impl(idx_t n, const float* x) override;
+    size_t leanvec_d;
 
-  size_t leanvec_d;
-
-  leanvec_matrix_type* leanvec_matrix;
+    leanvec_matrix_type* leanvec_matrix;
 };
 
 } // namespace faiss
diff --git a/faiss/impl/index_read.cpp b/faiss/impl/index_read.cpp
index 5a1f1325f..b01916a98 100644
--- a/faiss/impl/index_read.cpp
+++ b/faiss/impl/index_read.cpp
@@ -46,6 +46,8 @@
 #include <faiss/IndexRefine.h>
 #include <faiss/IndexRowwiseMinMax.h>
 #include <faiss/IndexSVS.h>
+#include <faiss/IndexSVSFlat.h>
+#include <faiss/IndexSVSLVQ4x4.h>
 #include <faiss/IndexScalarQuantizer.h>
 #include <faiss/MetaIndexes.h>
 #include <faiss/VectorTransform.h>
@@ -1245,7 +1247,8 @@ Index* read_index(IOReader* f, int io_flags) {
         idx = ivrq;
     } else if (h == fourcc("ISVD") || h == fourcc("IS44")) {
         // SVS dynamic vamana
-        auto svs = new IndexSVS();
+        IndexSVS* svs;
+        svs = h == fourcc("ISVD") ? new IndexSVS() : new IndexSVSLVQ4x4();
 
         // Read class properties
         READ1(svs->d);
@@ -1273,16 +1276,14 @@ Index* read_index(IOReader* f, int io_flags) {
     } else if (h == fourcc("ISVF")) {
         // SVS Flat
         auto svs = new IndexSVSFlat();
+    } else {
+        FAISS_THROW_FMT(
+                "Index type 0x%08x (\"%s\") not recognized",
+                h,
+                fourcc_inv_printable(h).c_str());
+        idx = nullptr;
     }
-}
-else {
-    FAISS_THROW_FMT(
-            "Index type 0x%08x (\"%s\") not recognized",
-            h,
-            fourcc_inv_printable(h).c_str());
-    idx = nullptr;
-}
-return idx;
+    return idx;
 }
 
 Index* read_index(FILE* f, int io_flags) {
diff --git a/tests/test_svs.cpp b/tests/test_svs.cpp
index cc900c326..6afc839a1 100644
--- a/tests/test_svs.cpp
+++ b/tests/test_svs.cpp
@@ -6,7 +6,8 @@
  */
 
 #include <faiss/Index.h>
-#include <faiss/IndexSVSUncompressed.h>
+#include <faiss/IndexSVS.h>
+#include <faiss/IndexSVSLVQ4x4.h>
 #include <faiss/index_io.h>
 #include <gtest/gtest.h>
 
@@ -16,9 +17,10 @@ namespace {
 pthread_mutex_t temp_file_mutex = PTHREAD_MUTEX_INITIALIZER;
 }
 
-TEST(SVSIO, WriteAndReadIndex) {
-    const faiss::idx_t d = 64;
-    faiss::IndexSVSUncompressed index(d);
+template <typename T>
+void write_and_read_index() {
+    constexpr faiss::idx_t d = 64;
+    T index(d);
     std::vector<float> xb(d * 100);
     std::mt19937 gen(123);
     std::uniform_real_distribution<float> dis(0.0f, 1.0f);
@@ -34,10 +36,9 @@ TEST(SVSIO, WriteAndReadIndex) {
     ASSERT_NO_THROW({ faiss::write_index(&index, filename.c_str()); });
 
     // Deserialize
-    faiss::IndexSVSUncompressed* loaded = nullptr;
+    T* loaded = nullptr;
     ASSERT_NO_THROW({
-        loaded = dynamic_cast<faiss::IndexSVSUncompressed*>(
-                faiss::read_index(filename.c_str()));
+        loaded = dynamic_cast<T*>(faiss::read_index(filename.c_str()));
     });
 
     // Basic checks
@@ -54,8 +55,13 @@ TEST(SVSIO, WriteAndReadIndex) {
     EXPECT_EQ(loaded->prune_to, index.prune_to);
     EXPECT_EQ(loaded->use_full_search_history, index.use_full_search_history);
 
-    // Question: Save/load of SVS indices is tested within SVS. Do we still want
-    // to validate `loaded->impl`?
-
     delete loaded;
 }
+
+TEST(SVSIO, WriteAndReadIndexIndexSVS) {
+    write_and_read_index<faiss::IndexSVS>();
+}
+
+TEST(SVSIO, WriteAndReadIndexIndexSVSLVQ4x4) {
+    write_and_read_index<faiss::IndexSVSLVQ4x4>();
+}
-- 
2.39.5 (Apple Git-154)


From 014960dd29c7cfcd76277d25174f9894b731410d Mon Sep 17 00:00:00 2001
From: Andreas Huber <andreas.huber@intel.com>
Date: Wed, 30 Jul 2025 01:49:07 -0700
Subject: [PATCH 11/38] add LVQ4x8

---
 faiss/CMakeLists.txt       |  1 +
 faiss/IndexSVSLVQ4x8.cpp   |  2 --
 faiss/IndexSVSLVQ4x8.h     |  2 --
 faiss/impl/index_read.cpp  | 13 ++++++++++---
 faiss/impl/index_write.cpp | 11 ++++++-----
 tests/test_svs.cpp         |  5 +++++
 6 files changed, 22 insertions(+), 12 deletions(-)

diff --git a/faiss/CMakeLists.txt b/faiss/CMakeLists.txt
index 74c5325c3..3463e45de 100644
--- a/faiss/CMakeLists.txt
+++ b/faiss/CMakeLists.txt
@@ -49,6 +49,7 @@ set(FAISS_SRC
   IndexShardsIVF.cpp
   IndexSVS.cpp
   IndexSVSLVQ4x4.cpp
+  IndexSVSLVQ4x8.cpp
   IndexSVSFlat.cpp
   #IndexSVSLeanVec4x4.cpp
   IndexNeuralNetCodec.cpp
diff --git a/faiss/IndexSVSLVQ4x8.cpp b/faiss/IndexSVSLVQ4x8.cpp
index e10ea3195..0bb9edeb9 100644
--- a/faiss/IndexSVSLVQ4x8.cpp
+++ b/faiss/IndexSVSLVQ4x8.cpp
@@ -13,6 +13,4 @@ namespace faiss {
 IndexSVSLVQ4x8::IndexSVSLVQ4x8(idx_t d, MetricType metric)
         : IndexSVSLVQ4x4(d, metric) {}
 
-IndexSVSLVQ4x8::~IndexSVSLVQ4x8() {}
-
 } // namespace faiss
diff --git a/faiss/IndexSVSLVQ4x8.h b/faiss/IndexSVSLVQ4x8.h
index 2c81921ca..07c75cf15 100644
--- a/faiss/IndexSVSLVQ4x8.h
+++ b/faiss/IndexSVSLVQ4x8.h
@@ -23,8 +23,6 @@ struct IndexSVSLVQ4x8 : IndexSVSLVQ4x4 {
     IndexSVSLVQ4x8() = default;
 
     IndexSVSLVQ4x8(idx_t d, MetricType metric = METRIC_L2);
-
-    ~IndexSVSLVQ4x8() override;
 };
 
 } // namespace faiss
diff --git a/faiss/impl/index_read.cpp b/faiss/impl/index_read.cpp
index b01916a98..1889d8602 100644
--- a/faiss/impl/index_read.cpp
+++ b/faiss/impl/index_read.cpp
@@ -48,6 +48,7 @@
 #include <faiss/IndexSVS.h>
 #include <faiss/IndexSVSFlat.h>
 #include <faiss/IndexSVSLVQ4x4.h>
+#include <faiss/IndexSVSLVQ4x8.h>
 #include <faiss/IndexScalarQuantizer.h>
 #include <faiss/MetaIndexes.h>
 #include <faiss/VectorTransform.h>
@@ -1245,10 +1246,16 @@ Index* read_index(IOReader* f, int io_flags) {
         READ1(ivrq->qb);
         read_InvertedLists(ivrq, f, io_flags);
         idx = ivrq;
-    } else if (h == fourcc("ISVD") || h == fourcc("IS44")) {
-        // SVS dynamic vamana
+    } else if (
+            h == fourcc("IS48") || h == fourcc("IS44") || h == fourcc("ISVD")) {
         IndexSVS* svs;
-        svs = h == fourcc("ISVD") ? new IndexSVS() : new IndexSVSLVQ4x4();
+        if (h == fourcc("IS48")) {
+            svs = new IndexSVSLVQ4x8(); // LVQ4x8
+        } else if (h == fourcc("IS44")) {
+            svs = new IndexSVSLVQ4x4(); // LVQ4x4
+        } else if (h == fourcc("ISVD")) {
+            svs = new IndexSVS(); // uncompressed
+        }
 
         // Read class properties
         READ1(svs->d);
diff --git a/faiss/impl/index_write.cpp b/faiss/impl/index_write.cpp
index 86f150d00..3105b1f88 100644
--- a/faiss/impl/index_write.cpp
+++ b/faiss/impl/index_write.cpp
@@ -46,6 +46,7 @@
 #include <faiss/IndexSVS.h>
 #include <faiss/IndexSVSFlat.h>
 #include <faiss/IndexSVSLVQ4x4.h>
+#include <faiss/IndexSVSLVQ4x8.h>
 #include <faiss/IndexScalarQuantizer.h>
 #include <faiss/MetaIndexes.h>
 #include <faiss/VectorTransform.h>
@@ -887,12 +888,12 @@ void write_index(const Index* idx, IOWriter* f, int io_flags) {
     } else if (const IndexSVS* svs = dynamic_cast<const IndexSVS*>(idx)) {
         uint32_t h;
 
-        if (dynamic_cast<const IndexSVSLVQ4x4*>(idx)) {
-            // LVQ4x4
-            h = fourcc("IS44");
+        if (dynamic_cast<const IndexSVSLVQ4x8*>(idx)) {
+            h = fourcc("IS48"); // LVQ4x8
+        } else if (dynamic_cast<const IndexSVSLVQ4x4*>(idx)) {
+            h = fourcc("IS44"); // LVQ4x4
         } else {
-            // dynamic vamana
-            h = fourcc("ISVD");
+            h = fourcc("ISVD"); // uncompressed
         }
         WRITE1(h);
 
diff --git a/tests/test_svs.cpp b/tests/test_svs.cpp
index 6afc839a1..dbdc34f51 100644
--- a/tests/test_svs.cpp
+++ b/tests/test_svs.cpp
@@ -8,6 +8,7 @@
 #include <faiss/Index.h>
 #include <faiss/IndexSVS.h>
 #include <faiss/IndexSVSLVQ4x4.h>
+#include <faiss/IndexSVSLVQ4x8.h>
 #include <faiss/index_io.h>
 #include <gtest/gtest.h>
 
@@ -65,3 +66,7 @@ TEST(SVSIO, WriteAndReadIndexIndexSVS) {
 TEST(SVSIO, WriteAndReadIndexIndexSVSLVQ4x4) {
     write_and_read_index<faiss::IndexSVSLVQ4x4>();
 }
+
+TEST(SVSIO, WriteAndReadIndexIndexSVSLVQ4x8) {
+    write_and_read_index<faiss::IndexSVSLVQ4x8>();
+}
-- 
2.39.5 (Apple Git-154)


From 09c0db5b91800cca99712d5b07477be5c6b148c1 Mon Sep 17 00:00:00 2001
From: Andreas Huber <andreas.huber@intel.com>
Date: Wed, 30 Jul 2025 03:15:16 -0700
Subject: [PATCH 12/38] initial set of SVS python tests

---
 faiss/IndexSVS.h            |   4 -
 faiss/IndexSVSLVQ4x4.cpp    |   2 -
 faiss/IndexSVSLVQ4x4.h      |   2 +-
 faiss/IndexSVSLVQ4x8.h      |   2 +
 faiss/python/swigfaiss.swig |   3 +
 tests/test_svs.py           | 259 ++++++++++++++++++++++++++++++++++++
 6 files changed, 265 insertions(+), 7 deletions(-)
 create mode 100644 tests/test_svs.py

diff --git a/faiss/IndexSVS.h b/faiss/IndexSVS.h
index 7c38bf6d8..302560f8a 100644
--- a/faiss/IndexSVS.h
+++ b/faiss/IndexSVS.h
@@ -39,10 +39,6 @@ struct SVSTempDirectory {
 } // namespace detail
 
 struct IndexSVS : Index {
-    // sequential labels
-    size_t nlabels{0};
-
-    // default parameters
     size_t num_threads = 1;
     size_t graph_max_degree = 64;
     float alpha = 1.2;
diff --git a/faiss/IndexSVSLVQ4x4.cpp b/faiss/IndexSVSLVQ4x4.cpp
index 97a4654f7..a611d885f 100644
--- a/faiss/IndexSVSLVQ4x4.cpp
+++ b/faiss/IndexSVSLVQ4x4.cpp
@@ -12,8 +12,6 @@ namespace faiss {
 IndexSVSLVQ4x4::IndexSVSLVQ4x4(idx_t d, MetricType metric)
         : IndexSVS(d, metric) {}
 
-IndexSVSLVQ4x4::~IndexSVSLVQ4x4() {}
-
 void IndexSVSLVQ4x4::init_impl(idx_t n, const float* x) {
     // TODO: support ConstSimpleDataView in SVS shared/static lib
     const auto data =
diff --git a/faiss/IndexSVSLVQ4x4.h b/faiss/IndexSVSLVQ4x4.h
index 8fa0f51dc..f89919273 100644
--- a/faiss/IndexSVSLVQ4x4.h
+++ b/faiss/IndexSVSLVQ4x4.h
@@ -33,7 +33,7 @@ struct IndexSVSLVQ4x4 : IndexSVS {
     IndexSVSLVQ4x4() = default;
     IndexSVSLVQ4x4(idx_t d, MetricType metric = METRIC_L2);
 
-    ~IndexSVSLVQ4x4() override;
+    ~IndexSVSLVQ4x4() override = default;
 
     void init_impl(idx_t n, const float* x) override;
 
diff --git a/faiss/IndexSVSLVQ4x8.h b/faiss/IndexSVSLVQ4x8.h
index 07c75cf15..041c40d09 100644
--- a/faiss/IndexSVSLVQ4x8.h
+++ b/faiss/IndexSVSLVQ4x8.h
@@ -23,6 +23,8 @@ struct IndexSVSLVQ4x8 : IndexSVSLVQ4x4 {
     IndexSVSLVQ4x8() = default;
 
     IndexSVSLVQ4x8(idx_t d, MetricType metric = METRIC_L2);
+
+    ~IndexSVSLVQ4x8() override = default;
 };
 
 } // namespace faiss
diff --git a/faiss/python/swigfaiss.swig b/faiss/python/swigfaiss.swig
index 0ef7fac18..5dd1ceb01 100644
--- a/faiss/python/swigfaiss.swig
+++ b/faiss/python/swigfaiss.swig
@@ -197,6 +197,7 @@ typedef uint64_t size_t;
 #include <faiss/IndexSVS.h>
 #include <faiss/IndexSVSFlat.h>
 #include <faiss/IndexSVSLVQ4x4.h>
+#include <faiss/IndexSVSLVQ4x8.h>
 
 %}
 
@@ -687,6 +688,7 @@ struct faiss::simd16uint16 {};
 %include  <faiss/IndexSVS.h>
 %include  <faiss/IndexSVSFlat.h>
 %include  <faiss/IndexSVSLVQ4x4.h>
+%include  <faiss/IndexSVSLVQ4x8.h>
 
 #ifdef GPU_WRAPPER
 
@@ -835,6 +837,7 @@ struct faiss::simd16uint16 {};
     DOWNCAST ( IndexRowwiseMinMax )
     DOWNCAST ( IndexRowwiseMinMaxFP16 )
     DOWNCAST ( IndexSVSFlat )
+    DOWNCAST ( IndexSVSLVQ4x8 )
     DOWNCAST ( IndexSVSLVQ4x4 )
     DOWNCAST ( IndexSVS )
 #ifdef GPU_WRAPPER
diff --git a/tests/test_svs.py b/tests/test_svs.py
new file mode 100644
index 000000000..0851b3612
--- /dev/null
+++ b/tests/test_svs.py
@@ -0,0 +1,259 @@
+# Copyright (c) Meta Platforms, Inc. and affiliates.
+#
+# This source code is licensed under the MIT license found in the
+# LICENSE file in the root directory of this source tree.
+
+import numpy as np
+import unittest
+import tempfile
+import faiss
+
+
+class TestSVSAdapter(unittest.TestCase):
+    """Test the FAISS-SVS adapter layer integration"""
+
+    target_class = faiss.IndexSVS
+
+    def setUp(self):
+        self.d = 32
+        self.nb = 1000
+        self.nq = 100
+        np.random.seed(1234)
+        self.xb = np.random.random((self.nb, self.d)).astype('float32')
+        self.xq = np.random.random((self.nq, self.d)).astype('float32')
+
+    def test_svs_construction(self):
+        """Test construction and basic properties"""
+        # Test default construction
+        index = self.target_class(self.d)
+        self.assertEqual(index.d, self.d)
+        self.assertTrue(index.is_trained)
+        self.assertEqual(index.ntotal, 0)
+        self.assertEqual(index.metric_type, faiss.METRIC_L2)
+
+        index_ip = self.target_class(self.d, faiss.METRIC_INNER_PRODUCT)
+        self.assertEqual(index_ip.metric_type, faiss.METRIC_INNER_PRODUCT)
+
+    def test_svs_add_search_interface(self):
+        """Test FAISS add/search interface compatibility"""
+        index = self.target_class(self.d)
+
+        # Test add interface
+        index.add(self.xb)
+        self.assertEqual(index.ntotal, self.nb)
+
+        # Test search interface
+        k = 4
+        D, I = index.search(self.xq, k)
+        self.assertEqual(D.shape, (self.nq, k))
+        self.assertEqual(I.shape, (self.nq, k))
+        self.assertTrue(np.all(I >= 0))
+        self.assertTrue(np.all(I < self.nb))
+
+        # Test reset
+        index.reset()
+        self.assertEqual(index.ntotal, 0)
+
+    def test_svs_metric_types(self):
+        """Test different metric types are handled correctly"""
+        # L2 metric
+        index_l2 = self.target_class(self.d, faiss.METRIC_L2)
+        index_l2.add(self.xb)
+        D_l2, _ = index_l2.search(self.xq[:10], 4)
+
+        index_ip = self.target_class(self.d, faiss.METRIC_INNER_PRODUCT)
+        index_ip.add(self.xb)
+        D_ip, _ = index_ip.search(self.xq[:10], 4)
+
+        # Results should be different (testing adapter forwards metric correctly)
+        self.assertFalse(np.array_equal(D_l2, D_ip))
+
+    def test_svs_serialization(self):
+        """Test FAISS serialization system works with SVS indices"""
+        index = self.target_class(self.d)
+
+        index.num_threads = 2
+
+        index.add(self.xb)
+        D_before, I_before = index.search(self.xq, 4)
+
+        with tempfile.NamedTemporaryFile() as f:
+            faiss.write_index(index, f.name)
+            loaded = faiss.read_index(f.name)
+
+        # Verify adapter layer preserves type and parameters
+        self.assertIsInstance(loaded, self.target_class)
+        self.assertEqual(loaded.d, self.d)
+        self.assertEqual(loaded.ntotal, self.nb)
+        self.assertEqual(loaded.metric_type, index.metric_type)
+        self.assertEqual(loaded.num_threads, index.num_threads)
+
+        # Verify functionality is preserved
+        D_after, I_after = loaded.search(self.xq, 4)
+        np.testing.assert_array_equal(I_before, I_after)
+        np.testing.assert_allclose(D_before, D_after, rtol=1e-6)
+
+    def test_svs_error_handling(self):
+        """Test that FAISS error handling works with SVS indices"""
+        index = self.target_class(self.d)
+
+        # Test search before adding data
+        with self.assertRaises(RuntimeError):
+            index.search(self.xq, 4)
+
+        # Test wrong dimension
+        wrong_dim_data = np.random.random((100, self.d + 1)).astype('float32')
+        with self.assertRaises(AssertionError):
+            index.add(wrong_dim_data)
+
+    def test_svs_fourcc_handling(self):
+        """Test that FAISS I/O system handles SVS fourccs correctly"""
+        # Create and populate index
+        index = self.target_class(self.d)
+        index.add(self.xb[:100])  # Smaller dataset for speed
+
+        # Test round-trip serialization preserves exact type
+        with tempfile.NamedTemporaryFile() as f:
+            faiss.write_index(index, f.name)
+            loaded = faiss.read_index(f.name)
+
+            # Verify exact type preservation (fourcc working correctly)
+            self.assertEqual(type(loaded), self.target_class)
+
+    def test_svs_batch_operations(self):
+        """Test that batch operations work correctly through adapter"""
+        index = self.target_class(self.d)
+
+        # Add in multiple batches
+        batch_size = 250
+        for i in range(0, self.nb, batch_size):
+            end_idx = min(i + batch_size, self.nb)
+            index.add(self.xb[i:end_idx])
+
+        self.assertEqual(index.ntotal, self.nb)
+
+        # Verify search still works after batch operations
+        D, _ = index.search(self.xq, 4)
+        self.assertEqual(D.shape, (self.nq, 4))
+
+
+class TestSVSAdapterLVQ4x4(TestSVSAdapter):
+    """Repeat all tests for SVSLVQ4x4 variant"""
+    target_class = faiss.IndexSVSLVQ4x4
+
+class TestSVSAdapterLVQ4x8(TestSVSAdapter):
+    """Repeat all tests for SVSLVQ4x8 variant"""
+    target_class = faiss.IndexSVSLVQ4x8
+
+class TestSVSAdapterFlat(TestSVSAdapter):
+    """Repeat all tests for SVSFlat variant"""
+    target_class = faiss.IndexSVSFlat
+
+
+class TestSVSVamanaParameters(unittest.TestCase):
+    """Test Vamana-specific parameter forwarding and persistence for SVS Vamana variants"""
+
+    target_class = faiss.IndexSVS
+
+    def setUp(self):
+        self.d = 32
+        self.nb = 500  # Smaller dataset for parameter tests
+        self.nq = 50
+        np.random.seed(1234)
+        self.xb = np.random.random((self.nb, self.d)).astype('float32')
+        self.xq = np.random.random((self.nq, self.d)).astype('float32')
+
+    def test_vamana_parameter_setting(self):
+        """Test that all Vamana parameters can be set and retrieved"""
+        index = self.target_class(self.d)
+
+        # Set non-default values for all parameters
+        index.num_threads = 4
+        index.graph_max_degree = 32
+        index.alpha = 1.5
+        index.search_window_size = 20
+        index.search_buffer_capacity = 25
+        index.construction_window_size = 80
+        index.max_candidate_pool_size = 150
+        index.prune_to = 30
+        index.use_full_search_history = False
+
+        # Verify all parameters are set correctly
+        self.assertEqual(index.num_threads, 4)
+        self.assertEqual(index.graph_max_degree, 32)
+        self.assertEqual(index.alpha, 1.5)
+        self.assertEqual(index.search_window_size, 20)
+        self.assertEqual(index.search_buffer_capacity, 25)
+        self.assertEqual(index.construction_window_size, 80)
+        self.assertEqual(index.max_candidate_pool_size, 150)
+        self.assertEqual(index.prune_to, 30)
+        self.assertEqual(index.use_full_search_history, False)
+
+    def test_vamana_parameter_defaults(self):
+        """Test that Vamana parameters have correct default values"""
+        index = self.target_class(self.d)
+
+        # Verify default values match C++ header
+        self.assertEqual(index.num_threads, 1)
+        self.assertEqual(index.graph_max_degree, 64)
+        self.assertEqual(index.alpha, 1.2)
+        self.assertEqual(index.search_window_size, 10)
+        self.assertEqual(index.search_buffer_capacity, 10)
+        self.assertEqual(index.construction_window_size, 40)
+        self.assertEqual(index.max_candidate_pool_size, 200)
+        self.assertEqual(index.prune_to, 60)
+        self.assertEqual(index.use_full_search_history, True)
+
+    def test_vamana_parameter_serialization(self):
+        """Test that all Vamana parameters are preserved through serialization"""
+        index = self.target_class(self.d)
+
+        # Set distinctive non-default values
+        index.num_threads = 8
+        index.graph_max_degree = 48
+        index.alpha = 1.8
+        index.search_window_size = 15
+        index.search_buffer_capacity = 18
+        index.construction_window_size = 60
+        index.max_candidate_pool_size = 180
+        index.prune_to = 45
+        index.use_full_search_history = False
+
+        # Add data and train
+        index.add(self.xb)
+
+        # Serialize and deserialize
+        with tempfile.NamedTemporaryFile() as f:
+            faiss.write_index(index, f.name)
+            loaded = faiss.read_index(f.name)
+
+        # Verify all parameters are preserved
+        self.assertIsInstance(loaded, self.target_class)
+        self.assertEqual(loaded.num_threads, 8)
+        self.assertEqual(loaded.graph_max_degree, 48)
+        self.assertEqual(loaded.alpha, 1.8)
+        self.assertEqual(loaded.search_window_size, 15)
+        self.assertEqual(loaded.search_buffer_capacity, 18)
+        self.assertEqual(loaded.construction_window_size, 60)
+        self.assertEqual(loaded.max_candidate_pool_size, 180)
+        self.assertEqual(loaded.prune_to, 45)
+        self.assertEqual(loaded.use_full_search_history, False)
+
+        # Verify results are unaffected
+        D_before, I_before = index.search(self.xq, 4)
+        D_after, I_after = loaded.search(self.xq, 4)
+        np.testing.assert_array_equal(I_before, I_after)
+        np.testing.assert_allclose(D_before, D_after, rtol=1e-6)
+
+
+class TestSVSVamanaParametersLVQ4x4(TestSVSVamanaParameters):
+    """Repeat Vamana parameter tests for SVSLVQ4x4 variant"""
+    target_class = faiss.IndexSVSLVQ4x4
+
+
+class TestSVSVamanaParametersLVQ4x8(TestSVSVamanaParameters):
+    """Repeat Vamana parameter tests for SVSLVQ4x8 variant"""
+    target_class = faiss.IndexSVSLVQ4x8
+
+if __name__ == '__main__':
+    unittest.main()
-- 
2.39.5 (Apple Git-154)


From 969d595be6f2174715828b4b36a27d9aafca82ff Mon Sep 17 00:00:00 2001
From: Andreas Huber <andreas.huber@intel.com>
Date: Wed, 30 Jul 2025 09:15:02 -0700
Subject: [PATCH 13/38] fix some tests

---
 faiss/IndexSVS.cpp           |  2 +
 faiss/IndexSVSFlat.cpp       | 17 ++++---
 faiss/IndexSVSLeanVec4x4.cpp | 88 ++++++++++++++++++++----------------
 faiss/impl/index_read.cpp    |  6 +--
 faiss/impl/index_write.cpp   |  8 ++--
 tests/test_svs.py            |  6 +--
 6 files changed, 72 insertions(+), 55 deletions(-)

diff --git a/faiss/IndexSVS.cpp b/faiss/IndexSVS.cpp
index b026fa2a9..020fff9ad 100644
--- a/faiss/IndexSVS.cpp
+++ b/faiss/IndexSVS.cpp
@@ -136,6 +136,7 @@ void IndexSVS::add(idx_t n, const float* x) {
 void IndexSVS::reset() {
     if (impl) {
         delete impl;
+        impl = nullptr;
     }
     ntotal = 0;
 }
@@ -147,6 +148,7 @@ void IndexSVS::search(
         float* distances,
         idx_t* labels,
         const SearchParameters* params) const {
+    FAISS_THROW_IF_NOT(impl);
     FAISS_THROW_IF_NOT(k > 0);
     FAISS_THROW_IF_NOT(is_trained);
 
diff --git a/faiss/IndexSVSFlat.cpp b/faiss/IndexSVSFlat.cpp
index 4ab4efe42..5c4feef1a 100644
--- a/faiss/IndexSVSFlat.cpp
+++ b/faiss/IndexSVSFlat.cpp
@@ -5,13 +5,13 @@
  * LICENSE file in the root directory of this source tree.
  */
 
+#include <faiss/Index.h>
 #include <faiss/IndexSVSFlat.h>
-#include "faiss/Index.h"
 
-#include "faiss/impl/FaissAssert.h"
-#include "svs/core/data.h"
-#include "svs/core/query_result.h"
-#include "svs/orchestrators/exhaustive.h"
+#include <faiss/impl/FaissAssert.h>
+#include <svs/core/data.h>
+#include <svs/core/query_result.h>
+#include <svs/orchestrators/exhaustive.h>
 
 namespace faiss {
 
@@ -28,8 +28,10 @@ void IndexSVSFlat::add(idx_t n, const float* x) {
 }
 
 void IndexSVSFlat::reset() {
-    delete impl;
-    impl = nullptr;
+    if (impl) {
+        delete impl;
+        impl = nullptr;
+    }
 }
 
 IndexSVSFlat::~IndexSVSFlat() {}
@@ -41,6 +43,7 @@ void IndexSVSFlat::search(
         float* distances,
         idx_t* labels,
         const SearchParameters* params) const {
+    FAISS_THROW_IF_NOT(impl);
     FAISS_THROW_IF_NOT(k > 0);
 
     auto queries = svs::data::ConstSimpleDataView<float>(x, n, d);
diff --git a/faiss/IndexSVSLeanVec4x4.cpp b/faiss/IndexSVSLeanVec4x4.cpp
index e4753b5cf..a16e81dd6 100644
--- a/faiss/IndexSVSLeanVec4x4.cpp
+++ b/faiss/IndexSVSLeanVec4x4.cpp
@@ -10,23 +10,23 @@
 namespace faiss {
 
 IndexSVSLeanVec4x4::IndexSVSLeanVec4x4(
-    idx_t d, 
-    MetricType metric,
-    size_t num_threads,
-    size_t graph_max_degree,
-    size_t leanvec_dims
-): IndexSVS(d, metric, num_threads, graph_max_degree) {
+        idx_t d,
+        MetricType metric,
+        size_t num_threads,
+        size_t graph_max_degree,
+        size_t leanvec_dims)
+        : IndexSVS(d, metric, num_threads, graph_max_degree) {
     leanvec_d = leanvec_dims == 0 ? d / 2 : leanvec_d;
     is_trained = false;
 }
 
-IndexSVSLeanVec4x4::~IndexSVSLeanVec4x4() {
-}
+IndexSVSLeanVec4x4::~IndexSVSLeanVec4x4() {}
 
 void IndexSVSLeanVec4x4::train(idx_t n, const float* x) {
     auto data = svs::data::ConstSimpleDataView<float>(x, n, d);
     auto means = utils::compute_medioid(data, num_threads);
-    leanvec_matrix = compute_leanvec_matrix<svs::Dynamic, svs::Dynamic>(data, means, num_threads, leanvec_d);
+    leanvec_matrix = compute_leanvec_matrix<svs::Dynamic, svs::Dynamic>(
+            data, means, num_threads, leanvec_d);
     is_trained = true;
 }
 
@@ -36,48 +36,58 @@ void IndexSVSLeanVec4x4::reset() {
 }
 
 void IndexSVSLeanVec4x4::init_impl(idx_t n, const float* x) {
-
     // TODO: support ConstSimpleDataView in SVS shared/static lib
-    const auto data = svs::data::SimpleDataView<float>(const_cast<float*>(x), n, d);
+    const auto data =
+            svs::data::SimpleDataView<float>(const_cast<float*>(x), n, d);
     std::vector<size_t> labels(n);
     auto threadpool = svs::threads::as_threadpool(num_threads);
-    auto compressed_data = storage_type::reduce(data, leanvec_matrix, threadpool, 0, leanvec_d, blocked_alloc_type{});
+    auto compressed_data = storage_type::reduce(
+            data,
+            leanvec_matrix,
+            threadpool,
+            0,
+            leanvec_d,
+            blocked_alloc_type{});
 
     svs::threads::parallel_for(
-        threadpool,
-        svs::threads::StaticPartition(n),
-        [&](auto is, auto SVS_UNUSED(tid)) {
-            for(auto i : is) {
-                labels[i] = ntotal + i;
-            }
-        }
-    );
+            threadpool,
+            svs::threads::StaticPartition(n),
+            [&](auto is, auto SVS_UNUSED(tid)) {
+                for (auto i : is) {
+                    labels[i] = ntotal + i;
+                }
+            });
     ntotal += n;
 
-
-    svs::index::vamana::VamanaBuildParameters build_parameters{alpha, graph_max_degree, construction_window_size, max_candidate_pool_size, prune_to, use_full_search_history};
+    svs::index::vamana::VamanaBuildParameters build_parameters{
+            alpha,
+            graph_max_degree,
+            construction_window_size,
+            max_candidate_pool_size,
+            prune_to,
+            use_full_search_history};
 
     switch (metric_type) {
         case METRIC_INNER_PRODUCT:
-          impl = std::make_unique<svs::DynamicVamana>(svs::DynamicVamana::build<float>(
-                std::move(build_parameters),
-                std::move(compressed_data),
-                std::move(labels),
-                svs::DistanceIP(),
-                std::move(threadpool))
-              );
-          break;
+            impl = std::make_unique<svs::DynamicVamana>(
+                    svs::DynamicVamana::build<float>(
+                            std::move(build_parameters),
+                            std::move(compressed_data),
+                            std::move(labels),
+                            svs::DistanceIP(),
+                            std::move(threadpool)));
+            break;
         case METRIC_L2:
-          impl = std::make_unique<svs::DynamicVamana>(svs::DynamicVamana::build<float>(
-                std::move(build_parameters),
-                std::move(compressed_data),
-                std::move(labels),
-                svs::DistanceL2(),
-                std::move(threadpool))
-              );
-          break;
+            impl = std::make_unique<svs::DynamicVamana>(
+                    svs::DynamicVamana::build<float>(
+                            std::move(build_parameters),
+                            std::move(compressed_data),
+                            std::move(labels),
+                            svs::DistanceL2(),
+                            std::move(threadpool)));
+            break;
         default:
-          FAISS_ASSERT(!"not supported SVS distance");
+            FAISS_ASSERT(!"not supported SVS distance");
     }
 }
 
diff --git a/faiss/impl/index_read.cpp b/faiss/impl/index_read.cpp
index 1889d8602..291de78e9 100644
--- a/faiss/impl/index_read.cpp
+++ b/faiss/impl/index_read.cpp
@@ -1257,9 +1257,7 @@ Index* read_index(IOReader* f, int io_flags) {
             svs = new IndexSVS(); // uncompressed
         }
 
-        // Read class properties
-        READ1(svs->d);
-        READ1(svs->metric_type);
+        read_index_header(svs, f);
         READ1(svs->num_threads);
         READ1(svs->graph_max_degree);
         READ1(svs->alpha);
@@ -1283,6 +1281,8 @@ Index* read_index(IOReader* f, int io_flags) {
     } else if (h == fourcc("ISVF")) {
         // SVS Flat
         auto svs = new IndexSVSFlat();
+
+        idx = svs;
     } else {
         FAISS_THROW_FMT(
                 "Index type 0x%08x (\"%s\") not recognized",
diff --git a/faiss/impl/index_write.cpp b/faiss/impl/index_write.cpp
index 3105b1f88..2c741d7c3 100644
--- a/faiss/impl/index_write.cpp
+++ b/faiss/impl/index_write.cpp
@@ -896,9 +896,7 @@ void write_index(const Index* idx, IOWriter* f, int io_flags) {
             h = fourcc("ISVD"); // uncompressed
         }
         WRITE1(h);
-
-        WRITE1(svs->d);
-        WRITE1(svs->metric_type);
+        write_index_header(idx, f);
         WRITE1(svs->num_threads);
         WRITE1(svs->graph_max_degree);
         WRITE1(svs->alpha);
@@ -919,6 +917,10 @@ void write_index(const Index* idx, IOWriter* f, int io_flags) {
         WRITEANDCHECK(blob.data(), blob_size);
     } else if (
             const IndexSVSFlat* svs = dynamic_cast<const IndexSVSFlat*>(idx)) {
+        uint32_t h = fourcc("ISVF");
+        WRITE1(h);
+        write_index_header(idx, f);
+        WRITE1(svs->num_threads);
     } else {
         FAISS_THROW_MSG("don't know how to serialize this type of index");
     }
diff --git a/tests/test_svs.py b/tests/test_svs.py
index 0851b3612..a9ff6cad5 100644
--- a/tests/test_svs.py
+++ b/tests/test_svs.py
@@ -181,7 +181,7 @@ class TestSVSVamanaParameters(unittest.TestCase):
         # Verify all parameters are set correctly
         self.assertEqual(index.num_threads, 4)
         self.assertEqual(index.graph_max_degree, 32)
-        self.assertEqual(index.alpha, 1.5)
+        self.assertAlmostEqual(index.alpha, 1.5, places=6)
         self.assertEqual(index.search_window_size, 20)
         self.assertEqual(index.search_buffer_capacity, 25)
         self.assertEqual(index.construction_window_size, 80)
@@ -196,7 +196,7 @@ class TestSVSVamanaParameters(unittest.TestCase):
         # Verify default values match C++ header
         self.assertEqual(index.num_threads, 1)
         self.assertEqual(index.graph_max_degree, 64)
-        self.assertEqual(index.alpha, 1.2)
+        self.assertAlmostEqual(index.alpha, 1.2, places=6)
         self.assertEqual(index.search_window_size, 10)
         self.assertEqual(index.search_buffer_capacity, 10)
         self.assertEqual(index.construction_window_size, 40)
@@ -231,7 +231,7 @@ class TestSVSVamanaParameters(unittest.TestCase):
         self.assertIsInstance(loaded, self.target_class)
         self.assertEqual(loaded.num_threads, 8)
         self.assertEqual(loaded.graph_max_degree, 48)
-        self.assertEqual(loaded.alpha, 1.8)
+        self.assertAlmostEqual(loaded.alpha, 1.8, places=6)
         self.assertEqual(loaded.search_window_size, 15)
         self.assertEqual(loaded.search_buffer_capacity, 18)
         self.assertEqual(loaded.construction_window_size, 60)
-- 
2.39.5 (Apple Git-154)


From 9e3c48e37dd9b7af3c8aa8b171ee44f2627dea87 Mon Sep 17 00:00:00 2001
From: Aaron Lin <aaron.dl.lin@intel.com>
Date: Wed, 30 Jul 2025 17:07:58 -0700
Subject: [PATCH 14/38] support LVQ/LeanVec runtime quantization level

---
 faiss/CMakeLists.txt                          |   9 +-
 faiss/IndexSVSLVQ.cpp                         | 142 ++++++++++++++++++
 faiss/IndexSVSLVQ.h                           |  47 ++++++
 faiss/IndexSVSLVQ4x4.cpp                      |  93 ------------
 faiss/IndexSVSLVQ4x4.h                        |  43 ------
 faiss/IndexSVSLVQ4x8.cpp                      |  16 --
 faiss/IndexSVSLVQ4x8.h                        |  30 ----
 faiss/IndexSVSLeanVec.cpp                     | 106 +++++++++++++
 faiss/IndexSVSLeanVec.h                       |  53 +++++++
 faiss/IndexSVSLeanVec4x4.cpp                  |  94 ------------
 faiss/IndexSVSLeanVec4x4.h                    |  49 ------
 faiss/impl/index_read.cpp                     |  11 +-
 faiss/impl/index_write.cpp                    |   9 +-
 faiss/python/swigfaiss.swig                   |   9 +-
 .../cpp/{11-SVSLVQ4x4.cpp => 11-SVSLVQ.cpp}   |   4 +-
 ...12-SVSLeanVec4x4.cpp => 12-SVSLeanVec.cpp} |   4 +-
 tutorial/cpp/CMakeLists.txt                   |   8 +-
 tutorial/python/10-SVS.py                     |   2 +
 18 files changed, 372 insertions(+), 357 deletions(-)
 create mode 100644 faiss/IndexSVSLVQ.cpp
 create mode 100644 faiss/IndexSVSLVQ.h
 delete mode 100644 faiss/IndexSVSLVQ4x4.cpp
 delete mode 100644 faiss/IndexSVSLVQ4x4.h
 delete mode 100644 faiss/IndexSVSLVQ4x8.cpp
 delete mode 100644 faiss/IndexSVSLVQ4x8.h
 create mode 100644 faiss/IndexSVSLeanVec.cpp
 create mode 100644 faiss/IndexSVSLeanVec.h
 delete mode 100644 faiss/IndexSVSLeanVec4x4.cpp
 delete mode 100644 faiss/IndexSVSLeanVec4x4.h
 rename tutorial/cpp/{11-SVSLVQ4x4.cpp => 11-SVSLVQ.cpp} (95%)
 rename tutorial/cpp/{12-SVSLeanVec4x4.cpp => 12-SVSLeanVec.cpp} (95%)

diff --git a/faiss/CMakeLists.txt b/faiss/CMakeLists.txt
index 3463e45de..09eeb1b8e 100644
--- a/faiss/CMakeLists.txt
+++ b/faiss/CMakeLists.txt
@@ -48,10 +48,9 @@ set(FAISS_SRC
   IndexShards.cpp
   IndexShardsIVF.cpp
   IndexSVS.cpp
-  IndexSVSLVQ4x4.cpp
-  IndexSVSLVQ4x8.cpp
+  IndexSVSLVQ.cpp
   IndexSVSFlat.cpp
-  #IndexSVSLeanVec4x4.cpp
+  #IndexSVSLeanVec.cpp
   IndexNeuralNetCodec.cpp
   MatrixStats.cpp
   MetaIndexes.cpp
@@ -151,8 +150,8 @@ set(FAISS_HEADERS
   IndexShards.h
   IndexShardsIVF.h
   IndexSVS.h
-  IndexSVSLVQ4x4.h
-  #IndexSVSLeanVec4x4.h
+  IndexSVSLVQ.h
+  #IndexSVSLeanVec.h
   MatrixStats.h
   MetaIndexes.h
   MetricType.h
diff --git a/faiss/IndexSVSLVQ.cpp b/faiss/IndexSVSLVQ.cpp
new file mode 100644
index 000000000..98b65b31e
--- /dev/null
+++ b/faiss/IndexSVSLVQ.cpp
@@ -0,0 +1,142 @@
+/*
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+
+#include <variant>
+
+#include "faiss/IndexSVSLVQ.h"
+#include "svs/orchestrators/dynamic_vamana.h"
+namespace faiss {
+
+IndexSVSLVQ::IndexSVSLVQ(idx_t d, MetricType metric, LVQLevel lvq_level)
+        : IndexSVS(d, metric), lvq_level{lvq_level} {}
+
+void IndexSVSLVQ::init_impl(idx_t n, const float* x) {
+
+    // TODO: support ConstSimpleDataView in SVS shared/static lib
+    const auto data =
+            svs::data::SimpleDataView<float>(const_cast<float*>(x), n, d);
+    std::vector<size_t> labels(n);
+    auto threadpool = svs::threads::as_threadpool(num_threads);
+
+    std::variant<std::monostate, storage_type_4x0, storage_type_4x4, storage_type_4x8> compressed_data;
+
+    switch (lvq_level) {
+        case LVQLevel::LVQ_4x0:
+            compressed_data = storage_type_4x0::compress(data, threadpool, 0, blocked_alloc_type{});
+            break;
+        case LVQLevel::LVQ_4x4:
+            compressed_data = storage_type_4x4::compress(data, threadpool, 0, blocked_alloc_type{});
+            break;
+        case LVQLevel::LVQ_4x8:
+            compressed_data = storage_type_4x8::compress(data, threadpool, 0, blocked_alloc_type{});
+            break;
+        default:
+            FAISS_ASSERT(!"not supported SVS LVQ level");
+    }
+
+
+    svs::threads::parallel_for(
+            threadpool,
+            svs::threads::StaticPartition(n),
+            [&](auto is, auto SVS_UNUSED(tid)) {
+                for (auto i : is) {
+                    labels[i] = ntotal + i;
+                }
+            });
+    ntotal += n;
+
+    svs::index::vamana::VamanaBuildParameters build_parameters{
+            alpha,
+            graph_max_degree,
+            construction_window_size,
+            max_candidate_pool_size,
+            prune_to,
+            use_full_search_history};
+
+    std::visit([&](auto&& storage) {
+        if constexpr (std::is_same_v<std::decay_t<decltype(storage)>, std::monostate>) {
+            FAISS_ASSERT(!"SVS LVQ data is not initialized.");
+        }
+        else {
+            switch (metric_type) {
+                case METRIC_INNER_PRODUCT:
+                    impl = new svs::DynamicVamana(svs::DynamicVamana::build<float>(
+                            std::move(build_parameters),
+                            std::forward<decltype(storage)>(storage),
+                            std::move(labels),
+                            svs::DistanceIP(),
+                            std::move(threadpool)));
+                    break;
+                case METRIC_L2:
+                    impl = new svs::DynamicVamana(svs::DynamicVamana::build<float>(
+                            std::move(build_parameters),
+                            std::forward<decltype(storage)>(storage),
+                            std::move(labels),
+                            svs::DistanceL2(),
+                            std::move(threadpool)));
+                    break;
+                default:
+                    FAISS_ASSERT(!"not supported SVS distance");
+            }
+        }
+    }, compressed_data);
+
+}
+
+void IndexSVSLVQ::deserialize_impl(std::istream& in) {
+    FAISS_THROW_IF_MSG(
+            impl, "Cannot deserialize: SVS index already initialized.");
+
+    // Write stream to files that can be read by DynamicVamana::assemble()
+    detail::SVSTempDirectory tmp;
+    tmp.write_stream_to_files(in);
+
+    std::variant<svs::DistanceIP, svs::DistanceL2> svs_distance;
+    switch (metric_type) {
+        case METRIC_INNER_PRODUCT:
+          svs_distance = svs::DistanceIP();
+          break;
+        case METRIC_L2:
+          svs_distance = svs::DistanceL2();
+          break;
+        default:
+            FAISS_ASSERT(!"not supported SVS distance");
+    }
+
+    std::visit([&](auto&& svs_distance) {
+        switch (lvq_level) {
+            case LVQLevel::LVQ_4x0:
+                impl = new svs::DynamicVamana(svs::DynamicVamana::assemble<float>(
+                        tmp.config.string(),
+                        svs::GraphLoader(tmp.graph.string()),
+                        svs::lib::load_from_disk<storage_type_4x0>(tmp.data.string()),
+                        svs_distance,
+                        num_threads));
+                break;
+            case LVQLevel::LVQ_4x4:
+                impl = new svs::DynamicVamana(svs::DynamicVamana::assemble<float>(
+                        tmp.config.string(),
+                        svs::GraphLoader(tmp.graph.string()),
+                        svs::lib::load_from_disk<storage_type_4x4>(tmp.data.string()),
+                        svs_distance,
+                        num_threads));
+                break;
+            case LVQLevel::LVQ_4x8:
+                impl = new svs::DynamicVamana(svs::DynamicVamana::assemble<float>(
+                        tmp.config.string(),
+                        svs::GraphLoader(tmp.graph.string()),
+                        svs::lib::load_from_disk<storage_type_4x8>(tmp.data.string()),
+                        svs_distance,
+                        num_threads));
+                break;
+            default:
+                FAISS_ASSERT(!"not supported SVS LVQ level");
+        }
+    }, svs_distance);
+}
+
+} // namespace faiss
diff --git a/faiss/IndexSVSLVQ.h b/faiss/IndexSVSLVQ.h
new file mode 100644
index 000000000..4a6350655
--- /dev/null
+++ b/faiss/IndexSVSLVQ.h
@@ -0,0 +1,47 @@
+/*
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+
+#pragma once
+
+#include <faiss/IndexSVS.h>
+
+#include "svs/extensions/vamana/lvq.h"
+
+namespace faiss {
+
+enum LVQLevel {
+  LVQ_4x0,
+  LVQ_4x4,
+  LVQ_4x8
+};
+
+struct IndexSVSLVQ : IndexSVS {
+    using blocked_alloc_type =
+            svs::data::Blocked<svs::lib::Allocator<std::byte>>;
+
+    using strategy_type_4 = svs::quantization::lvq::Turbo<16, 8>;
+
+    using storage_type_4x0 = svs::quantization::lvq::
+            LVQDataset<4, 0, svs::Dynamic, strategy_type_4, blocked_alloc_type>;
+    using storage_type_4x4 = svs::quantization::lvq::
+            LVQDataset<4, 4, svs::Dynamic, strategy_type_4, blocked_alloc_type>;
+    using storage_type_4x8 = svs::quantization::lvq::
+            LVQDataset<4, 8, svs::Dynamic, strategy_type_4, blocked_alloc_type>;
+
+    IndexSVSLVQ() = default;
+    IndexSVSLVQ(idx_t d, MetricType metric = METRIC_L2, LVQLevel lvq_level = LVQLevel::LVQ_4x4);
+
+    ~IndexSVSLVQ() override = default;
+
+    void init_impl(idx_t n, const float* x) override;
+
+    void deserialize_impl(std::istream& in) override;
+
+    LVQLevel lvq_level;
+};
+
+} // namespace faiss
diff --git a/faiss/IndexSVSLVQ4x4.cpp b/faiss/IndexSVSLVQ4x4.cpp
deleted file mode 100644
index a611d885f..000000000
--- a/faiss/IndexSVSLVQ4x4.cpp
+++ /dev/null
@@ -1,93 +0,0 @@
-/*
- * Copyright (c) Meta Platforms, Inc. and affiliates.
- *
- * This source code is licensed under the MIT license found in the
- * LICENSE file in the root directory of this source tree.
- */
-
-#include "faiss/IndexSVSLVQ4x4.h"
-#include "svs/orchestrators/dynamic_vamana.h"
-namespace faiss {
-
-IndexSVSLVQ4x4::IndexSVSLVQ4x4(idx_t d, MetricType metric)
-        : IndexSVS(d, metric) {}
-
-void IndexSVSLVQ4x4::init_impl(idx_t n, const float* x) {
-    // TODO: support ConstSimpleDataView in SVS shared/static lib
-    const auto data =
-            svs::data::SimpleDataView<float>(const_cast<float*>(x), n, d);
-    std::vector<size_t> labels(n);
-    auto threadpool = svs::threads::as_threadpool(num_threads);
-    auto compressed_data =
-            storage_type::compress(data, threadpool, 0, blocked_alloc_type{});
-
-    svs::threads::parallel_for(
-            threadpool,
-            svs::threads::StaticPartition(n),
-            [&](auto is, auto SVS_UNUSED(tid)) {
-                for (auto i : is) {
-                    labels[i] = ntotal + i;
-                }
-            });
-    ntotal += n;
-
-    svs::index::vamana::VamanaBuildParameters build_parameters{
-            alpha,
-            graph_max_degree,
-            construction_window_size,
-            max_candidate_pool_size,
-            prune_to,
-            use_full_search_history};
-    switch (metric_type) {
-        case METRIC_INNER_PRODUCT:
-            impl = new svs::DynamicVamana(svs::DynamicVamana::build<float>(
-                    std::move(build_parameters),
-                    std::move(compressed_data),
-                    std::move(labels),
-                    svs::DistanceIP(),
-                    std::move(threadpool)));
-            break;
-        case METRIC_L2:
-            impl = new svs::DynamicVamana(svs::DynamicVamana::build<float>(
-                    std::move(build_parameters),
-                    std::move(compressed_data),
-                    std::move(labels),
-                    svs::DistanceL2(),
-                    std::move(threadpool)));
-            break;
-        default:
-            FAISS_ASSERT(!"not supported SVS distance");
-    }
-}
-
-void IndexSVSLVQ4x4::deserialize_impl(std::istream& in) {
-    FAISS_THROW_IF_MSG(
-            impl, "Cannot deserialize: SVS index already initialized.");
-
-    // Write stream to files that can be read by DynamicVamana::assemble()
-    detail::SVSTempDirectory tmp;
-    tmp.write_stream_to_files(in);
-
-    switch (metric_type) {
-        case METRIC_INNER_PRODUCT:
-            impl = new svs::DynamicVamana(svs::DynamicVamana::assemble<float>(
-                    tmp.config.string(),
-                    svs::GraphLoader(tmp.graph.string()),
-                    svs::lib::load_from_disk<storage_type>(tmp.data.string()),
-                    svs::distance::DistanceIP(),
-                    num_threads));
-            break;
-        case METRIC_L2:
-            impl = new svs::DynamicVamana(svs::DynamicVamana::assemble<float>(
-                    tmp.config.string(),
-                    svs::GraphLoader(tmp.graph.string()),
-                    svs::lib::load_from_disk<storage_type>(tmp.data.string()),
-                    svs::distance::DistanceL2(),
-                    num_threads));
-            break;
-        default:
-            FAISS_ASSERT(!"not supported SVS distance");
-    }
-}
-
-} // namespace faiss
diff --git a/faiss/IndexSVSLVQ4x4.h b/faiss/IndexSVSLVQ4x4.h
deleted file mode 100644
index f89919273..000000000
--- a/faiss/IndexSVSLVQ4x4.h
+++ /dev/null
@@ -1,43 +0,0 @@
-/*
- * Copyright (c) Meta Platforms, Inc. and affiliates.
- *
- * This source code is licensed under the MIT license found in the
- * LICENSE file in the root directory of this source tree.
- */
-
-#pragma once
-
-#include <faiss/IndexSVS.h>
-
-#include "svs/extensions/vamana/lvq.h"
-
-namespace faiss {
-
-// LVQ 4x0
-// LVQ 4x4
-// LVQ 4x8
-//
-//
-// allocator
-// threadpool
-
-struct IndexSVSLVQ4x4 : IndexSVS {
-    using blocked_alloc_type =
-            svs::data::Blocked<svs::lib::Allocator<std::byte>>;
-
-    using strategy_type = svs::quantization::lvq::Turbo<16, 8>;
-
-    using storage_type = svs::quantization::lvq::
-            LVQDataset<4, 4, svs::Dynamic, strategy_type, blocked_alloc_type>;
-
-    IndexSVSLVQ4x4() = default;
-    IndexSVSLVQ4x4(idx_t d, MetricType metric = METRIC_L2);
-
-    ~IndexSVSLVQ4x4() override = default;
-
-    void init_impl(idx_t n, const float* x) override;
-
-    void deserialize_impl(std::istream& in) override;
-};
-
-} // namespace faiss
diff --git a/faiss/IndexSVSLVQ4x8.cpp b/faiss/IndexSVSLVQ4x8.cpp
deleted file mode 100644
index 0bb9edeb9..000000000
--- a/faiss/IndexSVSLVQ4x8.cpp
+++ /dev/null
@@ -1,16 +0,0 @@
-
-/*
- * Copyright (c) Meta Platforms, Inc. and affiliates.
- *
- * This source code is licensed under the MIT license found in the
- * LICENSE file in the root directory of this source tree.
- */
-
-#include <faiss/IndexSVSLVQ4x8.h>
-
-namespace faiss {
-
-IndexSVSLVQ4x8::IndexSVSLVQ4x8(idx_t d, MetricType metric)
-        : IndexSVSLVQ4x4(d, metric) {}
-
-} // namespace faiss
diff --git a/faiss/IndexSVSLVQ4x8.h b/faiss/IndexSVSLVQ4x8.h
deleted file mode 100644
index 041c40d09..000000000
--- a/faiss/IndexSVSLVQ4x8.h
+++ /dev/null
@@ -1,30 +0,0 @@
-
-/*
- * Copyright (c) Meta Platforms, Inc. and affiliates.
- *
- * This source code is licensed under the MIT license found in the
- * LICENSE file in the root directory of this source tree.
- */
-
-#pragma once
-#include <faiss/IndexSVSLVQ4x4.h>
-
-namespace faiss {
-
-struct IndexSVSLVQ4x8 : IndexSVSLVQ4x4 {
-    using blocked_alloc_type =
-            svs::data::Blocked<svs::lib::Allocator<std::byte>>;
-
-    using strategy_type = svs::quantization::lvq::Turbo<16, 8>;
-
-    using storage_type = svs::quantization::lvq::
-            LVQDataset<4, 8, svs::Dynamic, strategy_type, blocked_alloc_type>;
-
-    IndexSVSLVQ4x8() = default;
-
-    IndexSVSLVQ4x8(idx_t d, MetricType metric = METRIC_L2);
-
-    ~IndexSVSLVQ4x8() override = default;
-};
-
-} // namespace faiss
diff --git a/faiss/IndexSVSLeanVec.cpp b/faiss/IndexSVSLeanVec.cpp
new file mode 100644
index 000000000..e8f0b1731
--- /dev/null
+++ b/faiss/IndexSVSLeanVec.cpp
@@ -0,0 +1,106 @@
+/*
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+
+#include <variant>
+#include <faiss/IndexSVSLeanVec.h>
+#include "svs/orchestrators/dynamic_vamana.h"
+#include "svs/core/medioid.h"
+
+namespace faiss {
+
+IndexSVSLeanVec::IndexSVSLeanVec(
+    idx_t d, 
+    MetricType metric,
+    size_t leanvec_dims,
+    LeanVecLevel leanvec_level
+): IndexSVS(d, metric), leanvec_level{leanvec_level} {
+    leanvec_d = leanvec_dims == 0 ? d / 2 : leanvec_d;
+    is_trained = false;
+}
+
+void IndexSVSLeanVec::train(idx_t n, const float* x) {
+    auto data = svs::data::ConstSimpleDataView<float>(x, n, d);
+    auto means = utils::compute_medioid(data, num_threads);
+    leanvec_matrix = compute_leanvec_matrix<svs::Dynamic, svs::Dynamic>(
+            data, means, num_threads, leanvec_d);
+    is_trained = true;
+}
+
+void IndexSVSLeanVec::reset() {
+    is_trained = false;
+    IndexSVS::reset();
+}
+
+void IndexSVSLeanVec::init_impl(idx_t n, const float* x) {
+
+    // TODO: support ConstSimpleDataView in SVS shared/static lib
+    const auto data = svs::data::SimpleDataView<float>(const_cast<float*>(x), n, d);
+    std::vector<size_t> labels(n);
+    auto threadpool = svs::threads::as_threadpool(num_threads);
+
+    std::variant<std::monostate, storage_type_4x4, storage_type_4x8, storage_type_8x8> compressed_data;
+
+    switch (leanvec_level) {
+        case LeanVecLevel::Level4x4:
+            compressed_data = storage_type_4x4::reduce(data, leanvec_matrix, threadpool, 0, leanvec_d, blocked_alloc_type{});
+            break;
+        case LeanVecLevel::Level4x8:
+            compressed_data = storage_type_4x8::reduce(data, leanvec_matrix, threadpool, 0, leanvec_d, blocked_alloc_type{});
+            break;
+        case LeanVecLevel::Level8x8:
+            compressed_data = storage_type_8x8::reduce(data, leanvec_matrix, threadpool, 0, leanvec_d, blocked_alloc_type{});
+            break;
+        default:
+            FAISS_ASSERT(!"not supported SVS LVQ level");
+    }
+
+    svs::threads::parallel_for(
+        threadpool,
+        svs::threads::StaticPartition(n),
+        [&](auto is, auto SVS_UNUSED(tid)) {
+            for(auto i : is) {
+                labels[i] = ntotal + i;
+            }
+        }
+    );
+    ntotal += n;
+
+
+    svs::index::vamana::VamanaBuildParameters build_parameters{alpha, graph_max_degree, construction_window_size, max_candidate_pool_size, prune_to, use_full_search_history};
+
+    std::visit([&](auto&& storage) {
+        if constexpr (std::is_same_v<std::decay_t<decltype(storage)>, std::monostate>) {
+            FAISS_ASSERT(!"SVS LVQ data is not initialized.");
+        }
+        else {
+            switch (metric_type) {
+                case METRIC_INNER_PRODUCT:
+                  impl = std::make_unique<svs::DynamicVamana>(svs::DynamicVamana::build<float>(
+                        std::move(build_parameters),
+                        std::forward<decltype(storage)>(storage),
+                        std::move(labels),
+                        svs::DistanceIP(),
+                        std::move(threadpool))
+                      );
+                  break;
+                case METRIC_L2:
+                  impl = std::make_unique<svs::DynamicVamana>(svs::DynamicVamana::build<float>(
+                        std::move(build_parameters),
+                        std::forward<decltype(storage)>(storage),
+                        std::move(labels),
+                        svs::DistanceL2(),
+                        std::move(threadpool))
+                      );
+                  break;
+                default:
+                  FAISS_ASSERT(!"not supported SVS distance");
+            }
+        }
+    }, compressed_data);
+}
+
+} // namespace faiss
diff --git a/faiss/IndexSVSLeanVec.h b/faiss/IndexSVSLeanVec.h
new file mode 100644
index 000000000..816de7dd0
--- /dev/null
+++ b/faiss/IndexSVSLeanVec.h
@@ -0,0 +1,53 @@
+/*
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+
+#pragma once
+
+#include <faiss/IndexSVS.h>
+
+#include "svs/extensions/vamana/leanvec.h"
+
+namespace faiss {
+
+enum class LeanVecLevel {
+  Level4x4,
+  Level4x8,
+  Level8x8
+};
+
+struct IndexSVSLeanVec : IndexSVS {
+    using leanvec_matrix_type = svs::data::SimpleData<float>;
+    using blocked_alloc_type = svs::data::Blocked<svs::lib::Allocator<std::byte>>;
+    using storage_type_4x4 = svs::leanvec::LeanDataset<svs::leanvec::UsingLVQ<4>, svs::leanvec::UsingLVQ<4>, svs::Dynamic, svs::Dynamic, blocked_alloc_type>;
+    using storage_type_4x8 = svs::leanvec::LeanDataset<svs::leanvec::UsingLVQ<4>, svs::leanvec::UsingLVQ<8>, svs::Dynamic, svs::Dynamic, blocked_alloc_type>;
+    using storage_type_8x8 = svs::leanvec::LeanDataset<svs::leanvec::UsingLVQ<8>, svs::leanvec::UsingLVQ<8>, svs::Dynamic, svs::Dynamic, blocked_alloc_type>;
+
+    IndexSVSLeanVec() = default;
+
+    IndexSVSLeanVec(
+        idx_t d, 
+        MetricType metric = METRIC_L2,
+        size_t leanvec_dims = 0,
+        LeanVecLevel leanvec_level = LeanVecLevel::Level4x4
+    );
+
+    ~IndexSVSLeanVec() override = default;
+
+    void reset() override;
+
+    void train(idx_t n, const float* x) override;
+
+    void init_impl(idx_t n, const float* x) override;
+
+    size_t leanvec_d;
+
+    LeanVecLevel leanvec_level;
+
+    leanvec_matrix_type* leanvec_matrix;
+};
+
+} // namespace faiss
diff --git a/faiss/IndexSVSLeanVec4x4.cpp b/faiss/IndexSVSLeanVec4x4.cpp
deleted file mode 100644
index a16e81dd6..000000000
--- a/faiss/IndexSVSLeanVec4x4.cpp
+++ /dev/null
@@ -1,94 +0,0 @@
-/*
- * Copyright (c) Meta Platforms, Inc. and affiliates.
- *
- * This source code is licensed under the MIT license found in the
- * LICENSE file in the root directory of this source tree.
- */
-
-#include <faiss/IndexSVSLeanVec4x4.h>
-
-namespace faiss {
-
-IndexSVSLeanVec4x4::IndexSVSLeanVec4x4(
-        idx_t d,
-        MetricType metric,
-        size_t num_threads,
-        size_t graph_max_degree,
-        size_t leanvec_dims)
-        : IndexSVS(d, metric, num_threads, graph_max_degree) {
-    leanvec_d = leanvec_dims == 0 ? d / 2 : leanvec_d;
-    is_trained = false;
-}
-
-IndexSVSLeanVec4x4::~IndexSVSLeanVec4x4() {}
-
-void IndexSVSLeanVec4x4::train(idx_t n, const float* x) {
-    auto data = svs::data::ConstSimpleDataView<float>(x, n, d);
-    auto means = utils::compute_medioid(data, num_threads);
-    leanvec_matrix = compute_leanvec_matrix<svs::Dynamic, svs::Dynamic>(
-            data, means, num_threads, leanvec_d);
-    is_trained = true;
-}
-
-void IndexSVSLeanVec4x4::reset() {
-    is_trained = false;
-    IndexSVS::reset();
-}
-
-void IndexSVSLeanVec4x4::init_impl(idx_t n, const float* x) {
-    // TODO: support ConstSimpleDataView in SVS shared/static lib
-    const auto data =
-            svs::data::SimpleDataView<float>(const_cast<float*>(x), n, d);
-    std::vector<size_t> labels(n);
-    auto threadpool = svs::threads::as_threadpool(num_threads);
-    auto compressed_data = storage_type::reduce(
-            data,
-            leanvec_matrix,
-            threadpool,
-            0,
-            leanvec_d,
-            blocked_alloc_type{});
-
-    svs::threads::parallel_for(
-            threadpool,
-            svs::threads::StaticPartition(n),
-            [&](auto is, auto SVS_UNUSED(tid)) {
-                for (auto i : is) {
-                    labels[i] = ntotal + i;
-                }
-            });
-    ntotal += n;
-
-    svs::index::vamana::VamanaBuildParameters build_parameters{
-            alpha,
-            graph_max_degree,
-            construction_window_size,
-            max_candidate_pool_size,
-            prune_to,
-            use_full_search_history};
-
-    switch (metric_type) {
-        case METRIC_INNER_PRODUCT:
-            impl = std::make_unique<svs::DynamicVamana>(
-                    svs::DynamicVamana::build<float>(
-                            std::move(build_parameters),
-                            std::move(compressed_data),
-                            std::move(labels),
-                            svs::DistanceIP(),
-                            std::move(threadpool)));
-            break;
-        case METRIC_L2:
-            impl = std::make_unique<svs::DynamicVamana>(
-                    svs::DynamicVamana::build<float>(
-                            std::move(build_parameters),
-                            std::move(compressed_data),
-                            std::move(labels),
-                            svs::DistanceL2(),
-                            std::move(threadpool)));
-            break;
-        default:
-            FAISS_ASSERT(!"not supported SVS distance");
-    }
-}
-
-} // namespace faiss
diff --git a/faiss/IndexSVSLeanVec4x4.h b/faiss/IndexSVSLeanVec4x4.h
deleted file mode 100644
index a2422066b..000000000
--- a/faiss/IndexSVSLeanVec4x4.h
+++ /dev/null
@@ -1,49 +0,0 @@
-/*
- * Copyright (c) Meta Platforms, Inc. and affiliates.
- *
- * This source code is licensed under the MIT license found in the
- * LICENSE file in the root directory of this source tree.
- */
-
-#pragma once
-
-#include <faiss/IndexSVS.h>
-
-#include "svs/extensions/vamana/leanvec.h"
-
-namespace faiss {
-
-struct IndexSVSLeanVec4x4 : IndexSVS {
-    using blocked_alloc_type =
-            svs::data::Blocked<svs::lib::Allocator<std::byte>>;
-
-    using storage_type = svs::leanvec::LeanDataset<
-            svs::leanvec::UsingLVQ<4>,
-            svs::leanvec::UsingLVQ<4>,
-            svs::Dynamic,
-            svs::Dynamic,
-            blocked_alloc_type>;
-
-    using leanvec_matrix_type = svs::data::SimpleData<float>;
-
-    IndexSVSLeanVec4x4(
-            idx_t d,
-            MetricType metric = METRIC_L2,
-            size_t num_threads = 32,
-            size_t graph_max_degree = 64,
-            size_t leanvec_dims = 0);
-
-    ~IndexSVSLeanVec4x4() override;
-
-    void reset() override;
-
-    void train(idx_t n, const float* x) override;
-
-    void init_impl(idx_t n, const float* x) override;
-
-    size_t leanvec_d;
-
-    leanvec_matrix_type* leanvec_matrix;
-};
-
-} // namespace faiss
diff --git a/faiss/impl/index_read.cpp b/faiss/impl/index_read.cpp
index 291de78e9..c9dda939a 100644
--- a/faiss/impl/index_read.cpp
+++ b/faiss/impl/index_read.cpp
@@ -47,8 +47,7 @@
 #include <faiss/IndexRowwiseMinMax.h>
 #include <faiss/IndexSVS.h>
 #include <faiss/IndexSVSFlat.h>
-#include <faiss/IndexSVSLVQ4x4.h>
-#include <faiss/IndexSVSLVQ4x8.h>
+#include <faiss/IndexSVSLVQ.h>
 #include <faiss/IndexScalarQuantizer.h>
 #include <faiss/MetaIndexes.h>
 #include <faiss/VectorTransform.h>
@@ -1247,12 +1246,10 @@ Index* read_index(IOReader* f, int io_flags) {
         read_InvertedLists(ivrq, f, io_flags);
         idx = ivrq;
     } else if (
-            h == fourcc("IS48") || h == fourcc("IS44") || h == fourcc("ISVD")) {
+            h == fourcc("ILVQ") || h == fourcc("ISVD")) {
         IndexSVS* svs;
-        if (h == fourcc("IS48")) {
-            svs = new IndexSVSLVQ4x8(); // LVQ4x8
-        } else if (h == fourcc("IS44")) {
-            svs = new IndexSVSLVQ4x4(); // LVQ4x4
+        if (h == fourcc("ILVQ")) {
+            svs = new IndexSVSLVQ(); // LVQ
         } else if (h == fourcc("ISVD")) {
             svs = new IndexSVS(); // uncompressed
         }
diff --git a/faiss/impl/index_write.cpp b/faiss/impl/index_write.cpp
index 2c741d7c3..e028404ab 100644
--- a/faiss/impl/index_write.cpp
+++ b/faiss/impl/index_write.cpp
@@ -45,8 +45,7 @@
 #include <faiss/IndexRowwiseMinMax.h>
 #include <faiss/IndexSVS.h>
 #include <faiss/IndexSVSFlat.h>
-#include <faiss/IndexSVSLVQ4x4.h>
-#include <faiss/IndexSVSLVQ4x8.h>
+#include <faiss/IndexSVSLVQ.h>
 #include <faiss/IndexScalarQuantizer.h>
 #include <faiss/MetaIndexes.h>
 #include <faiss/VectorTransform.h>
@@ -888,10 +887,8 @@ void write_index(const Index* idx, IOWriter* f, int io_flags) {
     } else if (const IndexSVS* svs = dynamic_cast<const IndexSVS*>(idx)) {
         uint32_t h;
 
-        if (dynamic_cast<const IndexSVSLVQ4x8*>(idx)) {
-            h = fourcc("IS48"); // LVQ4x8
-        } else if (dynamic_cast<const IndexSVSLVQ4x4*>(idx)) {
-            h = fourcc("IS44"); // LVQ4x4
+        if (dynamic_cast<const IndexSVSLVQ*>(idx)) {
+            h = fourcc("ILVQ"); // LVQ
         } else {
             h = fourcc("ISVD"); // uncompressed
         }
diff --git a/faiss/python/swigfaiss.swig b/faiss/python/swigfaiss.swig
index 5dd1ceb01..309478b84 100644
--- a/faiss/python/swigfaiss.swig
+++ b/faiss/python/swigfaiss.swig
@@ -196,8 +196,7 @@ typedef uint64_t size_t;
 
 #include <faiss/IndexSVS.h>
 #include <faiss/IndexSVSFlat.h>
-#include <faiss/IndexSVSLVQ4x4.h>
-#include <faiss/IndexSVSLVQ4x8.h>
+#include <faiss/IndexSVSLVQ.h>
 
 %}
 
@@ -687,8 +686,7 @@ struct faiss::simd16uint16 {};
 
 %include  <faiss/IndexSVS.h>
 %include  <faiss/IndexSVSFlat.h>
-%include  <faiss/IndexSVSLVQ4x4.h>
-%include  <faiss/IndexSVSLVQ4x8.h>
+%include  <faiss/IndexSVSLVQ.h>
 
 #ifdef GPU_WRAPPER
 
@@ -837,8 +835,7 @@ struct faiss::simd16uint16 {};
     DOWNCAST ( IndexRowwiseMinMax )
     DOWNCAST ( IndexRowwiseMinMaxFP16 )
     DOWNCAST ( IndexSVSFlat )
-    DOWNCAST ( IndexSVSLVQ4x8 )
-    DOWNCAST ( IndexSVSLVQ4x4 )
+    DOWNCAST ( IndexSVSLVQ )
     DOWNCAST ( IndexSVS )
 #ifdef GPU_WRAPPER
 #ifdef FAISS_ENABLE_CUVS
diff --git a/tutorial/cpp/11-SVSLVQ4x4.cpp b/tutorial/cpp/11-SVSLVQ.cpp
similarity index 95%
rename from tutorial/cpp/11-SVSLVQ4x4.cpp
rename to tutorial/cpp/11-SVSLVQ.cpp
index b22389359..76e9a23a7 100644
--- a/tutorial/cpp/11-SVSLVQ4x4.cpp
+++ b/tutorial/cpp/11-SVSLVQ.cpp
@@ -10,7 +10,7 @@
 #include <cstdlib>
 #include <random>
 
-#include <faiss/IndexSVSLVQ4x4.h>
+#include <faiss/IndexSVSLVQ.h>
 
 using idx_t = faiss::idx_t;
 
@@ -39,7 +39,7 @@ int main() {
 
     int k = 4;
 
-    faiss::IndexSVSLVQ4x4 index(d);
+    faiss::IndexSVSLVQ index(d);
     index.add(nb, xb);
 
     { // search xq
diff --git a/tutorial/cpp/12-SVSLeanVec4x4.cpp b/tutorial/cpp/12-SVSLeanVec.cpp
similarity index 95%
rename from tutorial/cpp/12-SVSLeanVec4x4.cpp
rename to tutorial/cpp/12-SVSLeanVec.cpp
index 8a247ce0d..d3cc68f76 100644
--- a/tutorial/cpp/12-SVSLeanVec4x4.cpp
+++ b/tutorial/cpp/12-SVSLeanVec.cpp
@@ -10,7 +10,7 @@
 #include <cstdlib>
 #include <random>
 
-#include <faiss/IndexSVSLeanVec4x4.h>
+#include <faiss/IndexSVSLeanVec.h>
 
 using idx_t = faiss::idx_t;
 
@@ -39,7 +39,7 @@ int main() {
 
     int k = 4;
 
-    faiss::IndexSVSLeanVec4x4 index(d);
+    faiss::IndexSVSLeanVec index(d);
     index.add(nb, xb);
 
     { // search xq
diff --git a/tutorial/cpp/CMakeLists.txt b/tutorial/cpp/CMakeLists.txt
index 7a563c23a..4fa5a9ae0 100644
--- a/tutorial/cpp/CMakeLists.txt
+++ b/tutorial/cpp/CMakeLists.txt
@@ -33,11 +33,11 @@ target_link_libraries(9-RefineComparison PRIVATE faiss)
 add_executable(10-SVS EXCLUDE_FROM_ALL 10-SVS.cpp)
 target_link_libraries(10-SVS PRIVATE faiss)
 
-add_executable(11-SVSLVQ4x4 EXCLUDE_FROM_ALL 11-SVSLVQ4x4.cpp)
-target_link_libraries(11-SVSLVQ4x4 PRIVATE faiss)
+add_executable(11-SVSLVQ EXCLUDE_FROM_ALL 11-SVSLVQ.cpp)
+target_link_libraries(11-SVSLVQ PRIVATE faiss)
 
-add_executable(12-SVSLeanVec4x4 EXCLUDE_FROM_ALL 12-SVSLeanVec4x4.cpp)
-target_link_libraries(12-SVSLeanVec4x4 PRIVATE faiss)
+add_executable(12-SVSLeanVec EXCLUDE_FROM_ALL 12-SVSLeanVec.cpp)
+target_link_libraries(12-SVSLeanVec PRIVATE faiss)
 
 add_executable(13-tmp-svscomp EXCLUDE_FROM_ALL 13-tmp-svscomp.cpp)
 target_link_libraries(13-tmp-svscomp PRIVATE faiss)
diff --git a/tutorial/python/10-SVS.py b/tutorial/python/10-SVS.py
index 7bd5b1377..53b76fb99 100644
--- a/tutorial/python/10-SVS.py
+++ b/tutorial/python/10-SVS.py
@@ -46,3 +46,5 @@ print(f"{k} nearest neighbors of the 5 first query vectors (after reloading)")
 print(I[:5])                   # neighbors of the 5 first queries
 print(f"{k} nearest neighbors of the 5 last query vectors (after reloading)")
 print(I[-5:])                  # neighbors of the 5 last queries
+
+idx = faiss.IndexSVSLVQ(d, faiss.METRIC_L2, faiss.LVQ_4x8) # example of using SVS LVQ
-- 
2.39.5 (Apple Git-154)


From 7eb62898a8e15f4013af8c6003cf718f1362520d Mon Sep 17 00:00:00 2001
From: Andreas Huber <andreas.huber@intel.com>
Date: Thu, 31 Jul 2025 01:44:56 -0700
Subject: [PATCH 15/38] Fix LVQ in test_svs.cpp

---
 faiss/IndexSVS.cpp         |  2 +-
 faiss/impl/index_read.cpp  |  6 ++++--
 faiss/impl/index_write.cpp |  7 ++++++-
 tests/test_svs.cpp         | 32 ++++++++++++++++++++++----------
 4 files changed, 33 insertions(+), 14 deletions(-)

diff --git a/faiss/IndexSVS.cpp b/faiss/IndexSVS.cpp
index 020fff9ad..76b17e66b 100644
--- a/faiss/IndexSVS.cpp
+++ b/faiss/IndexSVS.cpp
@@ -249,7 +249,7 @@ void IndexSVS::deserialize_impl(std::istream& in) {
             break;
         default:
             FAISS_ASSERT(!"not supported SVS distance");
-    }
+    }   
 }
 
 } // namespace faiss
diff --git a/faiss/impl/index_read.cpp b/faiss/impl/index_read.cpp
index c9dda939a..4170d5ed6 100644
--- a/faiss/impl/index_read.cpp
+++ b/faiss/impl/index_read.cpp
@@ -1245,8 +1245,7 @@ Index* read_index(IOReader* f, int io_flags) {
         READ1(ivrq->qb);
         read_InvertedLists(ivrq, f, io_flags);
         idx = ivrq;
-    } else if (
-            h == fourcc("ILVQ") || h == fourcc("ISVD")) {
+    } else if (h == fourcc("ILVQ") || h == fourcc("ISVD")) {
         IndexSVS* svs;
         if (h == fourcc("ILVQ")) {
             svs = new IndexSVSLVQ(); // LVQ
@@ -1264,6 +1263,9 @@ Index* read_index(IOReader* f, int io_flags) {
         READ1(svs->max_candidate_pool_size);
         READ1(svs->prune_to);
         READ1(svs->use_full_search_history);
+        if (h == fourcc("ILVQ")) {
+            READ1(dynamic_cast<IndexSVSLVQ*>(svs)->lvq_level);
+        }
 
         // Read the binary blob from which impl will be reconstructed
         uint64_t blob_size;
diff --git a/faiss/impl/index_write.cpp b/faiss/impl/index_write.cpp
index e028404ab..ad4ee4eb5 100644
--- a/faiss/impl/index_write.cpp
+++ b/faiss/impl/index_write.cpp
@@ -887,7 +887,9 @@ void write_index(const Index* idx, IOWriter* f, int io_flags) {
     } else if (const IndexSVS* svs = dynamic_cast<const IndexSVS*>(idx)) {
         uint32_t h;
 
-        if (dynamic_cast<const IndexSVSLVQ*>(idx)) {
+        auto* lvq = dynamic_cast<const IndexSVSLVQ*>(idx);
+
+        if (lvq != nullptr) {
             h = fourcc("ILVQ"); // LVQ
         } else {
             h = fourcc("ISVD"); // uncompressed
@@ -903,6 +905,9 @@ void write_index(const Index* idx, IOWriter* f, int io_flags) {
         WRITE1(svs->max_candidate_pool_size);
         WRITE1(svs->prune_to);
         WRITE1(svs->use_full_search_history);
+        if (lvq != nullptr) {
+            WRITE1(lvq->lvq_level);
+        }
 
         std::stringstream ss;
         svs->serialize_impl(ss);
diff --git a/tests/test_svs.cpp b/tests/test_svs.cpp
index dbdc34f51..0675320d6 100644
--- a/tests/test_svs.cpp
+++ b/tests/test_svs.cpp
@@ -7,8 +7,7 @@
 
 #include <faiss/Index.h>
 #include <faiss/IndexSVS.h>
-#include <faiss/IndexSVSLVQ4x4.h>
-#include <faiss/IndexSVSLVQ4x8.h>
+#include <faiss/IndexSVSLVQ.h>
 #include <faiss/index_io.h>
 #include <gtest/gtest.h>
 
@@ -19,10 +18,8 @@ pthread_mutex_t temp_file_mutex = PTHREAD_MUTEX_INITIALIZER;
 }
 
 template <typename T>
-void write_and_read_index() {
-    constexpr faiss::idx_t d = 64;
-    T index(d);
-    std::vector<float> xb(d * 100);
+void write_and_read_index(T& index) {
+    std::vector<float> xb(index.d * 100);
     std::mt19937 gen(123);
     std::uniform_real_distribution<float> dis(0.0f, 1.0f);
     for (size_t i = 0; i < xb.size(); ++i) {
@@ -60,13 +57,28 @@ void write_and_read_index() {
 }
 
 TEST(SVSIO, WriteAndReadIndexIndexSVS) {
-    write_and_read_index<faiss::IndexSVS>();
+    constexpr faiss::idx_t d = 64;
+    faiss::IndexSVS index{d};
+    write_and_read_index(index);
+}
+
+TEST(SVSIO, WriteAndReadIndexIndexSVSLVQ4x0) {
+    constexpr faiss::idx_t d = 64;
+    faiss::IndexSVSLVQ index{d};
+    index.lvq_level = faiss::LVQLevel::LVQ_4x0;
+    write_and_read_index(index);
 }
 
 TEST(SVSIO, WriteAndReadIndexIndexSVSLVQ4x4) {
-    write_and_read_index<faiss::IndexSVSLVQ4x4>();
+    constexpr faiss::idx_t d = 64;
+    faiss::IndexSVSLVQ index{d};
+    index.lvq_level = faiss::LVQLevel::LVQ_4x4;
+    write_and_read_index(index);
 }
 
 TEST(SVSIO, WriteAndReadIndexIndexSVSLVQ4x8) {
-    write_and_read_index<faiss::IndexSVSLVQ4x8>();
-}
+    constexpr faiss::idx_t d = 64;
+    faiss::IndexSVSLVQ index{d};
+    index.lvq_level = faiss::LVQLevel::LVQ_4x8;
+    write_and_read_index(index);
+}
\ No newline at end of file
-- 
2.39.5 (Apple Git-154)


From 6dbb96fb269cb3b070af03c26f3dd03b6b3e223f Mon Sep 17 00:00:00 2001
From: Andreas Huber <andreas.huber@intel.com>
Date: Thu, 31 Jul 2025 01:48:32 -0700
Subject: [PATCH 16/38] clang-format

---
 faiss/IndexSVS.cpp        |   2 +-
 faiss/IndexSVSLVQ.cpp     | 159 ++++++++++++++++++++++----------------
 faiss/IndexSVSLVQ.h       |  11 ++-
 faiss/IndexSVSLeanVec.cpp | 136 +++++++++++++++++++-------------
 faiss/IndexSVSLeanVec.h   |  39 ++++++----
 tests/test_svs.cpp        |   2 +-
 6 files changed, 207 insertions(+), 142 deletions(-)

diff --git a/faiss/IndexSVS.cpp b/faiss/IndexSVS.cpp
index 76b17e66b..020fff9ad 100644
--- a/faiss/IndexSVS.cpp
+++ b/faiss/IndexSVS.cpp
@@ -249,7 +249,7 @@ void IndexSVS::deserialize_impl(std::istream& in) {
             break;
         default:
             FAISS_ASSERT(!"not supported SVS distance");
-    }   
+    }
 }
 
 } // namespace faiss
diff --git a/faiss/IndexSVSLVQ.cpp b/faiss/IndexSVSLVQ.cpp
index 98b65b31e..36fcd8968 100644
--- a/faiss/IndexSVSLVQ.cpp
+++ b/faiss/IndexSVSLVQ.cpp
@@ -15,30 +15,36 @@ IndexSVSLVQ::IndexSVSLVQ(idx_t d, MetricType metric, LVQLevel lvq_level)
         : IndexSVS(d, metric), lvq_level{lvq_level} {}
 
 void IndexSVSLVQ::init_impl(idx_t n, const float* x) {
-
     // TODO: support ConstSimpleDataView in SVS shared/static lib
     const auto data =
             svs::data::SimpleDataView<float>(const_cast<float*>(x), n, d);
     std::vector<size_t> labels(n);
     auto threadpool = svs::threads::as_threadpool(num_threads);
 
-    std::variant<std::monostate, storage_type_4x0, storage_type_4x4, storage_type_4x8> compressed_data;
+    std::variant<
+            std::monostate,
+            storage_type_4x0,
+            storage_type_4x4,
+            storage_type_4x8>
+            compressed_data;
 
     switch (lvq_level) {
         case LVQLevel::LVQ_4x0:
-            compressed_data = storage_type_4x0::compress(data, threadpool, 0, blocked_alloc_type{});
+            compressed_data = storage_type_4x0::compress(
+                    data, threadpool, 0, blocked_alloc_type{});
             break;
         case LVQLevel::LVQ_4x4:
-            compressed_data = storage_type_4x4::compress(data, threadpool, 0, blocked_alloc_type{});
+            compressed_data = storage_type_4x4::compress(
+                    data, threadpool, 0, blocked_alloc_type{});
             break;
         case LVQLevel::LVQ_4x8:
-            compressed_data = storage_type_4x8::compress(data, threadpool, 0, blocked_alloc_type{});
+            compressed_data = storage_type_4x8::compress(
+                    data, threadpool, 0, blocked_alloc_type{});
             break;
         default:
             FAISS_ASSERT(!"not supported SVS LVQ level");
     }
 
-
     svs::threads::parallel_for(
             threadpool,
             svs::threads::StaticPartition(n),
@@ -57,34 +63,40 @@ void IndexSVSLVQ::init_impl(idx_t n, const float* x) {
             prune_to,
             use_full_search_history};
 
-    std::visit([&](auto&& storage) {
-        if constexpr (std::is_same_v<std::decay_t<decltype(storage)>, std::monostate>) {
-            FAISS_ASSERT(!"SVS LVQ data is not initialized.");
-        }
-        else {
-            switch (metric_type) {
-                case METRIC_INNER_PRODUCT:
-                    impl = new svs::DynamicVamana(svs::DynamicVamana::build<float>(
-                            std::move(build_parameters),
-                            std::forward<decltype(storage)>(storage),
-                            std::move(labels),
-                            svs::DistanceIP(),
-                            std::move(threadpool)));
-                    break;
-                case METRIC_L2:
-                    impl = new svs::DynamicVamana(svs::DynamicVamana::build<float>(
-                            std::move(build_parameters),
-                            std::forward<decltype(storage)>(storage),
-                            std::move(labels),
-                            svs::DistanceL2(),
-                            std::move(threadpool)));
-                    break;
-                default:
-                    FAISS_ASSERT(!"not supported SVS distance");
-            }
-        }
-    }, compressed_data);
-
+    std::visit(
+            [&](auto&& storage) {
+                if constexpr (std::is_same_v<
+                                      std::decay_t<decltype(storage)>,
+                                      std::monostate>) {
+                    FAISS_ASSERT(!"SVS LVQ data is not initialized.");
+                } else {
+                    switch (metric_type) {
+                        case METRIC_INNER_PRODUCT:
+                            impl = new svs::DynamicVamana(
+                                    svs::DynamicVamana::build<float>(
+                                            std::move(build_parameters),
+                                            std::forward<decltype(storage)>(
+                                                    storage),
+                                            std::move(labels),
+                                            svs::DistanceIP(),
+                                            std::move(threadpool)));
+                            break;
+                        case METRIC_L2:
+                            impl = new svs::DynamicVamana(
+                                    svs::DynamicVamana::build<float>(
+                                            std::move(build_parameters),
+                                            std::forward<decltype(storage)>(
+                                                    storage),
+                                            std::move(labels),
+                                            svs::DistanceL2(),
+                                            std::move(threadpool)));
+                            break;
+                        default:
+                            FAISS_ASSERT(!"not supported SVS distance");
+                    }
+                }
+            },
+            compressed_data);
 }
 
 void IndexSVSLVQ::deserialize_impl(std::istream& in) {
@@ -98,45 +110,56 @@ void IndexSVSLVQ::deserialize_impl(std::istream& in) {
     std::variant<svs::DistanceIP, svs::DistanceL2> svs_distance;
     switch (metric_type) {
         case METRIC_INNER_PRODUCT:
-          svs_distance = svs::DistanceIP();
-          break;
+            svs_distance = svs::DistanceIP();
+            break;
         case METRIC_L2:
-          svs_distance = svs::DistanceL2();
-          break;
+            svs_distance = svs::DistanceL2();
+            break;
         default:
             FAISS_ASSERT(!"not supported SVS distance");
     }
 
-    std::visit([&](auto&& svs_distance) {
-        switch (lvq_level) {
-            case LVQLevel::LVQ_4x0:
-                impl = new svs::DynamicVamana(svs::DynamicVamana::assemble<float>(
-                        tmp.config.string(),
-                        svs::GraphLoader(tmp.graph.string()),
-                        svs::lib::load_from_disk<storage_type_4x0>(tmp.data.string()),
-                        svs_distance,
-                        num_threads));
-                break;
-            case LVQLevel::LVQ_4x4:
-                impl = new svs::DynamicVamana(svs::DynamicVamana::assemble<float>(
-                        tmp.config.string(),
-                        svs::GraphLoader(tmp.graph.string()),
-                        svs::lib::load_from_disk<storage_type_4x4>(tmp.data.string()),
-                        svs_distance,
-                        num_threads));
-                break;
-            case LVQLevel::LVQ_4x8:
-                impl = new svs::DynamicVamana(svs::DynamicVamana::assemble<float>(
-                        tmp.config.string(),
-                        svs::GraphLoader(tmp.graph.string()),
-                        svs::lib::load_from_disk<storage_type_4x8>(tmp.data.string()),
-                        svs_distance,
-                        num_threads));
-                break;
-            default:
-                FAISS_ASSERT(!"not supported SVS LVQ level");
-        }
-    }, svs_distance);
+    std::visit(
+            [&](auto&& svs_distance) {
+                switch (lvq_level) {
+                    case LVQLevel::LVQ_4x0:
+                        impl = new svs::DynamicVamana(
+                                svs::DynamicVamana::assemble<float>(
+                                        tmp.config.string(),
+                                        svs::GraphLoader(tmp.graph.string()),
+                                        svs::lib::load_from_disk<
+                                                storage_type_4x0>(
+                                                tmp.data.string()),
+                                        svs_distance,
+                                        num_threads));
+                        break;
+                    case LVQLevel::LVQ_4x4:
+                        impl = new svs::DynamicVamana(
+                                svs::DynamicVamana::assemble<float>(
+                                        tmp.config.string(),
+                                        svs::GraphLoader(tmp.graph.string()),
+                                        svs::lib::load_from_disk<
+                                                storage_type_4x4>(
+                                                tmp.data.string()),
+                                        svs_distance,
+                                        num_threads));
+                        break;
+                    case LVQLevel::LVQ_4x8:
+                        impl = new svs::DynamicVamana(
+                                svs::DynamicVamana::assemble<float>(
+                                        tmp.config.string(),
+                                        svs::GraphLoader(tmp.graph.string()),
+                                        svs::lib::load_from_disk<
+                                                storage_type_4x8>(
+                                                tmp.data.string()),
+                                        svs_distance,
+                                        num_threads));
+                        break;
+                    default:
+                        FAISS_ASSERT(!"not supported SVS LVQ level");
+                }
+            },
+            svs_distance);
 }
 
 } // namespace faiss
diff --git a/faiss/IndexSVSLVQ.h b/faiss/IndexSVSLVQ.h
index 4a6350655..49a7d1dbf 100644
--- a/faiss/IndexSVSLVQ.h
+++ b/faiss/IndexSVSLVQ.h
@@ -13,11 +13,7 @@
 
 namespace faiss {
 
-enum LVQLevel {
-  LVQ_4x0,
-  LVQ_4x4,
-  LVQ_4x8
-};
+enum LVQLevel { LVQ_4x0, LVQ_4x4, LVQ_4x8 };
 
 struct IndexSVSLVQ : IndexSVS {
     using blocked_alloc_type =
@@ -33,7 +29,10 @@ struct IndexSVSLVQ : IndexSVS {
             LVQDataset<4, 8, svs::Dynamic, strategy_type_4, blocked_alloc_type>;
 
     IndexSVSLVQ() = default;
-    IndexSVSLVQ(idx_t d, MetricType metric = METRIC_L2, LVQLevel lvq_level = LVQLevel::LVQ_4x4);
+    IndexSVSLVQ(
+            idx_t d,
+            MetricType metric = METRIC_L2,
+            LVQLevel lvq_level = LVQLevel::LVQ_4x4);
 
     ~IndexSVSLVQ() override = default;
 
diff --git a/faiss/IndexSVSLeanVec.cpp b/faiss/IndexSVSLeanVec.cpp
index e8f0b1731..fc82ee67d 100644
--- a/faiss/IndexSVSLeanVec.cpp
+++ b/faiss/IndexSVSLeanVec.cpp
@@ -5,19 +5,19 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <variant>
 #include <faiss/IndexSVSLeanVec.h>
-#include "svs/orchestrators/dynamic_vamana.h"
+#include <variant>
 #include "svs/core/medioid.h"
+#include "svs/orchestrators/dynamic_vamana.h"
 
 namespace faiss {
 
 IndexSVSLeanVec::IndexSVSLeanVec(
-    idx_t d, 
-    MetricType metric,
-    size_t leanvec_dims,
-    LeanVecLevel leanvec_level
-): IndexSVS(d, metric), leanvec_level{leanvec_level} {
+        idx_t d,
+        MetricType metric,
+        size_t leanvec_dims,
+        LeanVecLevel leanvec_level)
+        : IndexSVS(d, metric), leanvec_level{leanvec_level} {
     leanvec_d = leanvec_dims == 0 ? d / 2 : leanvec_d;
     is_trained = false;
 }
@@ -36,71 +36,103 @@ void IndexSVSLeanVec::reset() {
 }
 
 void IndexSVSLeanVec::init_impl(idx_t n, const float* x) {
-
     // TODO: support ConstSimpleDataView in SVS shared/static lib
-    const auto data = svs::data::SimpleDataView<float>(const_cast<float*>(x), n, d);
+    const auto data =
+            svs::data::SimpleDataView<float>(const_cast<float*>(x), n, d);
     std::vector<size_t> labels(n);
     auto threadpool = svs::threads::as_threadpool(num_threads);
 
-    std::variant<std::monostate, storage_type_4x4, storage_type_4x8, storage_type_8x8> compressed_data;
+    std::variant<
+            std::monostate,
+            storage_type_4x4,
+            storage_type_4x8,
+            storage_type_8x8>
+            compressed_data;
 
     switch (leanvec_level) {
         case LeanVecLevel::Level4x4:
-            compressed_data = storage_type_4x4::reduce(data, leanvec_matrix, threadpool, 0, leanvec_d, blocked_alloc_type{});
+            compressed_data = storage_type_4x4::reduce(
+                    data,
+                    leanvec_matrix,
+                    threadpool,
+                    0,
+                    leanvec_d,
+                    blocked_alloc_type{});
             break;
         case LeanVecLevel::Level4x8:
-            compressed_data = storage_type_4x8::reduce(data, leanvec_matrix, threadpool, 0, leanvec_d, blocked_alloc_type{});
+            compressed_data = storage_type_4x8::reduce(
+                    data,
+                    leanvec_matrix,
+                    threadpool,
+                    0,
+                    leanvec_d,
+                    blocked_alloc_type{});
             break;
         case LeanVecLevel::Level8x8:
-            compressed_data = storage_type_8x8::reduce(data, leanvec_matrix, threadpool, 0, leanvec_d, blocked_alloc_type{});
+            compressed_data = storage_type_8x8::reduce(
+                    data,
+                    leanvec_matrix,
+                    threadpool,
+                    0,
+                    leanvec_d,
+                    blocked_alloc_type{});
             break;
         default:
             FAISS_ASSERT(!"not supported SVS LVQ level");
     }
 
     svs::threads::parallel_for(
-        threadpool,
-        svs::threads::StaticPartition(n),
-        [&](auto is, auto SVS_UNUSED(tid)) {
-            for(auto i : is) {
-                labels[i] = ntotal + i;
-            }
-        }
-    );
+            threadpool,
+            svs::threads::StaticPartition(n),
+            [&](auto is, auto SVS_UNUSED(tid)) {
+                for (auto i : is) {
+                    labels[i] = ntotal + i;
+                }
+            });
     ntotal += n;
 
+    svs::index::vamana::VamanaBuildParameters build_parameters{
+            alpha,
+            graph_max_degree,
+            construction_window_size,
+            max_candidate_pool_size,
+            prune_to,
+            use_full_search_history};
 
-    svs::index::vamana::VamanaBuildParameters build_parameters{alpha, graph_max_degree, construction_window_size, max_candidate_pool_size, prune_to, use_full_search_history};
-
-    std::visit([&](auto&& storage) {
-        if constexpr (std::is_same_v<std::decay_t<decltype(storage)>, std::monostate>) {
-            FAISS_ASSERT(!"SVS LVQ data is not initialized.");
-        }
-        else {
-            switch (metric_type) {
-                case METRIC_INNER_PRODUCT:
-                  impl = std::make_unique<svs::DynamicVamana>(svs::DynamicVamana::build<float>(
-                        std::move(build_parameters),
-                        std::forward<decltype(storage)>(storage),
-                        std::move(labels),
-                        svs::DistanceIP(),
-                        std::move(threadpool))
-                      );
-                  break;
-                case METRIC_L2:
-                  impl = std::make_unique<svs::DynamicVamana>(svs::DynamicVamana::build<float>(
-                        std::move(build_parameters),
-                        std::forward<decltype(storage)>(storage),
-                        std::move(labels),
-                        svs::DistanceL2(),
-                        std::move(threadpool))
-                      );
-                  break;
-                default:
-                  FAISS_ASSERT(!"not supported SVS distance");
-            }
-        }
-    }, compressed_data);
+    std::visit(
+            [&](auto&& storage) {
+                if constexpr (std::is_same_v<
+                                      std::decay_t<decltype(storage)>,
+                                      std::monostate>) {
+                    FAISS_ASSERT(!"SVS LVQ data is not initialized.");
+                } else {
+                    switch (metric_type) {
+                        case METRIC_INNER_PRODUCT:
+                            impl = std::make_unique<svs::DynamicVamana>(
+                                    svs::DynamicVamana::build<float>(
+                                            std::move(build_parameters),
+                                            std::forward<decltype(storage)>(
+                                                    storage),
+                                            std::move(labels),
+                                            svs::DistanceIP(),
+                                            std::move(threadpool)));
+                            break;
+                        case METRIC_L2:
+                            impl = std::make_unique<svs::DynamicVamana>(
+                                    svs::DynamicVamana::build<float>(
+                                            std::move(build_parameters),
+                                            std::forward<decltype(storage)>(
+                                                    storage),
+                                            std::move(labels),
+                                            svs::DistanceL2(),
+                                            std::move(threadpool)));
+                            break;
+                        default:
+                            FAISS_ASSERT(!"not supported SVS distance");
+                    }
+                }
+            },
+            compressed_data);
 }
 
 } // namespace faiss
diff --git a/faiss/IndexSVSLeanVec.h b/faiss/IndexSVSLeanVec.h
index 816de7dd0..f59e5f7b5 100644
--- a/faiss/IndexSVSLeanVec.h
+++ b/faiss/IndexSVSLeanVec.h
@@ -13,27 +13,38 @@
 
 namespace faiss {
 
-enum class LeanVecLevel {
-  Level4x4,
-  Level4x8,
-  Level8x8
-};
+enum class LeanVecLevel { Level4x4, Level4x8, Level8x8 };
 
 struct IndexSVSLeanVec : IndexSVS {
     using leanvec_matrix_type = svs::data::SimpleData<float>;
-    using blocked_alloc_type = svs::data::Blocked<svs::lib::Allocator<std::byte>>;
-    using storage_type_4x4 = svs::leanvec::LeanDataset<svs::leanvec::UsingLVQ<4>, svs::leanvec::UsingLVQ<4>, svs::Dynamic, svs::Dynamic, blocked_alloc_type>;
-    using storage_type_4x8 = svs::leanvec::LeanDataset<svs::leanvec::UsingLVQ<4>, svs::leanvec::UsingLVQ<8>, svs::Dynamic, svs::Dynamic, blocked_alloc_type>;
-    using storage_type_8x8 = svs::leanvec::LeanDataset<svs::leanvec::UsingLVQ<8>, svs::leanvec::UsingLVQ<8>, svs::Dynamic, svs::Dynamic, blocked_alloc_type>;
+    using blocked_alloc_type =
+            svs::data::Blocked<svs::lib::Allocator<std::byte>>;
+    using storage_type_4x4 = svs::leanvec::LeanDataset<
+            svs::leanvec::UsingLVQ<4>,
+            svs::leanvec::UsingLVQ<4>,
+            svs::Dynamic,
+            svs::Dynamic,
+            blocked_alloc_type>;
+    using storage_type_4x8 = svs::leanvec::LeanDataset<
+            svs::leanvec::UsingLVQ<4>,
+            svs::leanvec::UsingLVQ<8>,
+            svs::Dynamic,
+            svs::Dynamic,
+            blocked_alloc_type>;
+    using storage_type_8x8 = svs::leanvec::LeanDataset<
+            svs::leanvec::UsingLVQ<8>,
+            svs::leanvec::UsingLVQ<8>,
+            svs::Dynamic,
+            svs::Dynamic,
+            blocked_alloc_type>;
 
     IndexSVSLeanVec() = default;
 
     IndexSVSLeanVec(
-        idx_t d, 
-        MetricType metric = METRIC_L2,
-        size_t leanvec_dims = 0,
-        LeanVecLevel leanvec_level = LeanVecLevel::Level4x4
-    );
+            idx_t d,
+            MetricType metric = METRIC_L2,
+            size_t leanvec_dims = 0,
+            LeanVecLevel leanvec_level = LeanVecLevel::Level4x4);
 
     ~IndexSVSLeanVec() override = default;
 
diff --git a/tests/test_svs.cpp b/tests/test_svs.cpp
index 0675320d6..63d34fb41 100644
--- a/tests/test_svs.cpp
+++ b/tests/test_svs.cpp
@@ -81,4 +81,4 @@ TEST(SVSIO, WriteAndReadIndexIndexSVSLVQ4x8) {
     faiss::IndexSVSLVQ index{d};
     index.lvq_level = faiss::LVQLevel::LVQ_4x8;
     write_and_read_index(index);
-}
\ No newline at end of file
+}
-- 
2.39.5 (Apple Git-154)


From 90b15b6d327cbacda56bcc036a38e48558733f44 Mon Sep 17 00:00:00 2001
From: Andreas Huber <andreas.huber@intel.com>
Date: Thu, 31 Jul 2025 01:53:57 -0700
Subject: [PATCH 17/38] fix impl cleanup in destructor

---
 faiss/IndexSVS.cpp | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/faiss/IndexSVS.cpp b/faiss/IndexSVS.cpp
index 020fff9ad..f08f93038 100644
--- a/faiss/IndexSVS.cpp
+++ b/faiss/IndexSVS.cpp
@@ -29,7 +29,7 @@ SVSTempDirectory::SVSTempDirectory() {
 
 SVSTempDirectory::~SVSTempDirectory() {
     std::error_code ec;
-    std::filesystem::remove_all(root, ec); // best-effort cleanup
+    std::filesystem::remove_all(root, ec);
 }
 
 void SVSTempDirectory::write_files_to_stream(std::ostream& out) const {
@@ -107,6 +107,7 @@ IndexSVS::IndexSVS(idx_t d, MetricType metric) : Index(d, metric) {
 IndexSVS::~IndexSVS() {
     if (impl) {
         delete impl;
+        impl = nullptr;
     }
 }
 
-- 
2.39.5 (Apple Git-154)


From 38b7eea6a6f3de5741d7629565a377ded1b0d7b5 Mon Sep 17 00:00:00 2001
From: Andreas Huber <andreas.huber@intel.com>
Date: Thu, 31 Jul 2025 05:48:50 -0700
Subject: [PATCH 18/38] continue work on C++ & py tests

---
 faiss/IndexSVSFlat.cpp    |   2 +
 faiss/impl/index_read.cpp |   6 ++-
 tests/test_svs.cpp        |  88 ++++++++++++++++++++++++--------
 tests/test_svs.py         | 105 +++++++++++++++++++++++++++++++-------
 4 files changed, 160 insertions(+), 41 deletions(-)

diff --git a/faiss/IndexSVSFlat.cpp b/faiss/IndexSVSFlat.cpp
index 5c4feef1a..e3bba65db 100644
--- a/faiss/IndexSVSFlat.cpp
+++ b/faiss/IndexSVSFlat.cpp
@@ -32,6 +32,7 @@ void IndexSVSFlat::reset() {
         delete impl;
         impl = nullptr;
     }
+    ntotal = 0;
 }
 
 IndexSVSFlat::~IndexSVSFlat() {}
@@ -69,6 +70,7 @@ void IndexSVSFlat::search(
 void IndexSVSFlat::init_impl(idx_t n, const float* x) {
     auto data = svs::data::SimpleData<float>(n, d);
     auto threadpool = svs::threads::as_threadpool(num_threads);
+    ntotal = n;
 
     svs::threads::parallel_for(
             threadpool,
diff --git a/faiss/impl/index_read.cpp b/faiss/impl/index_read.cpp
index 4170d5ed6..cc29dce10 100644
--- a/faiss/impl/index_read.cpp
+++ b/faiss/impl/index_read.cpp
@@ -1276,11 +1276,13 @@ Index* read_index(IOReader* f, int io_flags) {
         svs->deserialize_impl(ss);
         idx = svs;
     } else if (h == fourcc("ISVS")) {
+        // TODO
         // SVS static vamana
     } else if (h == fourcc("ISVF")) {
         // SVS Flat
-        auto svs = new IndexSVSFlat();
-
+        IndexSVSFlat* svs = new IndexSVSFlat();
+        read_index_header(svs, f);
+        READ1(svs->num_threads);
         idx = svs;
     } else {
         FAISS_THROW_FMT(
diff --git a/tests/test_svs.cpp b/tests/test_svs.cpp
index 63d34fb41..398e66139 100644
--- a/tests/test_svs.cpp
+++ b/tests/test_svs.cpp
@@ -7,25 +7,45 @@
 
 #include <faiss/Index.h>
 #include <faiss/IndexSVS.h>
+#include <faiss/IndexSVSFlat.h>
 #include <faiss/IndexSVSLVQ.h>
 #include <faiss/index_io.h>
 #include <gtest/gtest.h>
+#include <type_traits>
 
 #include "test_util.h"
 
 namespace {
 pthread_mutex_t temp_file_mutex = PTHREAD_MUTEX_INITIALIZER;
-}
 
-template <typename T>
-void write_and_read_index(T& index) {
-    std::vector<float> xb(index.d * 100);
-    std::mt19937 gen(123);
-    std::uniform_real_distribution<float> dis(0.0f, 1.0f);
-    for (size_t i = 0; i < xb.size(); ++i) {
-        xb[i] = dis(gen);
+// Test fixture class to manage shared test data
+class SVSIOTest : public ::testing::Test {
+   protected:
+    static void SetUpTestSuite() {
+        // Generate test data once for all tests
+        constexpr size_t d = 64;
+        constexpr size_t n = 100;
+        test_data.resize(d * n);
+
+        std::mt19937 gen(123);
+        std::uniform_real_distribution<float> dis(0.0f, 1.0f);
+        for (size_t i = 0; i < test_data.size(); ++i) {
+            test_data[i] = dis(gen);
+        }
     }
-    index.add(100, xb.data());
+
+    static std::vector<float> test_data;
+    static constexpr size_t d = 64;
+    static constexpr size_t n = 100;
+};
+
+// Define static members
+std::vector<float> SVSIOTest::test_data;
+} // namespace
+
+template <typename T>
+void write_and_read_index(T& index, const std::vector<float>& xb, size_t n) {
+    index.add(n, xb.data());
 
     std::string temp_filename_template = "/tmp/faiss_svs_test_XXXXXX";
     Tempfilename filename(&temp_file_mutex, temp_filename_template);
@@ -52,33 +72,59 @@ void write_and_read_index(T& index) {
     EXPECT_EQ(loaded->max_candidate_pool_size, index.max_candidate_pool_size);
     EXPECT_EQ(loaded->prune_to, index.prune_to);
     EXPECT_EQ(loaded->use_full_search_history, index.use_full_search_history);
+    if constexpr (std::is_same_v<std::decay_t<T>, faiss::IndexSVSLVQ>) {
+        auto* lvq_loaded = dynamic_cast<faiss::IndexSVSLVQ*>(loaded);
+        ASSERT_NE(lvq_loaded, nullptr);
+        EXPECT_EQ(lvq_loaded->lvq_level, index.lvq_level);
+    }
 
     delete loaded;
 }
 
-TEST(SVSIO, WriteAndReadIndexIndexSVS) {
-    constexpr faiss::idx_t d = 64;
+TEST_F(SVSIOTest, WriteAndReadIndexSVS) {
     faiss::IndexSVS index{d};
-    write_and_read_index(index);
+    write_and_read_index(index, test_data, n);
 }
 
-TEST(SVSIO, WriteAndReadIndexIndexSVSLVQ4x0) {
-    constexpr faiss::idx_t d = 64;
+TEST_F(SVSIOTest, WriteAndReadIndexSVSLVQ4x0) {
     faiss::IndexSVSLVQ index{d};
     index.lvq_level = faiss::LVQLevel::LVQ_4x0;
-    write_and_read_index(index);
+    write_and_read_index(index, test_data, n);
 }
 
-TEST(SVSIO, WriteAndReadIndexIndexSVSLVQ4x4) {
-    constexpr faiss::idx_t d = 64;
+TEST_F(SVSIOTest, WriteAndReadIndexSVSLVQ4x4) {
     faiss::IndexSVSLVQ index{d};
     index.lvq_level = faiss::LVQLevel::LVQ_4x4;
-    write_and_read_index(index);
+    write_and_read_index(index, test_data, n);
 }
 
-TEST(SVSIO, WriteAndReadIndexIndexSVSLVQ4x8) {
-    constexpr faiss::idx_t d = 64;
+TEST_F(SVSIOTest, WriteAndReadIndexSVSLVQ4x8) {
     faiss::IndexSVSLVQ index{d};
     index.lvq_level = faiss::LVQLevel::LVQ_4x8;
-    write_and_read_index(index);
+    write_and_read_index(index, test_data, n);
+}
+
+TEST_F(SVSIOTest, WriteAndReadIndexSVSFlat) {
+    faiss::IndexSVSFlat index{d};
+    index.add(n, test_data.data());
+
+    std::string temp_filename_template = "/tmp/faiss_svs_test_XXXXXX";
+    Tempfilename filename(&temp_file_mutex, temp_filename_template);
+
+    // Serialize
+    ASSERT_NO_THROW({ faiss::write_index(&index, filename.c_str()); });
+
+    // Deserialize
+    faiss::IndexSVSFlat* loaded = nullptr;
+    ASSERT_NO_THROW({
+        loaded = dynamic_cast<faiss::IndexSVSFlat*>(
+                faiss::read_index(filename.c_str()));
+    });
+
+    ASSERT_NE(loaded, nullptr);
+    EXPECT_EQ(loaded->d, index.d);
+    EXPECT_EQ(loaded->metric_type, index.metric_type);
+    EXPECT_EQ(loaded->num_threads, index.num_threads);
+
+    delete loaded;
 }
diff --git a/tests/test_svs.py b/tests/test_svs.py
index a9ff6cad5..9b20bbafb 100644
--- a/tests/test_svs.py
+++ b/tests/test_svs.py
@@ -14,6 +14,10 @@ class TestSVSAdapter(unittest.TestCase):
 
     target_class = faiss.IndexSVS
 
+    def _create_instance(self) -> faiss.IndexSVS | faiss.IndexSVSFlat:
+        """Create an instance of the SVS index"""
+        return faiss.IndexSVS(self.d)
+
     def setUp(self):
         self.d = 32
         self.nb = 1000
@@ -25,18 +29,19 @@ class TestSVSAdapter(unittest.TestCase):
     def test_svs_construction(self):
         """Test construction and basic properties"""
         # Test default construction
-        index = self.target_class(self.d)
+        index = self._create_instance()
         self.assertEqual(index.d, self.d)
         self.assertTrue(index.is_trained)
         self.assertEqual(index.ntotal, 0)
         self.assertEqual(index.metric_type, faiss.METRIC_L2)
 
-        index_ip = self.target_class(self.d, faiss.METRIC_INNER_PRODUCT)
+        index_ip = self._create_instance()
+        index_ip.metric_type = faiss.METRIC_INNER_PRODUCT
         self.assertEqual(index_ip.metric_type, faiss.METRIC_INNER_PRODUCT)
 
     def test_svs_add_search_interface(self):
         """Test FAISS add/search interface compatibility"""
-        index = self.target_class(self.d)
+        index = self._create_instance()
 
         # Test add interface
         index.add(self.xb)
@@ -57,11 +62,14 @@ class TestSVSAdapter(unittest.TestCase):
     def test_svs_metric_types(self):
         """Test different metric types are handled correctly"""
         # L2 metric
-        index_l2 = self.target_class(self.d, faiss.METRIC_L2)
+        index_l2 = self._create_instance()
+        index_l2.metric_type = faiss.METRIC_L2
         index_l2.add(self.xb)
         D_l2, _ = index_l2.search(self.xq[:10], 4)
 
-        index_ip = self.target_class(self.d, faiss.METRIC_INNER_PRODUCT)
+        index_ip = self._create_instance()
+        index_ip.metric_type = faiss.METRIC_INNER_PRODUCT
+        index_ip.alpha = 0.95
         index_ip.add(self.xb)
         D_ip, _ = index_ip.search(self.xq[:10], 4)
 
@@ -70,7 +78,7 @@ class TestSVSAdapter(unittest.TestCase):
 
     def test_svs_serialization(self):
         """Test FAISS serialization system works with SVS indices"""
-        index = self.target_class(self.d)
+        index = self._create_instance()
 
         index.num_threads = 2
 
@@ -95,7 +103,7 @@ class TestSVSAdapter(unittest.TestCase):
 
     def test_svs_error_handling(self):
         """Test that FAISS error handling works with SVS indices"""
-        index = self.target_class(self.d)
+        index = self._create_instance()
 
         # Test search before adding data
         with self.assertRaises(RuntimeError):
@@ -109,7 +117,7 @@ class TestSVSAdapter(unittest.TestCase):
     def test_svs_fourcc_handling(self):
         """Test that FAISS I/O system handles SVS fourccs correctly"""
         # Create and populate index
-        index = self.target_class(self.d)
+        index = self._create_instance()
         index.add(self.xb[:100])  # Smaller dataset for speed
 
         # Test round-trip serialization preserves exact type
@@ -117,12 +125,12 @@ class TestSVSAdapter(unittest.TestCase):
             faiss.write_index(index, f.name)
             loaded = faiss.read_index(f.name)
 
-            # Verify exact type preservation (fourcc working correctly)
-            self.assertEqual(type(loaded), self.target_class)
+        # Verify exact type preservation (fourcc working correctly)
+        self.assertEqual(type(loaded), self.target_class)
 
     def test_svs_batch_operations(self):
         """Test that batch operations work correctly through adapter"""
-        index = self.target_class(self.d)
+        index = self._create_instance()
 
         # Add in multiple batches
         batch_size = 250
@@ -137,24 +145,64 @@ class TestSVSAdapter(unittest.TestCase):
         self.assertEqual(D.shape, (self.nq, 4))
 
 
+class TestSVSAdapterLVQ4x0(TestSVSAdapter):
+    """Repeat all tests for SVSLVQ4x0 variant"""
+
+    target_class = faiss.IndexSVSLVQ
+
+    def _create_instance(self):
+        idx = faiss.IndexSVSLVQ(self.d)
+        idx.lvq_level = faiss.LVQ_4x0
+        return idx
+
 class TestSVSAdapterLVQ4x4(TestSVSAdapter):
     """Repeat all tests for SVSLVQ4x4 variant"""
-    target_class = faiss.IndexSVSLVQ4x4
+
+    target_class = faiss.IndexSVSLVQ
+
+    def _create_instance(self):
+        idx = faiss.IndexSVSLVQ(self.d)
+        idx.lvq_level = faiss.LVQ_4x4
+        return idx
 
 class TestSVSAdapterLVQ4x8(TestSVSAdapter):
     """Repeat all tests for SVSLVQ4x8 variant"""
-    target_class = faiss.IndexSVSLVQ4x8
+    target_class = faiss.IndexSVSLVQ
+
+    def _create_instance(self):
+        idx = faiss.IndexSVSLVQ(self.d)
+        idx.lvq_level = faiss.LVQ_4x8
+        return idx
 
 class TestSVSAdapterFlat(TestSVSAdapter):
     """Repeat all tests for SVSFlat variant"""
     target_class = faiss.IndexSVSFlat
 
+    def _create_instance(self):
+        return faiss.IndexSVSFlat(self.d)
+
+    @unittest.expectedFailure
+    def test_svs_batch_operations(self):
+        # TODO
+        # This test is expected to fail for IndexSVSFlat as it doesn't support batch operations yet
+        super().test_svs_batch_operations()
+
+    @unittest.expectedFailure
+    def test_svs_serialization(self):
+        # TODO
+        # This test is expected to fail for IndexSVSFlat as it doesn't support serialization yet
+        super().test_svs_batch_operations()
+
 
 class TestSVSVamanaParameters(unittest.TestCase):
     """Test Vamana-specific parameter forwarding and persistence for SVS Vamana variants"""
 
     target_class = faiss.IndexSVS
 
+    def _create_instance(self):
+        """Create an instance of the SVS Vamana index"""
+        return faiss.IndexSVS(self.d)
+
     def setUp(self):
         self.d = 32
         self.nb = 500  # Smaller dataset for parameter tests
@@ -165,7 +213,7 @@ class TestSVSVamanaParameters(unittest.TestCase):
 
     def test_vamana_parameter_setting(self):
         """Test that all Vamana parameters can be set and retrieved"""
-        index = self.target_class(self.d)
+        index = self._create_instance()
 
         # Set non-default values for all parameters
         index.num_threads = 4
@@ -191,7 +239,7 @@ class TestSVSVamanaParameters(unittest.TestCase):
 
     def test_vamana_parameter_defaults(self):
         """Test that Vamana parameters have correct default values"""
-        index = self.target_class(self.d)
+        index = self._create_instance()
 
         # Verify default values match C++ header
         self.assertEqual(index.num_threads, 1)
@@ -206,7 +254,7 @@ class TestSVSVamanaParameters(unittest.TestCase):
 
     def test_vamana_parameter_serialization(self):
         """Test that all Vamana parameters are preserved through serialization"""
-        index = self.target_class(self.d)
+        index = self._create_instance()
 
         # Set distinctive non-default values
         index.num_threads = 8
@@ -246,14 +294,35 @@ class TestSVSVamanaParameters(unittest.TestCase):
         np.testing.assert_allclose(D_before, D_after, rtol=1e-6)
 
 
+class TestSVSVamanaParametersLVQ4x0(TestSVSVamanaParameters):
+    """Repeat Vamana parameter tests for SVSLVQ4x0 variant"""
+
+    target_class = faiss.IndexSVSLVQ
+
+    def _create_instance(self):
+        idx = faiss.IndexSVSLVQ(self.d)
+        idx.lvq_level = faiss.LVQ_4x0
+        return idx
+
 class TestSVSVamanaParametersLVQ4x4(TestSVSVamanaParameters):
     """Repeat Vamana parameter tests for SVSLVQ4x4 variant"""
-    target_class = faiss.IndexSVSLVQ4x4
 
+    target_class = faiss.IndexSVSLVQ
+
+    def _create_instance(self):
+        idx = faiss.IndexSVSLVQ(self.d)
+        idx.lvq_level = faiss.LVQ_4x4
+        return idx
 
 class TestSVSVamanaParametersLVQ4x8(TestSVSVamanaParameters):
     """Repeat Vamana parameter tests for SVSLVQ4x8 variant"""
-    target_class = faiss.IndexSVSLVQ4x8
+
+    target_class = faiss.IndexSVSLVQ
+
+    def _create_instance(self):
+        idx = faiss.IndexSVSLVQ(self.d)
+        idx.lvq_level = faiss.LVQ_4x8
+        return idx
 
 if __name__ == '__main__':
     unittest.main()
-- 
2.39.5 (Apple Git-154)


From 4f36df5b148fdbf99334f1220029aee229f11bb1 Mon Sep 17 00:00:00 2001
From: Aaron Lin <aaron.dl.lin@intel.com>
Date: Thu, 31 Jul 2025 17:47:26 -0700
Subject: [PATCH 19/38] enable SVS LeanVec

---
 faiss/CMakeLists.txt           |  6 +++---
 faiss/IndexSVSLeanVec.cpp      | 30 ++++++++++++++++--------------
 faiss/IndexSVSLeanVec.h        |  7 +++----
 faiss/python/swigfaiss.swig    |  3 +++
 tutorial/cpp/12-SVSLeanVec.cpp |  1 +
 tutorial/python/10-SVS.py      |  2 ++
 6 files changed, 28 insertions(+), 21 deletions(-)

diff --git a/faiss/CMakeLists.txt b/faiss/CMakeLists.txt
index 09eeb1b8e..9e665a704 100644
--- a/faiss/CMakeLists.txt
+++ b/faiss/CMakeLists.txt
@@ -50,7 +50,7 @@ set(FAISS_SRC
   IndexSVS.cpp
   IndexSVSLVQ.cpp
   IndexSVSFlat.cpp
-  #IndexSVSLeanVec.cpp
+  IndexSVSLeanVec.cpp
   IndexNeuralNetCodec.cpp
   MatrixStats.cpp
   MetaIndexes.cpp
@@ -151,7 +151,7 @@ set(FAISS_HEADERS
   IndexShardsIVF.h
   IndexSVS.h
   IndexSVSLVQ.h
-  #IndexSVSLeanVec.h
+  IndexSVSLeanVec.h
   MatrixStats.h
   MetaIndexes.h
   MetricType.h
@@ -328,7 +328,7 @@ endif()
 
 # Experimental SVS cmake build
 include(FetchContent)
-set(SVS_URL "https://github.com/intel/ScalableVectorSearch/releases/download/v0.0.8-dev/svs-shared-library-0.0.8-NIGHTLY-20250630.tar.gz")
+set(SVS_URL "https://github.com/intel/ScalableVectorSearch/releases/download/v0.0.8-dev/svs-shared-library-0.0.8-20250731.tar.gz")
 FetchContent_Declare(
     svs
     URL "${SVS_URL}"
diff --git a/faiss/IndexSVSLeanVec.cpp b/faiss/IndexSVSLeanVec.cpp
index fc82ee67d..e6647b3a7 100644
--- a/faiss/IndexSVSLeanVec.cpp
+++ b/faiss/IndexSVSLeanVec.cpp
@@ -23,10 +23,12 @@ IndexSVSLeanVec::IndexSVSLeanVec(
 }
 
 void IndexSVSLeanVec::train(idx_t n, const float* x) {
-    auto data = svs::data::ConstSimpleDataView<float>(x, n, d);
-    auto means = utils::compute_medioid(data, num_threads);
-    leanvec_matrix = compute_leanvec_matrix<svs::Dynamic, svs::Dynamic>(
-            data, means, num_threads, leanvec_d);
+    const auto data =
+            svs::data::SimpleDataView<float>(const_cast<float*>(x), n, d);
+    auto threadpool = svs::threads::as_threadpool(num_threads);
+    auto means = svs::utils::compute_medioid(data, threadpool);
+    auto matrix = svs::leanvec::compute_leanvec_matrix<svs::Dynamic, svs::Dynamic>(data, means, threadpool, svs::lib::MaybeStatic<svs::Dynamic>{leanvec_d});
+    leanvec_matrix = svs::leanvec::LeanVecMatrices<svs::Dynamic>(matrix, matrix);
     is_trained = true;
 }
 
@@ -50,35 +52,35 @@ void IndexSVSLeanVec::init_impl(idx_t n, const float* x) {
             compressed_data;
 
     switch (leanvec_level) {
-        case LeanVecLevel::Level4x4:
+        case LeanVecLevel::LeanVec_4x4:
             compressed_data = storage_type_4x4::reduce(
                     data,
                     leanvec_matrix,
                     threadpool,
                     0,
-                    leanvec_d,
+                    svs::lib::MaybeStatic<svs::Dynamic>(leanvec_d),
                     blocked_alloc_type{});
             break;
-        case LeanVecLevel::Level4x8:
+        case LeanVecLevel::LeanVec_4x8:
             compressed_data = storage_type_4x8::reduce(
                     data,
                     leanvec_matrix,
                     threadpool,
                     0,
-                    leanvec_d,
+                    svs::lib::MaybeStatic<svs::Dynamic>(leanvec_d),
                     blocked_alloc_type{});
             break;
-        case LeanVecLevel::Level8x8:
+        case LeanVecLevel::LeanVec_8x8:
             compressed_data = storage_type_8x8::reduce(
                     data,
                     leanvec_matrix,
                     threadpool,
                     0,
-                    leanvec_d,
+                    svs::lib::MaybeStatic<svs::Dynamic>(leanvec_d),
                     blocked_alloc_type{});
             break;
         default:
-            FAISS_ASSERT(!"not supported SVS LVQ level");
+            FAISS_ASSERT(!"not supported SVS LeanVec level");
     }
 
     svs::threads::parallel_for(
@@ -104,11 +106,11 @@ void IndexSVSLeanVec::init_impl(idx_t n, const float* x) {
                 if constexpr (std::is_same_v<
                                       std::decay_t<decltype(storage)>,
                                       std::monostate>) {
-                    FAISS_ASSERT(!"SVS LVQ data is not initialized.");
+                    FAISS_ASSERT(!"SVS LeanVec data is not initialized.");
                 } else {
                     switch (metric_type) {
                         case METRIC_INNER_PRODUCT:
-                            impl = std::make_unique<svs::DynamicVamana>(
+                            impl = new svs::DynamicVamana(
                                     svs::DynamicVamana::build<float>(
                                             std::move(build_parameters),
                                             std::forward<decltype(storage)>(
@@ -118,7 +120,7 @@ void IndexSVSLeanVec::init_impl(idx_t n, const float* x) {
                                             std::move(threadpool)));
                             break;
                         case METRIC_L2:
-                            impl = std::make_unique<svs::DynamicVamana>(
+                            impl = new svs::DynamicVamana(
                                     svs::DynamicVamana::build<float>(
                                             std::move(build_parameters),
                                             std::forward<decltype(storage)>(
diff --git a/faiss/IndexSVSLeanVec.h b/faiss/IndexSVSLeanVec.h
index f59e5f7b5..93efa95b8 100644
--- a/faiss/IndexSVSLeanVec.h
+++ b/faiss/IndexSVSLeanVec.h
@@ -13,10 +13,9 @@
 
 namespace faiss {
 
-enum class LeanVecLevel { Level4x4, Level4x8, Level8x8 };
+enum LeanVecLevel { LeanVec_4x4, LeanVec_4x8, LeanVec_8x8 };
 
 struct IndexSVSLeanVec : IndexSVS {
-    using leanvec_matrix_type = svs::data::SimpleData<float>;
     using blocked_alloc_type =
             svs::data::Blocked<svs::lib::Allocator<std::byte>>;
     using storage_type_4x4 = svs::leanvec::LeanDataset<
@@ -44,7 +43,7 @@ struct IndexSVSLeanVec : IndexSVS {
             idx_t d,
             MetricType metric = METRIC_L2,
             size_t leanvec_dims = 0,
-            LeanVecLevel leanvec_level = LeanVecLevel::Level4x4);
+            LeanVecLevel leanvec_level = LeanVecLevel::LeanVec_4x4);
 
     ~IndexSVSLeanVec() override = default;
 
@@ -58,7 +57,7 @@ struct IndexSVSLeanVec : IndexSVS {
 
     LeanVecLevel leanvec_level;
 
-    leanvec_matrix_type* leanvec_matrix;
+    svs::leanvec::LeanVecMatrices<svs::Dynamic> leanvec_matrix;
 };
 
 } // namespace faiss
diff --git a/faiss/python/swigfaiss.swig b/faiss/python/swigfaiss.swig
index 309478b84..d28603ab1 100644
--- a/faiss/python/swigfaiss.swig
+++ b/faiss/python/swigfaiss.swig
@@ -197,6 +197,7 @@ typedef uint64_t size_t;
 #include <faiss/IndexSVS.h>
 #include <faiss/IndexSVSFlat.h>
 #include <faiss/IndexSVSLVQ.h>
+#include <faiss/IndexSVSLeanVec.h>
 
 %}
 
@@ -687,6 +688,7 @@ struct faiss::simd16uint16 {};
 %include  <faiss/IndexSVS.h>
 %include  <faiss/IndexSVSFlat.h>
 %include  <faiss/IndexSVSLVQ.h>
+%include  <faiss/IndexSVSLeanVec.h>
 
 #ifdef GPU_WRAPPER
 
@@ -835,6 +837,7 @@ struct faiss::simd16uint16 {};
     DOWNCAST ( IndexRowwiseMinMax )
     DOWNCAST ( IndexRowwiseMinMaxFP16 )
     DOWNCAST ( IndexSVSFlat )
+    DOWNCAST ( IndexSVSLeanVec )
     DOWNCAST ( IndexSVSLVQ )
     DOWNCAST ( IndexSVS )
 #ifdef GPU_WRAPPER
diff --git a/tutorial/cpp/12-SVSLeanVec.cpp b/tutorial/cpp/12-SVSLeanVec.cpp
index d3cc68f76..1072fb655 100644
--- a/tutorial/cpp/12-SVSLeanVec.cpp
+++ b/tutorial/cpp/12-SVSLeanVec.cpp
@@ -40,6 +40,7 @@ int main() {
     int k = 4;
 
     faiss::IndexSVSLeanVec index(d);
+    index.train(nb, xb);
     index.add(nb, xb);
 
     { // search xq
diff --git a/tutorial/python/10-SVS.py b/tutorial/python/10-SVS.py
index 53b76fb99..67aa6542e 100644
--- a/tutorial/python/10-SVS.py
+++ b/tutorial/python/10-SVS.py
@@ -48,3 +48,5 @@ print(f"{k} nearest neighbors of the 5 last query vectors (after reloading)")
 print(I[-5:])                  # neighbors of the 5 last queries
 
 idx = faiss.IndexSVSLVQ(d, faiss.METRIC_L2, faiss.LVQ_4x8) # example of using SVS LVQ
+
+idx_2 = faiss.IndexSVSLeanVec(d, faiss.METRIC_L2, 0, faiss.LeanVec_4x4) # example of using SVS LeanVec
-- 
2.39.5 (Apple Git-154)


From 8f16863039038c9454c4e90189d0f16d776e0fde Mon Sep 17 00:00:00 2001
From: Andreas Huber <andreas.huber@intel.com>
Date: Fri, 1 Aug 2025 04:25:58 -0700
Subject: [PATCH 20/38] I/O support for LeanVec

---
 faiss/IndexSVSLeanVec.cpp  | 78 +++++++++++++++++++++++++++++++++++++-
 faiss/IndexSVSLeanVec.h    |  2 +
 faiss/impl/index_read.cpp  | 10 ++++-
 faiss/impl/index_write.cpp |  8 ++++
 tests/test_svs.cpp         | 26 +++++++++++++
 5 files changed, 121 insertions(+), 3 deletions(-)

diff --git a/faiss/IndexSVSLeanVec.cpp b/faiss/IndexSVSLeanVec.cpp
index e6647b3a7..6664beab0 100644
--- a/faiss/IndexSVSLeanVec.cpp
+++ b/faiss/IndexSVSLeanVec.cpp
@@ -7,6 +7,7 @@
 
 #include <faiss/IndexSVSLeanVec.h>
 #include <variant>
+#include "faiss/impl/FaissAssert.h"
 #include "svs/core/medioid.h"
 #include "svs/orchestrators/dynamic_vamana.h"
 
@@ -27,8 +28,14 @@ void IndexSVSLeanVec::train(idx_t n, const float* x) {
             svs::data::SimpleDataView<float>(const_cast<float*>(x), n, d);
     auto threadpool = svs::threads::as_threadpool(num_threads);
     auto means = svs::utils::compute_medioid(data, threadpool);
-    auto matrix = svs::leanvec::compute_leanvec_matrix<svs::Dynamic, svs::Dynamic>(data, means, threadpool, svs::lib::MaybeStatic<svs::Dynamic>{leanvec_d});
-    leanvec_matrix = svs::leanvec::LeanVecMatrices<svs::Dynamic>(matrix, matrix);
+    auto matrix =
+            svs::leanvec::compute_leanvec_matrix<svs::Dynamic, svs::Dynamic>(
+                    data,
+                    means,
+                    threadpool,
+                    svs::lib::MaybeStatic<svs::Dynamic>{leanvec_d});
+    leanvec_matrix =
+            svs::leanvec::LeanVecMatrices<svs::Dynamic>(matrix, matrix);
     is_trained = true;
 }
 
@@ -38,6 +45,10 @@ void IndexSVSLeanVec::reset() {
 }
 
 void IndexSVSLeanVec::init_impl(idx_t n, const float* x) {
+    FAISS_THROW_IF_NOT_MSG(
+            is_trained,
+            "Cannot initialize SVS LeanVec index without training first.");
+
     // TODO: support ConstSimpleDataView in SVS shared/static lib
     const auto data =
             svs::data::SimpleDataView<float>(const_cast<float*>(x), n, d);
@@ -137,4 +148,67 @@ void IndexSVSLeanVec::init_impl(idx_t n, const float* x) {
             compressed_data);
 }
 
+void IndexSVSLeanVec::deserialize_impl(std::istream& in) {
+    FAISS_THROW_IF_MSG(
+            impl, "Cannot deserialize: SVS index already initialized.");
+
+    // Write stream to files that can be read by DynamicVamana::assemble()
+    detail::SVSTempDirectory tmp;
+    tmp.write_stream_to_files(in);
+
+    std::variant<svs::DistanceIP, svs::DistanceL2> svs_distance;
+    switch (metric_type) {
+        case METRIC_INNER_PRODUCT:
+            svs_distance = svs::DistanceIP();
+            break;
+        case METRIC_L2:
+            svs_distance = svs::DistanceL2();
+            break;
+        default:
+            FAISS_ASSERT(!"not supported SVS distance");
+    }
+
+    std::visit(
+            [&](auto&& svs_distance) {
+                switch (leanvec_level) {
+                    case LeanVecLevel::LeanVec_4x4:
+                        impl = new svs::DynamicVamana(
+                                svs::DynamicVamana::assemble<float>(
+                                        tmp.config.string(),
+                                        svs::GraphLoader(tmp.graph.string()),
+                                        svs::lib::load_from_disk<
+                                                storage_type_4x4>(
+                                                tmp.data.string()),
+                                        svs_distance,
+                                        num_threads));
+                        break;
+                    case LeanVecLevel::LeanVec_4x8:
+                        impl = new svs::DynamicVamana(
+                                svs::DynamicVamana::assemble<float>(
+                                        tmp.config.string(),
+                                        svs::GraphLoader(tmp.graph.string()),
+                                        svs::lib::load_from_disk<
+                                                storage_type_4x8>(
+                                                tmp.data.string()),
+                                        svs_distance,
+                                        num_threads));
+                        break;
+                    case LeanVecLevel::LeanVec_8x8:
+                        impl = new svs::DynamicVamana(
+                                svs::DynamicVamana::assemble<float>(
+                                        tmp.config.string(),
+                                        svs::GraphLoader(tmp.graph.string()),
+                                        svs::lib::load_from_disk<
+                                                storage_type_8x8>(
+                                                tmp.data.string()),
+                                        svs_distance,
+                                        num_threads));
+                        break;
+                    default:
+                        FAISS_ASSERT(!"not supported SVS LVQ level");
+                }
+            },
+            svs_distance);
+}
+
 } // namespace faiss
diff --git a/faiss/IndexSVSLeanVec.h b/faiss/IndexSVSLeanVec.h
index 93efa95b8..b216a13f9 100644
--- a/faiss/IndexSVSLeanVec.h
+++ b/faiss/IndexSVSLeanVec.h
@@ -58,6 +58,8 @@ struct IndexSVSLeanVec : IndexSVS {
     LeanVecLevel leanvec_level;
 
     svs::leanvec::LeanVecMatrices<svs::Dynamic> leanvec_matrix;
+
+    void deserialize_impl(std::istream& in) override;
 };
 
 } // namespace faiss
diff --git a/faiss/impl/index_read.cpp b/faiss/impl/index_read.cpp
index cc29dce10..b41e97960 100644
--- a/faiss/impl/index_read.cpp
+++ b/faiss/impl/index_read.cpp
@@ -48,6 +48,7 @@
 #include <faiss/IndexSVS.h>
 #include <faiss/IndexSVSFlat.h>
 #include <faiss/IndexSVSLVQ.h>
+#include <faiss/IndexSVSLeanVec.h>
 #include <faiss/IndexScalarQuantizer.h>
 #include <faiss/MetaIndexes.h>
 #include <faiss/VectorTransform.h>
@@ -1245,10 +1246,13 @@ Index* read_index(IOReader* f, int io_flags) {
         READ1(ivrq->qb);
         read_InvertedLists(ivrq, f, io_flags);
         idx = ivrq;
-    } else if (h == fourcc("ILVQ") || h == fourcc("ISVD")) {
+    } else if (
+            h == fourcc("ILVQ") || h == fourcc("ISVL") || h == fourcc("ISVD")) {
         IndexSVS* svs;
         if (h == fourcc("ILVQ")) {
             svs = new IndexSVSLVQ(); // LVQ
+        } else if (h == fourcc("ISVL")) {
+            svs = new IndexSVSLeanVec(); // LeanVec
         } else if (h == fourcc("ISVD")) {
             svs = new IndexSVS(); // uncompressed
         }
@@ -1266,6 +1270,10 @@ Index* read_index(IOReader* f, int io_flags) {
         if (h == fourcc("ILVQ")) {
             READ1(dynamic_cast<IndexSVSLVQ*>(svs)->lvq_level);
         }
+        if (h == fourcc("ISVL")) {
+            READ1(dynamic_cast<IndexSVSLeanVec*>(svs)->leanvec_d);
+            READ1(dynamic_cast<IndexSVSLeanVec*>(svs)->leanvec_level);
+        }
 
         // Read the binary blob from which impl will be reconstructed
         uint64_t blob_size;
diff --git a/faiss/impl/index_write.cpp b/faiss/impl/index_write.cpp
index ad4ee4eb5..66ae63b9b 100644
--- a/faiss/impl/index_write.cpp
+++ b/faiss/impl/index_write.cpp
@@ -46,6 +46,7 @@
 #include <faiss/IndexSVS.h>
 #include <faiss/IndexSVSFlat.h>
 #include <faiss/IndexSVSLVQ.h>
+#include <faiss/IndexSVSLeanVec.h>
 #include <faiss/IndexScalarQuantizer.h>
 #include <faiss/MetaIndexes.h>
 #include <faiss/VectorTransform.h>
@@ -888,9 +889,12 @@ void write_index(const Index* idx, IOWriter* f, int io_flags) {
         uint32_t h;
 
         auto* lvq = dynamic_cast<const IndexSVSLVQ*>(idx);
+        auto* lean = dynamic_cast<const IndexSVSLeanVec*>(idx);
 
         if (lvq != nullptr) {
             h = fourcc("ILVQ"); // LVQ
+        } else if (lean != nullptr) {
+            h = fourcc("ISVL"); // LeanVec
         } else {
             h = fourcc("ISVD"); // uncompressed
         }
@@ -908,6 +912,10 @@ void write_index(const Index* idx, IOWriter* f, int io_flags) {
         if (lvq != nullptr) {
             WRITE1(lvq->lvq_level);
         }
+        if (lean != nullptr) {
+            WRITE1(lean->leanvec_d);
+            WRITE1(lean->leanvec_level);
+        }
 
         std::stringstream ss;
         svs->serialize_impl(ss);
diff --git a/tests/test_svs.cpp b/tests/test_svs.cpp
index 398e66139..f6d627dad 100644
--- a/tests/test_svs.cpp
+++ b/tests/test_svs.cpp
@@ -9,6 +9,7 @@
 #include <faiss/IndexSVS.h>
 #include <faiss/IndexSVSFlat.h>
 #include <faiss/IndexSVSLVQ.h>
+#include <faiss/IndexSVSLeanVec.h>
 #include <faiss/index_io.h>
 #include <gtest/gtest.h>
 #include <type_traits>
@@ -45,6 +46,7 @@ std::vector<float> SVSIOTest::test_data;
 
 template <typename T>
 void write_and_read_index(T& index, const std::vector<float>& xb, size_t n) {
+    index.train(n, xb.data());
     index.add(n, xb.data());
 
     std::string temp_filename_template = "/tmp/faiss_svs_test_XXXXXX";
@@ -104,6 +106,30 @@ TEST_F(SVSIOTest, WriteAndReadIndexSVSLVQ4x8) {
     write_and_read_index(index, test_data, n);
 }
 
+TEST_F(SVSIOTest, WriteAndReadIndexSVSLeanVec4x4) {
+    faiss::IndexSVSLeanVec index{
+            d, faiss::METRIC_L2, 0, faiss::LeanVecLevel::LeanVec_4x4};
+    write_and_read_index(index, test_data, n);
+}
+
+TEST_F(SVSIOTest, WriteAndReadIndexSVSLeanVec4x8) {
+    faiss::IndexSVSLeanVec index{
+            d, faiss::METRIC_L2, 0, faiss::LeanVecLevel::LeanVec_4x8};
+    write_and_read_index(index, test_data, n);
+}
+
+TEST_F(SVSIOTest, WriteAndReadIndexSVSLeanVec8x8) {
+    faiss::IndexSVSLeanVec index{
+            d, faiss::METRIC_L2, 0, faiss::LeanVecLevel::LeanVec_8x8};
+    write_and_read_index(index, test_data, n);
+}
+
+TEST_F(SVSIOTest, LeanVecThrowsWithoutTraining) {
+    faiss::IndexSVSLeanVec index{
+            64, faiss::METRIC_L2, 0, faiss::LeanVecLevel::LeanVec_4x4};
+    ASSERT_THROW(index.add(100, test_data.data()), faiss::FaissException);
+}
+
 TEST_F(SVSIOTest, WriteAndReadIndexSVSFlat) {
     faiss::IndexSVSFlat index{d};
     index.add(n, test_data.data());
-- 
2.39.5 (Apple Git-154)


From 034320b97e182853741a8a4cbd78ef8bbeeba626 Mon Sep 17 00:00:00 2001
From: Aaron Lin <aaron.dl.lin@intel.com>
Date: Thu, 7 Aug 2025 10:14:08 -0700
Subject: [PATCH 21/38] support SVS index factory

---
 faiss/IndexSVSLeanVec.cpp |  2 +-
 faiss/index_factory.cpp   | 86 +++++++++++++++++++++++++++++++++++++++
 tutorial/python/10-SVS.py | 12 +++++-
 3 files changed, 97 insertions(+), 3 deletions(-)

diff --git a/faiss/IndexSVSLeanVec.cpp b/faiss/IndexSVSLeanVec.cpp
index 6664beab0..3e3b95eb3 100644
--- a/faiss/IndexSVSLeanVec.cpp
+++ b/faiss/IndexSVSLeanVec.cpp
@@ -19,7 +19,7 @@ IndexSVSLeanVec::IndexSVSLeanVec(
         size_t leanvec_dims,
         LeanVecLevel leanvec_level)
         : IndexSVS(d, metric), leanvec_level{leanvec_level} {
-    leanvec_d = leanvec_dims == 0 ? d / 2 : leanvec_d;
+    leanvec_d = leanvec_dims == 0 ? d / 2 : leanvec_dims;
     is_trained = false;
 }
 
diff --git a/faiss/index_factory.cpp b/faiss/index_factory.cpp
index baf7a760f..cbd1c803b 100644
--- a/faiss/index_factory.cpp
+++ b/faiss/index_factory.cpp
@@ -49,6 +49,10 @@
 #include <faiss/IndexBinaryHNSW.h>
 #include <faiss/IndexBinaryHash.h>
 #include <faiss/IndexBinaryIVF.h>
+
+#include <faiss/IndexSVS.h>
+#include <faiss/IndexSVSLVQ.h>
+#include <faiss/IndexSVSLeanVec.h>
 #include <string>
 
 namespace faiss {
@@ -537,6 +541,69 @@ IndexNSG* parse_IndexNSG(
     return nullptr;
 }
 
+/***************************************************************
+ * Parse IndexSVS
+ */
+
+LVQLevel parse_lvq(
+      const std::string lvq_string) {
+    if(lvq_string == "LVQ_4x0") {
+        return LVQLevel::LVQ_4x0;
+    }
+    if(lvq_string == "LVQ_4x4") {
+        return LVQLevel::LVQ_4x4;
+    }
+    if(lvq_string == "LVQ_4x8") {
+        return LVQLevel::LVQ_4x8;
+    }
+    FAISS_ASSERT(!"not supported SVS LVQ level");
+}
+
+LeanVecLevel parse_leanvec(
+      const std::string leanvec_string) {
+    if(leanvec_string == "LeanVec_4x4") {
+        return LeanVecLevel::LeanVec_4x4;
+    }
+    if(leanvec_string == "LeanVec_4x8") {
+        return LeanVecLevel::LeanVec_4x8;
+    }
+    if(leanvec_string == "LeanVec_8x8") {
+        return LeanVecLevel::LeanVec_8x8;
+    }
+    FAISS_ASSERT(!"not supported SVS Leanvec level");
+}
+
+
+IndexSVS* parse_IndexSVS(
+        const std::string code_string,
+        int d,
+        MetricType mt) {
+    if(code_string.empty()) {
+        IndexSVS* svs = new IndexSVS(d, mt);
+        return svs;
+    }
+    std::smatch sm;
+    auto match = [&sm, &code_string](const std::string& pattern) {
+        return re_match(code_string, pattern, sm);
+    };
+
+    if (match("(LVQ_[0-9]+x[0-9]+)")) {
+        IndexSVSLVQ* slvq = new IndexSVSLVQ(d, mt, parse_lvq(sm[0].str()));
+        return slvq;
+    }
+    if (match("(LeanVec_[0-9]+x[0-9]+)([,]([0-9]+))?")) {
+        // We also accept empty leanvec dimension
+        std::string leanvec_d_string =
+                sm[2].length() > 0 ? sm[2].str().substr(1) : "0";
+
+        int leanvec_d = std::stoul(leanvec_d_string);
+        IndexSVSLeanVec* sleanvec = new IndexSVSLeanVec(d, mt, leanvec_d, parse_leanvec(sm[1].str()));
+        return sleanvec;
+    }
+
+    return nullptr;
+}
+
 /***************************************************************
  * Parse basic indexes
  */
@@ -822,6 +889,25 @@ std::unique_ptr<Index> index_factory_sub(
         return std::unique_ptr<Index>(index);
     }
 
+    if (re_match(description, "SVS([_].*)?", sm)) {
+        // We also accept empty code string
+        std::string code_string =
+                sm[1].length() > 0 ? sm[1].str().substr(1) : "";
+        if (verbose) {
+            printf("parsing SVS string %s code_string=%s",
+                   description.c_str(),
+                   code_string.c_str());
+        }
+
+        IndexSVS* index = parse_IndexSVS(code_string, d, metric);
+        FAISS_THROW_IF_NOT_FMT(
+                index,
+                "could not parse SVS code description %s in %s",
+                code_string.c_str(),
+                description.c_str());
+        return std::unique_ptr<Index>(index);
+    }
+
     // NSG variants (it was unclear in the old version that the separator was a
     // "," so we support both "_" and ",")
     if (re_match(description, "NSG([0-9]*)([,_].*)?", sm)) {
diff --git a/tutorial/python/10-SVS.py b/tutorial/python/10-SVS.py
index 67aa6542e..85c19dd69 100644
--- a/tutorial/python/10-SVS.py
+++ b/tutorial/python/10-SVS.py
@@ -47,6 +47,14 @@ print(I[:5])                   # neighbors of the 5 first queries
 print(f"{k} nearest neighbors of the 5 last query vectors (after reloading)")
 print(I[-5:])                  # neighbors of the 5 last queries
 
-idx = faiss.IndexSVSLVQ(d, faiss.METRIC_L2, faiss.LVQ_4x8) # example of using SVS LVQ
+lvq_idx = faiss.IndexSVSLVQ(d, faiss.METRIC_L2, faiss.LVQ_4x8) # example of using SVS LVQ
+lvq_idx_fac = faiss.index_factory(d, 'SVS_LVQ_4x8', faiss.METRIC_L2) # example of using factory for SVS LVQ
+lvq_idx_fac.add(xb)
+lvq_idx_fac.search(xq, k)
 
-idx_2 = faiss.IndexSVSLeanVec(d, faiss.METRIC_L2, 0, faiss.LeanVec_4x4) # example of using SVS LeanVec
+
+leanvec_idx = faiss.IndexSVSLeanVec(d, faiss.METRIC_L2, 0, faiss.LeanVec_4x4) # example of using SVS LeanVec
+leanvec_idx_fac = faiss.index_factory(d, 'SVS_LeanVec_4x4,32', faiss.METRIC_L2) # example of using factory for SVS LeanVec
+leanvec_idx_fac.train(xb)
+leanvec_idx_fac.add(xb)
+leanvec_idx_fac.search(xq, k)
-- 
2.39.5 (Apple Git-154)


From c7c35778b6fda35e2fd1dccaf5e2492088b07deb Mon Sep 17 00:00:00 2001
From: Aaron Lin <aaron.dl.lin@intel.com>
Date: Fri, 8 Aug 2025 11:18:37 -0700
Subject: [PATCH 22/38] enable clang format

---
 faiss/index_factory.cpp        | 29 ++++++++++++-----------------
 tutorial/cpp/11-SVSLVQ.cpp     |  1 -
 tutorial/cpp/12-SVSLeanVec.cpp |  1 -
 3 files changed, 12 insertions(+), 19 deletions(-)

diff --git a/faiss/index_factory.cpp b/faiss/index_factory.cpp
index cbd1c803b..254891646 100644
--- a/faiss/index_factory.cpp
+++ b/faiss/index_factory.cpp
@@ -545,40 +545,34 @@ IndexNSG* parse_IndexNSG(
  * Parse IndexSVS
  */
 
-LVQLevel parse_lvq(
-      const std::string lvq_string) {
-    if(lvq_string == "LVQ_4x0") {
+LVQLevel parse_lvq(const std::string lvq_string) {
+    if (lvq_string == "LVQ_4x0") {
         return LVQLevel::LVQ_4x0;
     }
-    if(lvq_string == "LVQ_4x4") {
+    if (lvq_string == "LVQ_4x4") {
         return LVQLevel::LVQ_4x4;
     }
-    if(lvq_string == "LVQ_4x8") {
+    if (lvq_string == "LVQ_4x8") {
         return LVQLevel::LVQ_4x8;
     }
     FAISS_ASSERT(!"not supported SVS LVQ level");
 }
 
-LeanVecLevel parse_leanvec(
-      const std::string leanvec_string) {
-    if(leanvec_string == "LeanVec_4x4") {
+LeanVecLevel parse_leanvec(const std::string leanvec_string) {
+    if (leanvec_string == "LeanVec_4x4") {
         return LeanVecLevel::LeanVec_4x4;
     }
-    if(leanvec_string == "LeanVec_4x8") {
+    if (leanvec_string == "LeanVec_4x8") {
         return LeanVecLevel::LeanVec_4x8;
     }
-    if(leanvec_string == "LeanVec_8x8") {
+    if (leanvec_string == "LeanVec_8x8") {
         return LeanVecLevel::LeanVec_8x8;
     }
     FAISS_ASSERT(!"not supported SVS Leanvec level");
 }
 
-
-IndexSVS* parse_IndexSVS(
-        const std::string code_string,
-        int d,
-        MetricType mt) {
-    if(code_string.empty()) {
+IndexSVS* parse_IndexSVS(const std::string code_string, int d, MetricType mt) {
+    if (code_string.empty()) {
         IndexSVS* svs = new IndexSVS(d, mt);
         return svs;
     }
@@ -597,7 +591,8 @@ IndexSVS* parse_IndexSVS(
                 sm[2].length() > 0 ? sm[2].str().substr(1) : "0";
 
         int leanvec_d = std::stoul(leanvec_d_string);
-        IndexSVSLeanVec* sleanvec = new IndexSVSLeanVec(d, mt, leanvec_d, parse_leanvec(sm[1].str()));
+        IndexSVSLeanVec* sleanvec = new IndexSVSLeanVec(
+                d, mt, leanvec_d, parse_leanvec(sm[1].str()));
         return sleanvec;
     }
 
diff --git a/tutorial/cpp/11-SVSLVQ.cpp b/tutorial/cpp/11-SVSLVQ.cpp
index 76e9a23a7..30e03e454 100644
--- a/tutorial/cpp/11-SVSLVQ.cpp
+++ b/tutorial/cpp/11-SVSLVQ.cpp
@@ -71,4 +71,3 @@ int main() {
 
     return 0;
 }
-
diff --git a/tutorial/cpp/12-SVSLeanVec.cpp b/tutorial/cpp/12-SVSLeanVec.cpp
index 1072fb655..3b4f6f0ab 100644
--- a/tutorial/cpp/12-SVSLeanVec.cpp
+++ b/tutorial/cpp/12-SVSLeanVec.cpp
@@ -72,4 +72,3 @@ int main() {
 
     return 0;
 }
-
-- 
2.39.5 (Apple Git-154)


From b2b9819da83916b61219ae2fba7954e09faddaeb Mon Sep 17 00:00:00 2001
From: Andreas Huber <andreas.huber@intel.com>
Date: Mon, 11 Aug 2025 09:01:53 -0700
Subject: [PATCH 23/38] streaming write to disk

---
 faiss/IndexSVS.cpp          | 85 ++++++++++++++++++++++++++-------
 faiss/IndexSVS.h            | 57 ++++++++++++++++++++--
 faiss/IndexSVSLVQ.cpp       |  2 +-
 faiss/IndexSVSLeanVec.cpp   |  2 +-
 faiss/impl/index_write.cpp  | 94 +++++++++++++++++++++++++++----------
 faiss/python/swigfaiss.swig |  5 +-
 6 files changed, 195 insertions(+), 50 deletions(-)

diff --git a/faiss/IndexSVS.cpp b/faiss/IndexSVS.cpp
index f08f93038..e6555d6c7 100644
--- a/faiss/IndexSVS.cpp
+++ b/faiss/IndexSVS.cpp
@@ -8,13 +8,30 @@
 #include "faiss/IndexSVS.h"
 #include "faiss/Index.h"
 #include "faiss/MetricType.h"
+#include "faiss/impl/io.h"
 
 #include "svs/core/data.h"
 #include "svs/orchestrators/dynamic_vamana.h"
 
 namespace faiss {
+namespace svs_io {
+WriterStreambuf::WriterStreambuf(faiss::IOWriter* w_) : w(w_) {}
+
+std::streamsize WriterStreambuf::xsputn(const char* s, std::streamsize n) {
+    size_t k = (*w)(s, 1, (size_t)n);
+    written += k;
+    return (std::streamsize)k;
+}
+
+int WriterStreambuf::overflow(int ch) {
+    if (ch == traits_type::eof())
+        return 0;
+    char c = (char)ch;
+    size_t k = (*w)(&c, 1, 1);
+    written += k;
+    return ch;
+}
 
-namespace detail {
 SVSTempDirectory::SVSTempDirectory() {
     root = std::filesystem::temp_directory_path() /
             ("faiss_svs_" + std::to_string(std::rand()));
@@ -32,6 +49,19 @@ SVSTempDirectory::~SVSTempDirectory() {
     std::filesystem::remove_all(root, ec);
 }
 
+static inline void read_exact(std::istream& in, void* p, size_t n) {
+    char* c = static_cast<char*>(p);
+    size_t got = 0;
+    while (got < n) {
+        in.read(c + got, n - got);
+        std::streamsize r = in.gcount();
+        if (r <= 0) {
+            FAISS_THROW_IF_NOT_MSG(false, "Unexpected EOF while reading");
+        }
+        got += size_t(r);
+    }
+}
+
 void SVSTempDirectory::write_files_to_stream(std::ostream& out) const {
     for (const auto& dir : {config, graph, data}) {
         const std::string dir_name = dir.filename().string();
@@ -63,40 +93,59 @@ void SVSTempDirectory::write_files_to_stream(std::ostream& out) const {
 }
 
 void SVSTempDirectory::write_stream_to_files(std::istream& in) const {
-    while (in && in.peek() != EOF) {
-        uint64_t dir_len, file_len, file_size;
+    constexpr size_t BUFSZ = 1 << 20; // 1 MiB
+    std::vector<char> buf(BUFSZ);
+
+    for (;;) {
+        uint64_t dir_len = 0;
 
+        // Try to read next record. If we’re at clean EOF (no bytes), stop.
         in.read(reinterpret_cast<char*>(&dir_len), sizeof(dir_len));
+        if (!in) {
+            // No bytes read? clean EOF. Partial? error.
+            if (in.eof() && in.gcount() == 0)
+                return;
+            FAISS_THROW_IF_NOT_MSG(false, "Corrupt stream: partial header");
+        }
+
         std::string dir_name(dir_len, '\0');
-        in.read(dir_name.data(), dir_len);
+        read_exact(in, dir_name.data(), dir_len);
 
-        in.read(reinterpret_cast<char*>(&file_len), sizeof(file_len));
+        uint64_t file_len = 0;
+        read_exact(in, &file_len, sizeof(file_len));
         std::string filename(file_len, '\0');
-        in.read(filename.data(), file_len);
+        read_exact(in, filename.data(), file_len);
 
-        in.read(reinterpret_cast<char*>(&file_size), sizeof(file_size));
-        std::vector<char> buffer(file_size);
-        in.read(buffer.data(), file_size);
+        uint64_t file_size = 0;
+        read_exact(in, &file_size, sizeof(file_size));
 
         std::filesystem::path base;
-        if (dir_name == "config") {
+        if (dir_name == "config")
             base = config;
-        } else if (dir_name == "graph") {
+        else if (dir_name == "graph")
             base = graph;
-        } else if (dir_name == "data") {
+        else if (dir_name == "data")
             base = data;
-        } else {
+        else
             FAISS_THROW_IF_NOT_MSG(false, "Unknown SVS subdirectory name");
-        }
 
         std::filesystem::path full_path = base / filename;
         std::ofstream out(full_path, std::ios::binary);
         FAISS_THROW_IF_NOT_MSG(out, "Failed to open temp SVS file for writing");
-        out.write(buffer.data(), buffer.size());
+
+        // Stream body in chunks
+        uint64_t remaining = file_size;
+        while (remaining > 0) {
+            size_t want = size_t(std::min<uint64_t>(remaining, buf.size()));
+            read_exact(in, buf.data(), want);
+            out.write(buf.data(), want);
+            FAISS_THROW_IF_NOT_MSG(out, "Short write to temp SVS file");
+            remaining -= want;
+        }
     }
 }
 
-} // namespace detail
+} // namespace svs_io
 
 IndexSVS::IndexSVS() : Index{} {}
 
@@ -218,7 +267,7 @@ void IndexSVS::serialize_impl(std::ostream& out) const {
             impl, "Cannot serialize: SVS index not initialized.");
 
     // Write index to temporary files and concatenate the contents
-    detail::SVSTempDirectory tmp;
+    svs_io::SVSTempDirectory tmp;
     impl->save(tmp.config, tmp.graph, tmp.data);
     tmp.write_files_to_stream(out);
 }
@@ -228,7 +277,7 @@ void IndexSVS::deserialize_impl(std::istream& in) {
             impl, "Cannot deserialize: SVS index already initialized.");
 
     // Write stream to files that can be read by DynamicVamana::assemble()
-    detail::SVSTempDirectory tmp;
+    svs_io::SVSTempDirectory tmp;
     tmp.write_stream_to_files(in);
 
     switch (metric_type) {
diff --git a/faiss/IndexSVS.h b/faiss/IndexSVS.h
index 302560f8a..7431cbc8c 100644
--- a/faiss/IndexSVS.h
+++ b/faiss/IndexSVS.h
@@ -7,23 +7,70 @@
 
 #pragma once
 
+#include "faiss/Index.h"
+#include "faiss/impl/FaissAssert.h"
+
+#include <cstdint>
 #include <numeric>
 #include <utility>
 #include <vector>
 
 #include <filesystem>
-#include <sstream>
+#include <streambuf>
 
-#include "faiss/Index.h"
-#include "faiss/impl/FaissAssert.h"
+#ifdef _WIN32
+#include <io.h> // _lseeki64, _write
+#else
+#include <unistd.h> // lseek
+#endif
+#include <cstdint>
 
 namespace svs {
 class DynamicVamana;
 }
 
 namespace faiss {
+struct IOWriter;
+}
+
+namespace faiss {
+
+namespace svs_io {
+
+/* helpers to get and seek positions in fd for back-patching blob size */
+static inline bool fd_cur_pos(int fd, uint64_t& pos) {
+#ifdef _WIN32
+    __int64 p = _lseeki64(fd, 0, SEEK_CUR);
+    if (p < 0)
+        return false;
+    pos = (uint64_t)p;
+    return true;
+#else
+    off_t p = ::lseek(fd, 0, SEEK_CUR);
+    if (p < 0)
+        return false;
+    pos = (uint64_t)p;
+    return true;
+#endif
+}
+
+static inline bool fd_seek(int fd, uint64_t pos) {
+#ifdef _WIN32
+    return _lseeki64(fd, (__int64)pos, SEEK_SET) >= 0;
+#else
+    return ::lseek(fd, (off_t)pos, SEEK_SET) >= 0;
+#endif
+}
+
+struct WriterStreambuf : std::streambuf {
+    faiss::IOWriter* w;
+    uint64_t written = 0;
+    explicit WriterStreambuf(faiss::IOWriter* w_);
+    std::streamsize xsputn(const char* s, std::streamsize n) override;
+    int overflow(int ch) override;
+};
 
-namespace detail {
+/* temporary directory for SVS Vamana indices that tries to always clean up */
 struct SVSTempDirectory {
     std::filesystem::path root;
     std::filesystem::path config;
@@ -36,7 +83,7 @@ struct SVSTempDirectory {
     void write_files_to_stream(std::ostream& out) const;
     void write_stream_to_files(std::istream& in) const;
 };
-} // namespace detail
+} // namespace svs_io
 
 struct IndexSVS : Index {
     size_t num_threads = 1;
diff --git a/faiss/IndexSVSLVQ.cpp b/faiss/IndexSVSLVQ.cpp
index 36fcd8968..871e94682 100644
--- a/faiss/IndexSVSLVQ.cpp
+++ b/faiss/IndexSVSLVQ.cpp
@@ -104,7 +104,7 @@ void IndexSVSLVQ::deserialize_impl(std::istream& in) {
             impl, "Cannot deserialize: SVS index already initialized.");
 
     // Write stream to files that can be read by DynamicVamana::assemble()
-    detail::SVSTempDirectory tmp;
+    svs_io::SVSTempDirectory tmp;
     tmp.write_stream_to_files(in);
 
     std::variant<svs::DistanceIP, svs::DistanceL2> svs_distance;
diff --git a/faiss/IndexSVSLeanVec.cpp b/faiss/IndexSVSLeanVec.cpp
index 3e3b95eb3..7321b77d7 100644
--- a/faiss/IndexSVSLeanVec.cpp
+++ b/faiss/IndexSVSLeanVec.cpp
@@ -153,7 +153,7 @@ void IndexSVSLeanVec::deserialize_impl(std::istream& in) {
             impl, "Cannot deserialize: SVS index already initialized.");
 
     // Write stream to files that can be read by DynamicVamana::assemble()
-    detail::SVSTempDirectory tmp;
+    svs_io::SVSTempDirectory tmp;
     tmp.write_stream_to_files(in);
 
     std::variant<svs::DistanceIP, svs::DistanceL2> svs_distance;
diff --git a/faiss/impl/index_write.cpp b/faiss/impl/index_write.cpp
index 66ae63b9b..0fcd6215a 100644
--- a/faiss/impl/index_write.cpp
+++ b/faiss/impl/index_write.cpp
@@ -898,33 +898,79 @@ void write_index(const Index* idx, IOWriter* f, int io_flags) {
         } else {
             h = fourcc("ISVD"); // uncompressed
         }
-        WRITE1(h);
-        write_index_header(idx, f);
-        WRITE1(svs->num_threads);
-        WRITE1(svs->graph_max_degree);
-        WRITE1(svs->alpha);
-        WRITE1(svs->search_window_size);
-        WRITE1(svs->search_buffer_capacity);
-        WRITE1(svs->construction_window_size);
-        WRITE1(svs->max_candidate_pool_size);
-        WRITE1(svs->prune_to);
-        WRITE1(svs->use_full_search_history);
-        if (lvq != nullptr) {
-            WRITE1(lvq->lvq_level);
-        }
-        if (lean != nullptr) {
-            WRITE1(lean->leanvec_d);
-            WRITE1(lean->leanvec_level);
+
+        // The SVS implementation will write its contents to three directories,
+        // which we will read back here for writing to the actual output file.
+        // To avoid a full copy of the index in memory, we stream chunks.
+        // This requires some additional work on the output file and we need
+        // to keep track of some file positions.
+
+        // Helper because we need to write the header twice
+        auto write_header = [&](uint64_t blob_size) {
+            faiss::BufferedIOWriter bwr(f);
+            faiss::IOWriter* f = &bwr; // <-- shadow 'f' so WRITE1 uses bwr
+
+            // type tag + your existing header fields
+            WRITE1(h);
+            write_index_header(idx, f);
+            WRITE1(svs->num_threads);
+            WRITE1(svs->graph_max_degree);
+            WRITE1(svs->alpha);
+            WRITE1(svs->search_window_size);
+            WRITE1(svs->search_buffer_capacity);
+            WRITE1(svs->construction_window_size);
+            WRITE1(svs->max_candidate_pool_size);
+            WRITE1(svs->prune_to);
+            WRITE1(svs->use_full_search_history);
+            if (lvq != nullptr) {
+                WRITE1(lvq->lvq_level);
+            }
+            if (lean != nullptr) {
+                WRITE1(lean->leanvec_d);
+                WRITE1(lean->leanvec_level);
+            }
+
+            WRITE1(blob_size);
+        };
+
+        int fd = f->filedescriptor();
+        uint64_t header_start = 0;
+        FAISS_THROW_IF_NOT_MSG(
+                svs_io::fd_cur_pos(fd, header_start), "lseek failed at start");
+
+        // At this point we don't know the blob size yet, so we write a 0
+        write_header(0);
+
+        // Now we write the blob and keep track how much we advance the file
+        uint64_t payload_start = 0;
+        FAISS_THROW_IF_NOT_MSG(
+                svs_io::fd_cur_pos(fd, payload_start),
+                "lseek after header failed");
+
+        {
+            faiss::BufferedIOWriter bwr(f);
+            svs_io::WriterStreambuf wbuf(&bwr);
+            std::ostream os(&wbuf);
+
+            static_cast<const IndexSVS*>(idx)->serialize_impl(os);
+            os.flush();
         }
 
-        std::stringstream ss;
-        svs->serialize_impl(ss);
-        std::string blob = ss.str();
+        uint64_t payload_end = 0;
+        FAISS_THROW_IF_NOT_MSG(
+                svs_io::fd_cur_pos(fd, payload_end),
+                "lseek after payload failed");
+
+        uint64_t blob_size = payload_end - payload_start;
+        FAISS_THROW_IF_NOT_MSG(
+                svs_io::fd_seek(fd, header_start),
+                "seek to header_start failed");
+
+        // We write the header again, this time with the actual blob size
+        write_header(blob_size);
 
-        // Write blob size and contents
-        uint64_t blob_size = blob.size();
-        WRITE1(blob_size);
-        WRITEANDCHECK(blob.data(), blob_size);
+        // seek back to end of payload
+        svs_io::fd_seek(fd, payload_end);
     } else if (
             const IndexSVSFlat* svs = dynamic_cast<const IndexSVSFlat*>(idx)) {
         uint32_t h = fourcc("ISVF");
diff --git a/faiss/python/swigfaiss.swig b/faiss/python/swigfaiss.swig
index d28603ab1..88642b904 100644
--- a/faiss/python/swigfaiss.swig
+++ b/faiss/python/swigfaiss.swig
@@ -682,9 +682,12 @@ struct faiss::simd16uint16 {};
 %template(IndexIDMap2) faiss::IndexIDMap2Template<faiss::Index>;
 %template(IndexBinaryIDMap2) faiss::IndexIDMap2Template<faiss::IndexBinary>;
 
-
 %include <faiss/utils/approx_topk/mode.h>
 
+/* Hide SVS I/O helpers */
+%ignore faiss::svs_io::WriterStreambuf;
+%ignore faiss::svs_io::SVSTempDirectory;
+
 %include  <faiss/IndexSVS.h>
 %include  <faiss/IndexSVSFlat.h>
 %include  <faiss/IndexSVSLVQ.h>
-- 
2.39.5 (Apple Git-154)


From d31bcb15d138a40ce750ced492bd3cd6543ecdb3 Mon Sep 17 00:00:00 2001
From: Andreas Huber <andreas.huber@intel.com>
Date: Tue, 12 Aug 2025 06:46:49 -0700
Subject: [PATCH 24/38] change how files are streamed

---
 faiss/IndexSVS.cpp          | 288 +++++++++++++++++++-----------------
 faiss/IndexSVS.h            | 105 ++++++-------
 faiss/impl/index_read.cpp   |  11 +-
 faiss/impl/index_write.cpp  | 107 +++++---------
 faiss/python/swigfaiss.swig |   1 +
 5 files changed, 240 insertions(+), 272 deletions(-)

diff --git a/faiss/IndexSVS.cpp b/faiss/IndexSVS.cpp
index e6555d6c7..b91e93cb4 100644
--- a/faiss/IndexSVS.cpp
+++ b/faiss/IndexSVS.cpp
@@ -14,138 +14,6 @@
 #include "svs/orchestrators/dynamic_vamana.h"
 
 namespace faiss {
-namespace svs_io {
-WriterStreambuf::WriterStreambuf(faiss::IOWriter* w_) : w(w_) {}
-
-std::streamsize WriterStreambuf::xsputn(const char* s, std::streamsize n) {
-    size_t k = (*w)(s, 1, (size_t)n);
-    written += k;
-    return (std::streamsize)k;
-}
-
-int WriterStreambuf::overflow(int ch) {
-    if (ch == traits_type::eof())
-        return 0;
-    char c = (char)ch;
-    size_t k = (*w)(&c, 1, 1);
-    written += k;
-    return ch;
-}
-
-SVSTempDirectory::SVSTempDirectory() {
-    root = std::filesystem::temp_directory_path() /
-            ("faiss_svs_" + std::to_string(std::rand()));
-    config = root / "config";
-    graph = root / "graph";
-    data = root / "data";
-
-    std::filesystem::create_directories(config);
-    std::filesystem::create_directories(graph);
-    std::filesystem::create_directories(data);
-}
-
-SVSTempDirectory::~SVSTempDirectory() {
-    std::error_code ec;
-    std::filesystem::remove_all(root, ec);
-}
-
-static inline void read_exact(std::istream& in, void* p, size_t n) {
-    char* c = static_cast<char*>(p);
-    size_t got = 0;
-    while (got < n) {
-        in.read(c + got, n - got);
-        std::streamsize r = in.gcount();
-        if (r <= 0) {
-            FAISS_THROW_IF_NOT_MSG(false, "Unexpected EOF while reading");
-        }
-        got += size_t(r);
-    }
-}
-
-void SVSTempDirectory::write_files_to_stream(std::ostream& out) const {
-    for (const auto& dir : {config, graph, data}) {
-        const std::string dir_name = dir.filename().string();
-        for (const auto& entry : std::filesystem::directory_iterator(dir)) {
-            const std::string filename = entry.path().filename().string();
-
-            const uint64_t dir_len = dir_name.size();
-            const uint64_t file_len = filename.size();
-            const uint64_t file_size = std::filesystem::file_size(entry.path());
-
-            out.write(reinterpret_cast<const char*>(&dir_len), sizeof(dir_len));
-            out.write(dir_name.data(), dir_len);
-
-            out.write(
-                    reinterpret_cast<const char*>(&file_len), sizeof(file_len));
-            out.write(filename.data(), file_len);
-
-            out.write(
-                    reinterpret_cast<const char*>(&file_size),
-                    sizeof(file_size));
-
-            std::ifstream in(entry.path(), std::ios::binary);
-            FAISS_THROW_IF_NOT_MSG(
-                    in, "Failed to open temp SVS file for reading");
-
-            out << in.rdbuf();
-        }
-    }
-}
-
-void SVSTempDirectory::write_stream_to_files(std::istream& in) const {
-    constexpr size_t BUFSZ = 1 << 20; // 1 MiB
-    std::vector<char> buf(BUFSZ);
-
-    for (;;) {
-        uint64_t dir_len = 0;
-
-        // Try to read next record. If we’re at clean EOF (no bytes), stop.
-        in.read(reinterpret_cast<char*>(&dir_len), sizeof(dir_len));
-        if (!in) {
-            // No bytes read? clean EOF. Partial? error.
-            if (in.eof() && in.gcount() == 0)
-                return;
-            FAISS_THROW_IF_NOT_MSG(false, "Corrupt stream: partial header");
-        }
-
-        std::string dir_name(dir_len, '\0');
-        read_exact(in, dir_name.data(), dir_len);
-
-        uint64_t file_len = 0;
-        read_exact(in, &file_len, sizeof(file_len));
-        std::string filename(file_len, '\0');
-        read_exact(in, filename.data(), file_len);
-
-        uint64_t file_size = 0;
-        read_exact(in, &file_size, sizeof(file_size));
-
-        std::filesystem::path base;
-        if (dir_name == "config")
-            base = config;
-        else if (dir_name == "graph")
-            base = graph;
-        else if (dir_name == "data")
-            base = data;
-        else
-            FAISS_THROW_IF_NOT_MSG(false, "Unknown SVS subdirectory name");
-
-        std::filesystem::path full_path = base / filename;
-        std::ofstream out(full_path, std::ios::binary);
-        FAISS_THROW_IF_NOT_MSG(out, "Failed to open temp SVS file for writing");
-
-        // Stream body in chunks
-        uint64_t remaining = file_size;
-        while (remaining > 0) {
-            size_t want = size_t(std::min<uint64_t>(remaining, buf.size()));
-            read_exact(in, buf.data(), want);
-            out.write(buf.data(), want);
-            FAISS_THROW_IF_NOT_MSG(out, "Short write to temp SVS file");
-            remaining -= want;
-        }
-    }
-}
-
-} // namespace svs_io
 
 IndexSVS::IndexSVS() : Index{} {}
 
@@ -302,4 +170,160 @@ void IndexSVS::deserialize_impl(std::istream& in) {
     }
 }
 
+namespace svs_io {
+
+WriterStreambuf::WriterStreambuf(IOWriter* w_) : w(w_) {}
+
+WriterStreambuf::~WriterStreambuf() = default;
+
+std::streamsize WriterStreambuf::xsputn(const char* s, std::streamsize n) {
+    if (n <= 0)
+        return 0;
+    size_t wrote = (*w)(s, 1, static_cast<size_t>(n));
+    return static_cast<std::streamsize>(wrote);
+}
+
+int WriterStreambuf::overflow(int ch) {
+    if (ch == traits_type::eof())
+        return 0;
+    char c = static_cast<char>(ch);
+    size_t wrote = (*w)(&c, 1, 1);
+    return wrote == 1 ? ch : traits_type::eof();
+}
+
+ReaderStreambuf::ReaderStreambuf(IOReader* rr, size_t bsz)
+        : r(rr), buf(std::max<size_t>(bsz, 4096)) {
+    // empty get area initially
+    setg(buf.data(), buf.data(), buf.data());
+}
+
+ReaderStreambuf::~ReaderStreambuf() = default;
+
+std::streambuf::int_type ReaderStreambuf::underflow() {
+    if (gptr() < egptr()) {
+        return traits_type::to_int_type(*gptr());
+    }
+    size_t got = (*r)(buf.data(), 1, buf.size());
+    if (got == 0) {
+        return traits_type::eof(); // upstream EOF
+    }
+    setg(buf.data(), buf.data(), buf.data() + got);
+    return traits_type::to_int_type(*gptr());
+}
+
+SVSTempDirectory::SVSTempDirectory() {
+    root = std::filesystem::temp_directory_path() /
+            ("faiss_svs_" + std::to_string(std::rand()));
+    config = root / "config";
+    graph = root / "graph";
+    data = root / "data";
+
+    std::filesystem::create_directories(config);
+    std::filesystem::create_directories(graph);
+    std::filesystem::create_directories(data);
+}
+
+SVSTempDirectory::~SVSTempDirectory() {
+    std::error_code ec;
+    std::filesystem::remove_all(root, ec);
+}
+
+static inline void read_exact(std::istream& in, void* p, size_t n) {
+    char* c = static_cast<char*>(p);
+    size_t got = 0;
+    while (got < n) {
+        in.read(c + got, n - got);
+        std::streamsize r = in.gcount();
+        if (r <= 0) {
+            FAISS_THROW_IF_NOT_MSG(false, "Unexpected EOF while reading");
+        }
+        got += size_t(r);
+    }
+}
+
+void SVSTempDirectory::write_files_to_stream(std::ostream& out) const {
+    for (const auto& dir : {config, graph, data}) {
+        const std::string dir_name = dir.filename().string();
+        for (const auto& entry : std::filesystem::directory_iterator(dir)) {
+            const std::string filename = entry.path().filename().string();
+
+            const uint64_t dir_len = dir_name.size();
+            const uint64_t file_len = filename.size();
+            const uint64_t file_size = std::filesystem::file_size(entry.path());
+
+            out.write(reinterpret_cast<const char*>(&dir_len), sizeof(dir_len));
+            out.write(dir_name.data(), dir_len);
+
+            out.write(
+                    reinterpret_cast<const char*>(&file_len), sizeof(file_len));
+            out.write(filename.data(), file_len);
+
+            out.write(
+                    reinterpret_cast<const char*>(&file_size),
+                    sizeof(file_size));
+
+            std::ifstream in(entry.path(), std::ios::binary);
+            FAISS_THROW_IF_NOT_MSG(
+                    in, "Failed to open temp SVS file for reading");
+
+            out << in.rdbuf();
+        }
+    }
+}
+
+void SVSTempDirectory::write_stream_to_files(std::istream& in) const {
+    constexpr size_t BUFSZ = 1 << 20; // 1 MiB
+    std::vector<char> buf(BUFSZ);
+
+    for (;;) {
+        uint64_t dir_len = 0;
+
+        // Try to read next record. If we’re at clean EOF (no bytes), stop.
+        in.read(reinterpret_cast<char*>(&dir_len), sizeof(dir_len));
+        if (!in) {
+            // No bytes read? clean EOF. Partial? error.
+            if (in.eof() && in.gcount() == 0)
+                return;
+            FAISS_THROW_IF_NOT_MSG(false, "Corrupt stream: partial header");
+        }
+
+        std::string dir_name(dir_len, '\0');
+        read_exact(in, dir_name.data(), dir_len);
+
+        uint64_t file_len = 0;
+        read_exact(in, &file_len, sizeof(file_len));
+        std::string filename(file_len, '\0');
+        read_exact(in, filename.data(), file_len);
+
+        uint64_t file_size = 0;
+        read_exact(in, &file_size, sizeof(file_size));
+
+        std::filesystem::path base;
+        if (dir_name == "config")
+            base = config;
+        else if (dir_name == "graph")
+            base = graph;
+        else if (dir_name == "data")
+            base = data;
+        else
+            FAISS_THROW_IF_NOT_MSG(false, "Unknown SVS subdirectory name");
+
+        std::filesystem::path full_path = base / filename;
+        std::ofstream out(full_path, std::ios::binary);
+        FAISS_THROW_IF_NOT_MSG(out, "Failed to open temp SVS file for writing");
+
+        // Stream body in chunks
+        uint64_t remaining = file_size;
+        while (remaining > 0) {
+            size_t want = size_t(std::min<uint64_t>(remaining, buf.size()));
+            read_exact(in, buf.data(), want);
+            out.write(buf.data(), want);
+            FAISS_THROW_IF_NOT_MSG(out, "Short write to temp SVS file");
+            remaining -= want;
+        }
+    }
+}
+
+} // namespace svs_io
+
 } // namespace faiss
diff --git a/faiss/IndexSVS.h b/faiss/IndexSVS.h
index 7431cbc8c..33ac24396 100644
--- a/faiss/IndexSVS.h
+++ b/faiss/IndexSVS.h
@@ -8,22 +8,19 @@
 #pragma once
 
 #include "faiss/Index.h"
-#include "faiss/impl/FaissAssert.h"
 
+#include <cstddef>
 #include <cstdint>
+#include <filesystem>
 #include <numeric>
+#include <streambuf>
 #include <utility>
 #include <vector>
 
-#include <filesystem>
-#include <streambuf>
-
-#ifdef _WIN32
-#include <io.h> // _lseeki64, _write
-#else
-#include <unistd.h> // lseek
-#endif
-#include <cstdint>
+namespace faiss {
+struct IOReader;
+struct IOWriter;
+} // namespace faiss
 
 namespace svs {
 class DynamicVamana;
@@ -35,56 +32,6 @@ struct IOWriter;
 
 namespace faiss {
 
-namespace svs_io {
-
-/* helpers to get and seek positions in fd for back-patching blob size */
-static inline bool fd_cur_pos(int fd, uint64_t& pos) {
-#ifdef _WIN32
-    __int64 p = _lseeki64(fd, 0, SEEK_CUR);
-    if (p < 0)
-        return false;
-    pos = (uint64_t)p;
-    return true;
-#else
-    off_t p = ::lseek(fd, 0, SEEK_CUR);
-    if (p < 0)
-        return false;
-    pos = (uint64_t)p;
-    return true;
-#endif
-}
-
-static inline bool fd_seek(int fd, uint64_t pos) {
-#ifdef _WIN32
-    return _lseeki64(fd, (__int64)pos, SEEK_SET) >= 0;
-#else
-    return ::lseek(fd, (off_t)pos, SEEK_SET) >= 0;
-#endif
-}
-
-struct WriterStreambuf : std::streambuf {
-    faiss::IOWriter* w;
-    uint64_t written = 0;
-    explicit WriterStreambuf(faiss::IOWriter* w_);
-    std::streamsize xsputn(const char* s, std::streamsize n) override;
-    int overflow(int ch) override;
-};
-
-/* temporary directory for SVS Vamana indices that tries to always clean up */
-struct SVSTempDirectory {
-    std::filesystem::path root;
-    std::filesystem::path config;
-    std::filesystem::path graph;
-    std::filesystem::path data;
-
-    SVSTempDirectory();
-    ~SVSTempDirectory();
-
-    void write_files_to_stream(std::ostream& out) const;
-    void write_stream_to_files(std::istream& in) const;
-};
-} // namespace svs_io
-
 struct IndexSVS : Index {
     size_t num_threads = 1;
     size_t graph_max_degree = 64;
@@ -125,4 +72,42 @@ struct IndexSVS : Index {
     virtual void init_impl(idx_t n, const float* x);
 };
 
+// We provide some helpers for efficient I/O in the svs_io namespace
+// These can be excluded from the Python bindings
+namespace svs_io {
+// Bridges IOWriter to std::ostream (used for streaming payload out)
+struct WriterStreambuf : std::streambuf {
+    IOWriter* w; // not owning
+    explicit WriterStreambuf(IOWriter* w_);
+    ~WriterStreambuf() override; // out-of-line def in .cpp
+   protected:
+    std::streamsize xsputn(const char* s, std::streamsize n) override;
+    int overflow(int ch) override;
+};
+
+// Bridges IOReader to std::istream (used to read payload to EOF)
+struct ReaderStreambuf : std::streambuf {
+    IOReader* r;           // not owning
+    std::vector<char> buf; // ring buffer (default 1 MiB)
+    explicit ReaderStreambuf(IOReader* rr, size_t bsz = (1u << 20));
+    ~ReaderStreambuf() override; // out-of-line def in .cpp
+   protected:
+    int_type underflow() override;
+};
+
+/* temporary directory for SVS Vamana indices that tries to always clean up */
+struct SVSTempDirectory {
+    std::filesystem::path root;
+    std::filesystem::path config;
+    std::filesystem::path graph;
+    std::filesystem::path data;
+
+    SVSTempDirectory();
+    ~SVSTempDirectory();
+
+    void write_files_to_stream(std::ostream& out) const;
+    void write_stream_to_files(std::istream& in) const;
+};
+} // namespace svs_io
+
 } // namespace faiss
diff --git a/faiss/impl/index_read.cpp b/faiss/impl/index_read.cpp
index b41e97960..8dec34117 100644
--- a/faiss/impl/index_read.cpp
+++ b/faiss/impl/index_read.cpp
@@ -1275,13 +1275,10 @@ Index* read_index(IOReader* f, int io_flags) {
             READ1(dynamic_cast<IndexSVSLeanVec*>(svs)->leanvec_level);
         }
 
-        // Read the binary blob from which impl will be reconstructed
-        uint64_t blob_size;
-        READ1(blob_size);
-        std::string blob(blob_size, '\0');
-        READANDCHECK(blob.data(), blob_size);
-        std::stringstream ss(std::move(blob));
-        svs->deserialize_impl(ss);
+        faiss::BufferedIOReader br(f);
+        faiss::svs_io::ReaderStreambuf rbuf(&br);
+        std::istream is(&rbuf);
+        svs->deserialize_impl(is);
         idx = svs;
     } else if (h == fourcc("ISVS")) {
         // TODO
diff --git a/faiss/impl/index_write.cpp b/faiss/impl/index_write.cpp
index 0fcd6215a..97f162a00 100644
--- a/faiss/impl/index_write.cpp
+++ b/faiss/impl/index_write.cpp
@@ -886,11 +886,18 @@ void write_index(const Index* idx, IOWriter* f, int io_flags) {
         WRITE1(ivrq->qb);
         write_InvertedLists(ivrq->invlists, f);
     } else if (const IndexSVS* svs = dynamic_cast<const IndexSVS*>(idx)) {
-        uint32_t h;
-
-        auto* lvq = dynamic_cast<const IndexSVSLVQ*>(idx);
-        auto* lean = dynamic_cast<const IndexSVSLeanVec*>(idx);
+        // The SVS implementation will write its contents to three directories,
+        // which we will read back here for writing to the actual output file.
+        // To avoid a full copy of the index in memory, we stream chunks.
+        // This means we cannot write the output blob size in the header, as
+        // we only know the number of bytes at the very end.
+        // One solution would be to write a footer and read it in index_read(),
+        // but since the file ends anyway after index_write() is done, we just
+        // assume EOF means end of binary SVS blobl.
 
+        uint32_t h;
+        auto* lvq = dynamic_cast<const IndexSVSLVQ*>(svs);
+        auto* lean = dynamic_cast<const IndexSVSLeanVec*>(svs);
         if (lvq != nullptr) {
             h = fourcc("ILVQ"); // LVQ
         } else if (lean != nullptr) {
@@ -899,78 +906,32 @@ void write_index(const Index* idx, IOWriter* f, int io_flags) {
             h = fourcc("ISVD"); // uncompressed
         }
 
-        // The SVS implementation will write its contents to three directories,
-        // which we will read back here for writing to the actual output file.
-        // To avoid a full copy of the index in memory, we stream chunks.
-        // This requires some additional work on the output file and we need
-        // to keep track of some file positions.
-
-        // Helper because we need to write the header twice
-        auto write_header = [&](uint64_t blob_size) {
-            faiss::BufferedIOWriter bwr(f);
-            faiss::IOWriter* f = &bwr; // <-- shadow 'f' so WRITE1 uses bwr
-
-            // type tag + your existing header fields
-            WRITE1(h);
-            write_index_header(idx, f);
-            WRITE1(svs->num_threads);
-            WRITE1(svs->graph_max_degree);
-            WRITE1(svs->alpha);
-            WRITE1(svs->search_window_size);
-            WRITE1(svs->search_buffer_capacity);
-            WRITE1(svs->construction_window_size);
-            WRITE1(svs->max_candidate_pool_size);
-            WRITE1(svs->prune_to);
-            WRITE1(svs->use_full_search_history);
-            if (lvq != nullptr) {
-                WRITE1(lvq->lvq_level);
-            }
-            if (lean != nullptr) {
-                WRITE1(lean->leanvec_d);
-                WRITE1(lean->leanvec_level);
-            }
-
-            WRITE1(blob_size);
-        };
-
-        int fd = f->filedescriptor();
-        uint64_t header_start = 0;
-        FAISS_THROW_IF_NOT_MSG(
-                svs_io::fd_cur_pos(fd, header_start), "lseek failed at start");
-
-        // At this point we don't know the blob size yet, so we write a 0
-        write_header(0);
-
-        // Now we write the blob and keep track how much we advance the file
-        uint64_t payload_start = 0;
-        FAISS_THROW_IF_NOT_MSG(
-                svs_io::fd_cur_pos(fd, payload_start),
-                "lseek after header failed");
-
-        {
-            faiss::BufferedIOWriter bwr(f);
-            svs_io::WriterStreambuf wbuf(&bwr);
-            std::ostream os(&wbuf);
-
-            static_cast<const IndexSVS*>(idx)->serialize_impl(os);
-            os.flush();
+        WRITE1(h);
+        write_index_header(svs, f);
+        WRITE1(svs->num_threads);
+        WRITE1(svs->graph_max_degree);
+        WRITE1(svs->alpha);
+        WRITE1(svs->search_window_size);
+        WRITE1(svs->search_buffer_capacity);
+        WRITE1(svs->construction_window_size);
+        WRITE1(svs->max_candidate_pool_size);
+        WRITE1(svs->prune_to);
+        WRITE1(svs->use_full_search_history);
+        if (lvq != nullptr) {
+            WRITE1(lvq->lvq_level);
+        }
+        if (lean != nullptr) {
+            WRITE1(lean->leanvec_d);
+            WRITE1(lean->leanvec_level);
         }
 
-        uint64_t payload_end = 0;
-        FAISS_THROW_IF_NOT_MSG(
-                svs_io::fd_cur_pos(fd, payload_end),
-                "lseek after payload failed");
-
-        uint64_t blob_size = payload_end - payload_start;
-        FAISS_THROW_IF_NOT_MSG(
-                svs_io::fd_seek(fd, header_start),
-                "seek to header_start failed");
-
-        // We write the header again, this time with the actual blob size
-        write_header(blob_size);
+        // payload (stream to file)
+        faiss::BufferedIOWriter bwr(f);
+        faiss::svs_io::WriterStreambuf wbuf(&bwr);
+        std::ostream os(&wbuf);
 
-        // seek back to end of payload
-        svs_io::fd_seek(fd, payload_end);
+        static_cast<const IndexSVS*>(idx)->serialize_impl(os);
+        os.flush();
     } else if (
             const IndexSVSFlat* svs = dynamic_cast<const IndexSVSFlat*>(idx)) {
         uint32_t h = fourcc("ISVF");
diff --git a/faiss/python/swigfaiss.swig b/faiss/python/swigfaiss.swig
index 88642b904..88a85e7ea 100644
--- a/faiss/python/swigfaiss.swig
+++ b/faiss/python/swigfaiss.swig
@@ -685,6 +685,7 @@ struct faiss::simd16uint16 {};
 %include <faiss/utils/approx_topk/mode.h>
 
 /* Hide SVS I/O helpers */
+%ignore faiss::svs_io::ReaderStreambuf;
 %ignore faiss::svs_io::WriterStreambuf;
 %ignore faiss::svs_io::SVSTempDirectory;
 
-- 
2.39.5 (Apple Git-154)


From 483193adf60144050bd1a2d3f949b915a112de01 Mon Sep 17 00:00:00 2001
From: Andreas Huber <andreas.huber@intel.com>
Date: Wed, 13 Aug 2025 03:40:49 -0700
Subject: [PATCH 25/38] Update SVS version

---
 faiss/CMakeLists.txt | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/faiss/CMakeLists.txt b/faiss/CMakeLists.txt
index 9e665a704..c5b0593a1 100644
--- a/faiss/CMakeLists.txt
+++ b/faiss/CMakeLists.txt
@@ -328,7 +328,7 @@ endif()
 
 # Experimental SVS cmake build
 include(FetchContent)
-set(SVS_URL "https://github.com/intel/ScalableVectorSearch/releases/download/v0.0.8-dev/svs-shared-library-0.0.8-20250731.tar.gz")
+set(SVS_URL "https://github.com/intel/ScalableVectorSearch/releases/download/v0.0.9/svs-shared-library-0.0.9.tar.gz")
 FetchContent_Declare(
     svs
     URL "${SVS_URL}"
-- 
2.39.5 (Apple Git-154)


From caf1f90a7e89657b8bf56172f4785fb7a18ba3dc Mon Sep 17 00:00:00 2001
From: Andreas Huber <andreas.huber@intel.com>
Date: Wed, 13 Aug 2025 06:28:58 -0700
Subject: [PATCH 26/38] Add FAISS_USE_SVS flag

---
 CMakeLists.txt              |  1 +
 faiss/CMakeLists.txt        | 63 ++++++++++++++++++++++++++-----------
 faiss/index_factory.cpp     |  6 ++++
 faiss/python/swigfaiss.swig |  6 ++++
 4 files changed, 57 insertions(+), 19 deletions(-)

diff --git a/CMakeLists.txt b/CMakeLists.txt
index 4572771a2..d46d382bf 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -68,6 +68,7 @@ option(FAISS_ENABLE_PYTHON "Build Python extension." ON)
 option(FAISS_ENABLE_C_API "Build C API." OFF)
 option(FAISS_ENABLE_EXTRAS "Build extras like benchmarks and demos" ON)
 option(FAISS_USE_LTO "Enable Link-Time optimization" OFF)
+option(FAISS_USE_SVS "Enable SVS (Scalable Vector Search) integration." ON)
 
 if(FAISS_ENABLE_GPU)
   if(FAISS_ENABLE_ROCM)
diff --git a/faiss/CMakeLists.txt b/faiss/CMakeLists.txt
index c5b0593a1..4a5377542 100644
--- a/faiss/CMakeLists.txt
+++ b/faiss/CMakeLists.txt
@@ -47,10 +47,6 @@ set(FAISS_SRC
   IndexScalarQuantizer.cpp
   IndexShards.cpp
   IndexShardsIVF.cpp
-  IndexSVS.cpp
-  IndexSVSLVQ.cpp
-  IndexSVSFlat.cpp
-  IndexSVSLeanVec.cpp
   IndexNeuralNetCodec.cpp
   MatrixStats.cpp
   MetaIndexes.cpp
@@ -104,6 +100,15 @@ set(FAISS_SRC
   utils/distances_fused/simdlib_based.cpp
 )
 
+if(FAISS_USE_SVS)
+  list(APPEND FAISS_SRC
+    IndexSVS.cpp
+    IndexSVSLVQ.cpp
+    IndexSVSFlat.cpp
+    IndexSVSLeanVec.cpp
+  )
+endif()
+
 set(FAISS_HEADERS
   AutoTune.h
   Clustering.h
@@ -149,9 +154,6 @@ set(FAISS_HEADERS
   IndexScalarQuantizer.h
   IndexShards.h
   IndexShardsIVF.h
-  IndexSVS.h
-  IndexSVSLVQ.h
-  IndexSVSLeanVec.h
   MatrixStats.h
   MetaIndexes.h
   MetricType.h
@@ -160,6 +162,7 @@ set(FAISS_HEADERS
   index_factory.h
   index_io.h
   impl/AdditiveQuantizer.h
+  impl/AdditiveQuantizer.h
   impl/AuxIndexStructures.h
   impl/CodePacker.h
   impl/IDSelector.h
@@ -248,6 +251,14 @@ set(FAISS_HEADERS
   utils/hamming_distance/avx512-inl.h
 )
 
+if(FAISS_USE_SVS)
+  list(APPEND FAISS_HEADERS
+    IndexSVS.h
+    IndexSVSLVQ.h
+    IndexSVSLeanVec.h
+  )
+endif()
+
 if(NOT WIN32)
   list(APPEND FAISS_SRC invlists/OnDiskInvertedLists.cpp)
   list(APPEND FAISS_HEADERS invlists/OnDiskInvertedLists.h)
@@ -327,24 +338,30 @@ if(NOT WIN32)
 endif()
 
 # Experimental SVS cmake build
-include(FetchContent)
-set(SVS_URL "https://github.com/intel/ScalableVectorSearch/releases/download/v0.0.9/svs-shared-library-0.0.9.tar.gz")
-FetchContent_Declare(
-    svs
-    URL "${SVS_URL}"
-)
-FetchContent_MakeAvailable(svs)
-list(APPEND CMAKE_PREFIX_PATH "${svs_SOURCE_DIR}")
-find_package(svs REQUIRED)
+if(FAISS_USE_SVS)
+  include(FetchContent)
+  set(SVS_URL "https://github.com/intel/ScalableVectorSearch/releases/download/v0.0.9/svs-shared-library-0.0.9.tar.gz")
+  FetchContent_Declare(
+      svs
+      URL "${SVS_URL}"
+  )
+  FetchContent_MakeAvailable(svs)
+  list(APPEND CMAKE_PREFIX_PATH "${svs_SOURCE_DIR}")
+  find_package(svs REQUIRED)
 
-target_link_libraries(faiss PUBLIC svs::svs svs::svs_shared_library)
+  target_link_libraries(faiss PUBLIC svs::svs svs::svs_shared_library)
+endif()
 
 # Handle `#include <faiss/foo.h>`.
-# Handle `#include <svs/foo.h>`.
 target_include_directories(faiss PUBLIC
-  $<BUILD_INTERFACE:${svs_SOURCE_DIR}/include>
   $<BUILD_INTERFACE:${PROJECT_SOURCE_DIR}>
 )
+if(FAISS_USE_SVS)
+  # Handle `#include <svs/foo.h>`.
+  target_include_directories(faiss PUBLIC
+    $<BUILD_INTERFACE:${svs_SOURCE_DIR}/include>
+  )
+endif()
 # Handle `#include <faiss/foo.h>`.
 target_include_directories(faiss_avx2 PUBLIC
   $<BUILD_INTERFACE:${PROJECT_SOURCE_DIR}>)
@@ -371,6 +388,14 @@ if(WIN32)
   target_compile_definitions(faiss_sve PRIVATE FAISS_MAIN_LIB)
 endif()
 
+if(FAISS_USE_SVS)
+  target_compile_definitions(faiss PRIVATE FAISS_USE_SVS)
+  target_compile_definitions(faiss_avx2 PRIVATE FAISS_USE_SVS)
+  target_compile_definitions(faiss_avx512 PRIVATE FAISS_USE_SVS)
+  target_compile_definitions(faiss_avx512_spr PRIVATE FAISS_USE_SVS)
+  target_compile_definitions(faiss_sve PRIVATE FAISS_USE_SVS)
+endif()
+
 if(WIN32)
   set_target_properties(faiss PROPERTIES LINK_FLAGS "-Wl,--export-all-symbols")
 endif()
diff --git a/faiss/index_factory.cpp b/faiss/index_factory.cpp
index 254891646..60f358802 100644
--- a/faiss/index_factory.cpp
+++ b/faiss/index_factory.cpp
@@ -50,9 +50,11 @@
 #include <faiss/IndexBinaryHash.h>
 #include <faiss/IndexBinaryIVF.h>
 
+#ifdef FAISS_USE_SVS
 #include <faiss/IndexSVS.h>
 #include <faiss/IndexSVSLVQ.h>
 #include <faiss/IndexSVSLeanVec.h>
+#endif
 #include <string>
 
 namespace faiss {
@@ -541,6 +543,7 @@ IndexNSG* parse_IndexNSG(
     return nullptr;
 }
 
+#ifdef FAISS_USE_SVS
 /***************************************************************
  * Parse IndexSVS
  */
@@ -598,6 +601,7 @@ IndexSVS* parse_IndexSVS(const std::string code_string, int d, MetricType mt) {
 
     return nullptr;
 }
+#endif // FAISS_USE_SVS
 
 /***************************************************************
  * Parse basic indexes
@@ -884,6 +888,7 @@ std::unique_ptr<Index> index_factory_sub(
         return std::unique_ptr<Index>(index);
     }
 
+#ifdef FAISS_USE_SVS
     if (re_match(description, "SVS([_].*)?", sm)) {
         // We also accept empty code string
         std::string code_string =
@@ -902,6 +907,7 @@ std::unique_ptr<Index> index_factory_sub(
                 description.c_str());
         return std::unique_ptr<Index>(index);
     }
+#endif // FAISS_USE_SVS
 
     // NSG variants (it was unclear in the old version that the separator was a
     // "," so we support both "_" and ",")
diff --git a/faiss/python/swigfaiss.swig b/faiss/python/swigfaiss.swig
index 88a85e7ea..38beb1284 100644
--- a/faiss/python/swigfaiss.swig
+++ b/faiss/python/swigfaiss.swig
@@ -194,10 +194,12 @@ typedef uint64_t size_t;
 #include <faiss/IndexRaBitQ.h>
 #include <faiss/IndexIVFRaBitQ.h>
 
+#ifdef FAISS_USE_SVS
 #include <faiss/IndexSVS.h>
 #include <faiss/IndexSVSFlat.h>
 #include <faiss/IndexSVSLVQ.h>
 #include <faiss/IndexSVSLeanVec.h>
+#endif
 
 %}
 
@@ -684,6 +686,7 @@ struct faiss::simd16uint16 {};
 
 %include <faiss/utils/approx_topk/mode.h>
 
+#ifdef FAISS_USE_SVS
 /* Hide SVS I/O helpers */
 %ignore faiss::svs_io::ReaderStreambuf;
 %ignore faiss::svs_io::WriterStreambuf;
@@ -693,6 +696,7 @@ struct faiss::simd16uint16 {};
 %include  <faiss/IndexSVSFlat.h>
 %include  <faiss/IndexSVSLVQ.h>
 %include  <faiss/IndexSVSLeanVec.h>
+#endif // FAISS_USE_SVS
 
 #ifdef GPU_WRAPPER
 
@@ -840,10 +844,12 @@ struct faiss::simd16uint16 {};
     DOWNCAST ( IndexRandom )
     DOWNCAST ( IndexRowwiseMinMax )
     DOWNCAST ( IndexRowwiseMinMaxFP16 )
+#ifdef FAISS_USE_SVS
     DOWNCAST ( IndexSVSFlat )
     DOWNCAST ( IndexSVSLeanVec )
     DOWNCAST ( IndexSVSLVQ )
     DOWNCAST ( IndexSVS )
+#endif // FAISS_USE_SVS
 #ifdef GPU_WRAPPER
 #ifdef FAISS_ENABLE_CUVS
     DOWNCAST_GPU ( GpuIndexCagra )
-- 
2.39.5 (Apple Git-154)


From 38ef8019cd2211cb5cfc69676a744ad50e85a8dd Mon Sep 17 00:00:00 2001
From: Andreas Huber <andreas.huber@intel.com>
Date: Wed, 13 Aug 2025 06:39:18 -0700
Subject: [PATCH 27/38] fixup

---
 faiss/CMakeLists.txt       |  3 ++-
 faiss/impl/index_read.cpp  | 10 ++++++++--
 faiss/impl/index_write.cpp | 10 ++++++++--
 3 files changed, 18 insertions(+), 5 deletions(-)

diff --git a/faiss/CMakeLists.txt b/faiss/CMakeLists.txt
index 4a5377542..5ddcc1a5f 100644
--- a/faiss/CMakeLists.txt
+++ b/faiss/CMakeLists.txt
@@ -102,9 +102,9 @@ set(FAISS_SRC
 
 if(FAISS_USE_SVS)
   list(APPEND FAISS_SRC
+    IndexSVSFlat.cpp
     IndexSVS.cpp
     IndexSVSLVQ.cpp
-    IndexSVSFlat.cpp
     IndexSVSLeanVec.cpp
   )
 endif()
@@ -253,6 +253,7 @@ set(FAISS_HEADERS
 
 if(FAISS_USE_SVS)
   list(APPEND FAISS_HEADERS
+    IndexSVSFlat.h
     IndexSVS.h
     IndexSVSLVQ.h
     IndexSVSLeanVec.h
diff --git a/faiss/impl/index_read.cpp b/faiss/impl/index_read.cpp
index 8dec34117..d2fd82e80 100644
--- a/faiss/impl/index_read.cpp
+++ b/faiss/impl/index_read.cpp
@@ -45,10 +45,12 @@
 #include <faiss/IndexRaBitQ.h>
 #include <faiss/IndexRefine.h>
 #include <faiss/IndexRowwiseMinMax.h>
+#ifdef FAISS_USE_SVS
 #include <faiss/IndexSVS.h>
 #include <faiss/IndexSVSFlat.h>
 #include <faiss/IndexSVSLVQ.h>
 #include <faiss/IndexSVSLeanVec.h>
+#endif
 #include <faiss/IndexScalarQuantizer.h>
 #include <faiss/MetaIndexes.h>
 #include <faiss/VectorTransform.h>
@@ -1246,7 +1248,9 @@ Index* read_index(IOReader* f, int io_flags) {
         READ1(ivrq->qb);
         read_InvertedLists(ivrq, f, io_flags);
         idx = ivrq;
-    } else if (
+    }
+#ifdef FAISS_USE_SVS
+    else if (
             h == fourcc("ILVQ") || h == fourcc("ISVL") || h == fourcc("ISVD")) {
         IndexSVS* svs;
         if (h == fourcc("ILVQ")) {
@@ -1289,7 +1293,9 @@ Index* read_index(IOReader* f, int io_flags) {
         read_index_header(svs, f);
         READ1(svs->num_threads);
         idx = svs;
-    } else {
+    }
+#endif // FAISS_USE_SVS
+    else {
         FAISS_THROW_FMT(
                 "Index type 0x%08x (\"%s\") not recognized",
                 h,
diff --git a/faiss/impl/index_write.cpp b/faiss/impl/index_write.cpp
index 97f162a00..e39a9c26e 100644
--- a/faiss/impl/index_write.cpp
+++ b/faiss/impl/index_write.cpp
@@ -43,10 +43,12 @@
 #include <faiss/IndexRaBitQ.h>
 #include <faiss/IndexRefine.h>
 #include <faiss/IndexRowwiseMinMax.h>
+#ifdef FAISS_USE_SVS
 #include <faiss/IndexSVS.h>
 #include <faiss/IndexSVSFlat.h>
 #include <faiss/IndexSVSLVQ.h>
 #include <faiss/IndexSVSLeanVec.h>
+#endif
 #include <faiss/IndexScalarQuantizer.h>
 #include <faiss/MetaIndexes.h>
 #include <faiss/VectorTransform.h>
@@ -885,7 +887,9 @@ void write_index(const Index* idx, IOWriter* f, int io_flags) {
         WRITE1(ivrq->by_residual);
         WRITE1(ivrq->qb);
         write_InvertedLists(ivrq->invlists, f);
-    } else if (const IndexSVS* svs = dynamic_cast<const IndexSVS*>(idx)) {
+    }
+#ifdef FAISS_USE_SVS
+    else if (const IndexSVS* svs = dynamic_cast<const IndexSVS*>(idx)) {
         // The SVS implementation will write its contents to three directories,
         // which we will read back here for writing to the actual output file.
         // To avoid a full copy of the index in memory, we stream chunks.
@@ -938,7 +942,9 @@ void write_index(const Index* idx, IOWriter* f, int io_flags) {
         WRITE1(h);
         write_index_header(idx, f);
         WRITE1(svs->num_threads);
-    } else {
+    }
+#endif // FAISS_USE_SVS
+    else {
         FAISS_THROW_MSG("don't know how to serialize this type of index");
     }
 }
-- 
2.39.5 (Apple Git-154)


From 42b22085f45de760a76403102c5ca71beb7ad03d Mon Sep 17 00:00:00 2001
From: Andreas Huber <andreas.huber@intel.com>
Date: Wed, 13 Aug 2025 08:50:23 -0700
Subject: [PATCH 28/38] fix FAISS_USE_SVS

---
 CMakeLists.txt                  |  2 +-
 faiss/CMakeLists.txt            | 17 +++++++----------
 faiss/python/CMakeLists.txt     | 14 ++++++++++++++
 faiss/python/__init__.py        |  4 +++-
 faiss/python/swigfaiss.swig     |  1 +
 faiss/utils/utils.cpp           |  4 ++++
 tests/CMakeLists.txt            |  5 ++++-
 tutorial/cpp/11-tmp-svscomp.cpp |  0
 tutorial/cpp/CMakeLists.txt     | 18 ++++++++++--------
 9 files changed, 44 insertions(+), 21 deletions(-)
 create mode 100644 tutorial/cpp/11-tmp-svscomp.cpp

diff --git a/CMakeLists.txt b/CMakeLists.txt
index d46d382bf..b88b457de 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -68,7 +68,7 @@ option(FAISS_ENABLE_PYTHON "Build Python extension." ON)
 option(FAISS_ENABLE_C_API "Build C API." OFF)
 option(FAISS_ENABLE_EXTRAS "Build extras like benchmarks and demos" ON)
 option(FAISS_USE_LTO "Enable Link-Time optimization" OFF)
-option(FAISS_USE_SVS "Enable SVS (Scalable Vector Search) integration." ON)
+option(FAISS_USE_SVS "Enable SVS (Intel(R) Scalable Vector Search) integration." ON)
 
 if(FAISS_ENABLE_GPU)
   if(FAISS_ENABLE_ROCM)
diff --git a/faiss/CMakeLists.txt b/faiss/CMakeLists.txt
index 5ddcc1a5f..c38e2f8dd 100644
--- a/faiss/CMakeLists.txt
+++ b/faiss/CMakeLists.txt
@@ -162,7 +162,6 @@ set(FAISS_HEADERS
   index_factory.h
   index_io.h
   impl/AdditiveQuantizer.h
-  impl/AdditiveQuantizer.h
   impl/AuxIndexStructures.h
   impl/CodePacker.h
   impl/IDSelector.h
@@ -269,6 +268,7 @@ endif()
 set(FAISS_HEADERS ${FAISS_HEADERS} PARENT_SCOPE)
 
 add_library(faiss ${FAISS_SRC})
+
 add_library(faiss_avx2 ${FAISS_SRC})
 if(NOT FAISS_OPT_LEVEL STREQUAL "avx2" AND NOT FAISS_OPT_LEVEL STREQUAL "avx512" AND NOT FAISS_OPT_LEVEL STREQUAL "avx512_spr")
   set_target_properties(faiss_avx2 PROPERTIES EXCLUDE_FROM_ALL TRUE)
@@ -338,7 +338,6 @@ if(NOT WIN32)
   endif()
 endif()
 
-# Experimental SVS cmake build
 if(FAISS_USE_SVS)
   include(FetchContent)
   set(SVS_URL "https://github.com/intel/ScalableVectorSearch/releases/download/v0.0.9/svs-shared-library-0.0.9.tar.gz")
@@ -355,14 +354,7 @@ endif()
 
 # Handle `#include <faiss/foo.h>`.
 target_include_directories(faiss PUBLIC
-  $<BUILD_INTERFACE:${PROJECT_SOURCE_DIR}>
-)
-if(FAISS_USE_SVS)
-  # Handle `#include <svs/foo.h>`.
-  target_include_directories(faiss PUBLIC
-    $<BUILD_INTERFACE:${svs_SOURCE_DIR}/include>
-  )
-endif()
+  $<BUILD_INTERFACE:${PROJECT_SOURCE_DIR}>)
 # Handle `#include <faiss/foo.h>`.
 target_include_directories(faiss_avx2 PUBLIC
   $<BUILD_INTERFACE:${PROJECT_SOURCE_DIR}>)
@@ -375,6 +367,11 @@ target_include_directories(faiss_avx512_spr PUBLIC
 # Handle `#include <faiss/foo.h>`.
 target_include_directories(faiss_sve PUBLIC
   $<BUILD_INTERFACE:${PROJECT_SOURCE_DIR}>)
+if(FAISS_USE_SVS)
+  # Handle `#include <svs/foo.h>`.
+  target_include_directories(faiss PUBLIC
+    $<BUILD_INTERFACE:${svs_SOURCE_DIR}/include>)
+endif()
 
 set_target_properties(faiss faiss_avx2 faiss_avx512 faiss_avx512_spr faiss_sve PROPERTIES
   POSITION_INDEPENDENT_CODE ON
diff --git a/faiss/python/CMakeLists.txt b/faiss/python/CMakeLists.txt
index c1bbf088c..7aeb6e1f5 100644
--- a/faiss/python/CMakeLists.txt
+++ b/faiss/python/CMakeLists.txt
@@ -33,6 +33,11 @@ macro(configure_swigfaiss source)
       SWIG_FLAGS -DSWIGWIN
     )
   endif()
+  if(FAISS_USE_SVS)
+    set_property(SOURCE ${source} APPEND PROPERTY
+      SWIG_FLAGS -DFAISS_USE_SVS
+    )
+  endif()
   if(FAISS_ENABLE_GPU)
     set_source_files_properties(${source} PROPERTIES
       COMPILE_DEFINITIONS GPU_WRAPPER
@@ -205,6 +210,15 @@ else()
   target_compile_options(faiss_example_external_module PRIVATE /bigobj)
 endif()
 
+if(FAISS_USE_SVS)
+  target_compile_definitions(swigfaiss PRIVATE FAISS_USE_SVS)
+  target_compile_definitions(swigfaiss_avx2 PRIVATE FAISS_USE_SVS)
+  target_compile_definitions(swigfaiss_avx512 PRIVATE FAISS_USE_SVS)
+  target_compile_definitions(swigfaiss_avx512_spr PRIVATE FAISS_USE_SVS)
+  target_compile_definitions(swigfaiss_sve PRIVATE FAISS_USE_SVS)
+  target_compile_definitions(faiss_example_external_module PRIVATE FAISS_USE_SVS)
+endif()
+
 if(FAISS_ENABLE_GPU)
   if(FAISS_ENABLE_ROCM)
     target_link_libraries(swigfaiss PRIVATE hip::host)
diff --git a/faiss/python/__init__.py b/faiss/python/__init__.py
index 3b62a1cb6..5413a66b6 100644
--- a/faiss/python/__init__.py
+++ b/faiss/python/__init__.py
@@ -218,7 +218,9 @@ add_ref_in_constructor(IDSelectorTranslated, slice(2))
 add_ref_in_constructor(IDSelectorXOr, slice(2))
 add_ref_in_constructor(IndexIVFIndependentQuantizer, slice(3))
 
-add_ref_in_constructor(IndexSVS, 0)
+if "SVS" in get_compile_options():
+    add_ref_in_constructor(IndexSVS, 0)
+    add_ref_in_constructor(IndexSVSFlat, 0)
 
 # seems really marginal...
 # remove_ref_from_method(IndexReplicas, 'removeIndex', 0)
diff --git a/faiss/python/swigfaiss.swig b/faiss/python/swigfaiss.swig
index 38beb1284..f0c45fed3 100644
--- a/faiss/python/swigfaiss.swig
+++ b/faiss/python/swigfaiss.swig
@@ -684,6 +684,7 @@ struct faiss::simd16uint16 {};
 %template(IndexIDMap2) faiss::IndexIDMap2Template<faiss::Index>;
 %template(IndexBinaryIDMap2) faiss::IndexIDMap2Template<faiss::IndexBinary>;
 
+
 %include <faiss/utils/approx_topk/mode.h>
 
 #ifdef FAISS_USE_SVS
diff --git a/faiss/utils/utils.cpp b/faiss/utils/utils.cpp
index 2f2d6f4b6..44764de03 100644
--- a/faiss/utils/utils.cpp
+++ b/faiss/utils/utils.cpp
@@ -124,6 +124,10 @@ std::string get_compile_options() {
     options += "GENERIC ";
 #endif
 
+#ifdef FAISS_USE_SVS
+    options += "SVS ";
+#endif
+
     options += gpu_compile_options;
 
     return options;
diff --git a/tests/CMakeLists.txt b/tests/CMakeLists.txt
index 3c37c7e64..a6f868b05 100644
--- a/tests/CMakeLists.txt
+++ b/tests/CMakeLists.txt
@@ -38,9 +38,12 @@ set(FAISS_TEST_SRC
   test_hamming.cpp
   test_mmap.cpp
   test_zerocopy.cpp
-  test_svs.cpp  # TODO: should be guarded by FAISS_ENABLE_SVS
 )
 
+if(FAISS_USE_SVS)
+  list(APPEND FAISS_TEST_SRC test_svs.cpp)
+endif()
+
 add_executable(faiss_test ${FAISS_TEST_SRC})
 
 include(../cmake/link_to_faiss_lib.cmake)
diff --git a/tutorial/cpp/11-tmp-svscomp.cpp b/tutorial/cpp/11-tmp-svscomp.cpp
new file mode 100644
index 000000000..e69de29bb
diff --git a/tutorial/cpp/CMakeLists.txt b/tutorial/cpp/CMakeLists.txt
index 4fa5a9ae0..a37e542d0 100644
--- a/tutorial/cpp/CMakeLists.txt
+++ b/tutorial/cpp/CMakeLists.txt
@@ -30,14 +30,16 @@ target_link_libraries(8-PQFastScanRefine PRIVATE faiss)
 add_executable(9-RefineComparison EXCLUDE_FROM_ALL 9-RefineComparison.cpp)
 target_link_libraries(9-RefineComparison PRIVATE faiss)
 
-add_executable(10-SVS EXCLUDE_FROM_ALL 10-SVS.cpp)
-target_link_libraries(10-SVS PRIVATE faiss)
+if(FAISS_USE_SVS)
+  add_executable(10-SVS EXCLUDE_FROM_ALL 10-SVS.cpp)
+  target_link_libraries(10-SVS PRIVATE faiss)
 
-add_executable(11-SVSLVQ EXCLUDE_FROM_ALL 11-SVSLVQ.cpp)
-target_link_libraries(11-SVSLVQ PRIVATE faiss)
+  add_executable(11-SVSLVQ EXCLUDE_FROM_ALL 11-SVSLVQ.cpp)
+  target_link_libraries(11-SVSLVQ PRIVATE faiss)
 
-add_executable(12-SVSLeanVec EXCLUDE_FROM_ALL 12-SVSLeanVec.cpp)
-target_link_libraries(12-SVSLeanVec PRIVATE faiss)
+  add_executable(12-SVSLeanVec EXCLUDE_FROM_ALL 12-SVSLeanVec.cpp)
+  target_link_libraries(12-SVSLeanVec PRIVATE faiss)
 
-add_executable(13-tmp-svscomp EXCLUDE_FROM_ALL 13-tmp-svscomp.cpp)
-target_link_libraries(13-tmp-svscomp PRIVATE faiss)
+  add_executable(13-tmp-svscomp EXCLUDE_FROM_ALL 13-tmp-svscomp.cpp)
+  target_link_libraries(13-tmp-svscomp PRIVATE faiss)
+endif()
-- 
2.39.5 (Apple Git-154)


From 6873aa3c5a1ba7c5417a47d4a0708a1036a9807b Mon Sep 17 00:00:00 2001
From: Andreas Huber <andreas.huber@intel.com>
Date: Wed, 13 Aug 2025 08:50:48 -0700
Subject: [PATCH 29/38] add LeanVec load test

---
 tests/test_svs.cpp | 5 +++++
 1 file changed, 5 insertions(+)

diff --git a/tests/test_svs.cpp b/tests/test_svs.cpp
index f6d627dad..ae02b7504 100644
--- a/tests/test_svs.cpp
+++ b/tests/test_svs.cpp
@@ -79,6 +79,11 @@ void write_and_read_index(T& index, const std::vector<float>& xb, size_t n) {
         ASSERT_NE(lvq_loaded, nullptr);
         EXPECT_EQ(lvq_loaded->lvq_level, index.lvq_level);
     }
+    if constexpr (std::is_same_v<std::decay_t<T>, faiss::IndexSVSLeanVec>) {
+        auto* lvq_loaded = dynamic_cast<faiss::IndexSVSLeanVec*>(loaded);
+        ASSERT_NE(lvq_loaded, nullptr);
+        EXPECT_EQ(lvq_loaded->leanvec_level, index.leanvec_level);
+    }
 
     delete loaded;
 }
-- 
2.39.5 (Apple Git-154)


From b51ce17d98ce282ccc259a397e2312da2fc8b127 Mon Sep 17 00:00:00 2001
From: Andreas Huber <andreas.huber@intel.com>
Date: Thu, 14 Aug 2025 02:36:06 -0700
Subject: [PATCH 30/38] add I/O to IndexSVSFlat

---
 faiss/IndexSVSFlat.cpp     | 39 ++++++++++++++++++++++++++++++++++++++
 faiss/IndexSVSFlat.h       |  6 ++++++
 faiss/impl/index_read.cpp  |  8 +++++---
 faiss/impl/index_write.cpp | 10 +++++++++-
 tests/test_svs.cpp         |  3 +++
 tests/test_svs.py          |  5 -----
 6 files changed, 62 insertions(+), 9 deletions(-)

diff --git a/faiss/IndexSVSFlat.cpp b/faiss/IndexSVSFlat.cpp
index e3bba65db..20b56c602 100644
--- a/faiss/IndexSVSFlat.cpp
+++ b/faiss/IndexSVSFlat.cpp
@@ -6,6 +6,7 @@
  */
 
 #include <faiss/Index.h>
+#include <faiss/IndexSVS.h>
 #include <faiss/IndexSVSFlat.h>
 
 #include <faiss/impl/FaissAssert.h>
@@ -95,4 +96,42 @@ void IndexSVSFlat::init_impl(idx_t n, const float* x) {
     }
 }
 
+void IndexSVSFlat::serialize_impl(std::ostream& out) const {
+    FAISS_THROW_IF_NOT_MSG(
+            impl, "Cannot serialize: SVS index not initialized.");
+
+    // Write index to temporary files and concatenate the contents
+    svs_io::SVSTempDirectory tmp;
+    impl->save(tmp.data);
+    tmp.write_files_to_stream(out);
+}
+
+void IndexSVSFlat::deserialize_impl(std::istream& in) {
+    FAISS_THROW_IF_MSG(
+            impl, "Cannot deserialize: SVS index already initialized.");
+
+    // Write stream to files that can be read by Flat::assemble()
+    svs_io::SVSTempDirectory tmp;
+    tmp.write_stream_to_files(in);
+
+    auto threadpool = svs::threads::as_threadpool(num_threads);
+
+    switch (metric_type) {
+        case METRIC_INNER_PRODUCT:
+            impl = new svs::Flat(svs::Flat::assemble<float>(
+                    svs::VectorDataLoader<float>(tmp.data.string()),
+                    svs::DistanceIP(),
+                    std::move(threadpool)));
+            break;
+        case METRIC_L2:
+            impl = new svs::Flat(svs::Flat::assemble<float>(
+                    svs::VectorDataLoader<float>(tmp.data.string()),
+                    svs::DistanceL2(),
+                    std::move(threadpool)));
+            break;
+        default:
+            FAISS_ASSERT(!"not supported SVS distance");
+    }
+}
+
 } // namespace faiss
diff --git a/faiss/IndexSVSFlat.h b/faiss/IndexSVSFlat.h
index 00ec4f864..b61cf9175 100644
--- a/faiss/IndexSVSFlat.h
+++ b/faiss/IndexSVSFlat.h
@@ -7,6 +7,8 @@
 
 #pragma once
 
+#include <filesystem>
+#include <iostream>
 #include <memory>
 #include <numeric>
 #include <variant>
@@ -49,6 +51,10 @@ struct IndexSVSFlat : Index {
 
     /* Initializes the implementation, using the provided data */
     virtual void init_impl(idx_t n, const float* x);
+
+    /* Serialization */
+    void serialize_impl(std::ostream& out) const;
+    void deserialize_impl(std::istream& in);
 };
 
 } // namespace faiss
diff --git a/faiss/impl/index_read.cpp b/faiss/impl/index_read.cpp
index d2fd82e80..64ccd9270 100644
--- a/faiss/impl/index_read.cpp
+++ b/faiss/impl/index_read.cpp
@@ -1284,14 +1284,16 @@ Index* read_index(IOReader* f, int io_flags) {
         std::istream is(&rbuf);
         svs->deserialize_impl(is);
         idx = svs;
-    } else if (h == fourcc("ISVS")) {
-        // TODO
-        // SVS static vamana
     } else if (h == fourcc("ISVF")) {
         // SVS Flat
         IndexSVSFlat* svs = new IndexSVSFlat();
         read_index_header(svs, f);
         READ1(svs->num_threads);
+
+        faiss::BufferedIOReader br(f);
+        faiss::svs_io::ReaderStreambuf rbuf(&br);
+        std::istream is(&rbuf);
+        svs->deserialize_impl(is);
         idx = svs;
     }
 #endif // FAISS_USE_SVS
diff --git a/faiss/impl/index_write.cpp b/faiss/impl/index_write.cpp
index e39a9c26e..56b982121 100644
--- a/faiss/impl/index_write.cpp
+++ b/faiss/impl/index_write.cpp
@@ -934,7 +934,7 @@ void write_index(const Index* idx, IOWriter* f, int io_flags) {
         faiss::svs_io::WriterStreambuf wbuf(&bwr);
         std::ostream os(&wbuf);
 
-        static_cast<const IndexSVS*>(idx)->serialize_impl(os);
+        svs->serialize_impl(os);
         os.flush();
     } else if (
             const IndexSVSFlat* svs = dynamic_cast<const IndexSVSFlat*>(idx)) {
@@ -942,6 +942,14 @@ void write_index(const Index* idx, IOWriter* f, int io_flags) {
         WRITE1(h);
         write_index_header(idx, f);
         WRITE1(svs->num_threads);
+
+        // payload (stream to file)
+        faiss::BufferedIOWriter bwr(f);
+        faiss::svs_io::WriterStreambuf wbuf(&bwr);
+        std::ostream os(&wbuf);
+
+        svs->serialize_impl(os);
+        os.flush();
     }
 #endif // FAISS_USE_SVS
     else {
diff --git a/tests/test_svs.cpp b/tests/test_svs.cpp
index ae02b7504..432bfdafa 100644
--- a/tests/test_svs.cpp
+++ b/tests/test_svs.cpp
@@ -63,6 +63,7 @@ void write_and_read_index(T& index, const std::vector<float>& xb, size_t n) {
 
     // Basic checks
     ASSERT_NE(loaded, nullptr);
+    ASSERT_NE(loaded->impl, nullptr);
     EXPECT_EQ(loaded->d, index.d);
     EXPECT_EQ(loaded->metric_type, index.metric_type);
     EXPECT_EQ(loaded->num_threads, index.num_threads);
@@ -153,7 +154,9 @@ TEST_F(SVSIOTest, WriteAndReadIndexSVSFlat) {
     });
 
     ASSERT_NE(loaded, nullptr);
+    ASSERT_NE(loaded->impl, nullptr);
     EXPECT_EQ(loaded->d, index.d);
+    EXPECT_EQ(loaded->nlabels, index.nlabels);
     EXPECT_EQ(loaded->metric_type, index.metric_type);
     EXPECT_EQ(loaded->num_threads, index.num_threads);
 
diff --git a/tests/test_svs.py b/tests/test_svs.py
index 9b20bbafb..11ca2c22e 100644
--- a/tests/test_svs.py
+++ b/tests/test_svs.py
@@ -187,11 +187,6 @@ class TestSVSAdapterFlat(TestSVSAdapter):
         # This test is expected to fail for IndexSVSFlat as it doesn't support batch operations yet
         super().test_svs_batch_operations()
 
-    @unittest.expectedFailure
-    def test_svs_serialization(self):
-        # TODO
-        # This test is expected to fail for IndexSVSFlat as it doesn't support serialization yet
-        super().test_svs_batch_operations()
 
 
 class TestSVSVamanaParameters(unittest.TestCase):
-- 
2.39.5 (Apple Git-154)


From c7fb7dfee93f115e6276f05d861c3fd7a961c856 Mon Sep 17 00:00:00 2001
From: Andreas Huber <andreas.huber@intel.com>
Date: Thu, 14 Aug 2025 02:57:13 -0700
Subject: [PATCH 31/38] Refactor I/O functions into svs_io

---
 faiss/CMakeLists.txt  |   1 +
 faiss/IndexSVS.cpp    | 156 --------------------------------------
 faiss/IndexSVS.h      |  39 +---------
 faiss/IndexSVSFlat.h  |   1 +
 faiss/impl/svs_io.cpp | 171 ++++++++++++++++++++++++++++++++++++++++++
 faiss/impl/svs_io.h   |  57 ++++++++++++++
 6 files changed, 231 insertions(+), 194 deletions(-)
 create mode 100644 faiss/impl/svs_io.cpp
 create mode 100644 faiss/impl/svs_io.h

diff --git a/faiss/CMakeLists.txt b/faiss/CMakeLists.txt
index c38e2f8dd..74fc511bd 100644
--- a/faiss/CMakeLists.txt
+++ b/faiss/CMakeLists.txt
@@ -106,6 +106,7 @@ if(FAISS_USE_SVS)
     IndexSVS.cpp
     IndexSVSLVQ.cpp
     IndexSVSLeanVec.cpp
+    impl/svs_io.cpp
   )
 endif()
 
diff --git a/faiss/IndexSVS.cpp b/faiss/IndexSVS.cpp
index b91e93cb4..1558c190e 100644
--- a/faiss/IndexSVS.cpp
+++ b/faiss/IndexSVS.cpp
@@ -170,160 +170,4 @@ void IndexSVS::deserialize_impl(std::istream& in) {
     }
 }
 
-namespace svs_io {
-
-WriterStreambuf::WriterStreambuf(IOWriter* w_) : w(w_) {}
-
-WriterStreambuf::~WriterStreambuf() = default;
-
-std::streamsize WriterStreambuf::xsputn(const char* s, std::streamsize n) {
-    if (n <= 0)
-        return 0;
-    size_t wrote = (*w)(s, 1, static_cast<size_t>(n));
-    return static_cast<std::streamsize>(wrote);
-}
-
-int WriterStreambuf::overflow(int ch) {
-    if (ch == traits_type::eof())
-        return 0;
-    char c = static_cast<char>(ch);
-    size_t wrote = (*w)(&c, 1, 1);
-    return wrote == 1 ? ch : traits_type::eof();
-}
-
-ReaderStreambuf::ReaderStreambuf(IOReader* rr, size_t bsz)
-        : r(rr), buf(std::max<size_t>(bsz, 4096)) {
-    // empty get area initially
-    setg(buf.data(), buf.data(), buf.data());
-}
-
-ReaderStreambuf::~ReaderStreambuf() = default;
-
-std::streambuf::int_type ReaderStreambuf::underflow() {
-    if (gptr() < egptr()) {
-        return traits_type::to_int_type(*gptr());
-    }
-    size_t got = (*r)(buf.data(), 1, buf.size());
-    if (got == 0) {
-        return traits_type::eof(); // upstream EOF
-    }
-    setg(buf.data(), buf.data(), buf.data() + got);
-    return traits_type::to_int_type(*gptr());
-}
-
-SVSTempDirectory::SVSTempDirectory() {
-    root = std::filesystem::temp_directory_path() /
-            ("faiss_svs_" + std::to_string(std::rand()));
-    config = root / "config";
-    graph = root / "graph";
-    data = root / "data";
-
-    std::filesystem::create_directories(config);
-    std::filesystem::create_directories(graph);
-    std::filesystem::create_directories(data);
-}
-
-SVSTempDirectory::~SVSTempDirectory() {
-    std::error_code ec;
-    std::filesystem::remove_all(root, ec);
-}
-
-static inline void read_exact(std::istream& in, void* p, size_t n) {
-    char* c = static_cast<char*>(p);
-    size_t got = 0;
-    while (got < n) {
-        in.read(c + got, n - got);
-        std::streamsize r = in.gcount();
-        if (r <= 0) {
-            FAISS_THROW_IF_NOT_MSG(false, "Unexpected EOF while reading");
-        }
-        got += size_t(r);
-    }
-}
-
-void SVSTempDirectory::write_files_to_stream(std::ostream& out) const {
-    for (const auto& dir : {config, graph, data}) {
-        const std::string dir_name = dir.filename().string();
-        for (const auto& entry : std::filesystem::directory_iterator(dir)) {
-            const std::string filename = entry.path().filename().string();
-
-            const uint64_t dir_len = dir_name.size();
-            const uint64_t file_len = filename.size();
-            const uint64_t file_size = std::filesystem::file_size(entry.path());
-
-            out.write(reinterpret_cast<const char*>(&dir_len), sizeof(dir_len));
-            out.write(dir_name.data(), dir_len);
-
-            out.write(
-                    reinterpret_cast<const char*>(&file_len), sizeof(file_len));
-            out.write(filename.data(), file_len);
-
-            out.write(
-                    reinterpret_cast<const char*>(&file_size),
-                    sizeof(file_size));
-
-            std::ifstream in(entry.path(), std::ios::binary);
-            FAISS_THROW_IF_NOT_MSG(
-                    in, "Failed to open temp SVS file for reading");
-
-            out << in.rdbuf();
-        }
-    }
-}
-
-void SVSTempDirectory::write_stream_to_files(std::istream& in) const {
-    constexpr size_t BUFSZ = 1 << 20; // 1 MiB
-    std::vector<char> buf(BUFSZ);
-
-    for (;;) {
-        uint64_t dir_len = 0;
-
-        // Try to read next record. If we’re at clean EOF (no bytes), stop.
-        in.read(reinterpret_cast<char*>(&dir_len), sizeof(dir_len));
-        if (!in) {
-            // No bytes read? clean EOF. Partial? error.
-            if (in.eof() && in.gcount() == 0)
-                return;
-            FAISS_THROW_IF_NOT_MSG(false, "Corrupt stream: partial header");
-        }
-
-        std::string dir_name(dir_len, '\0');
-        read_exact(in, dir_name.data(), dir_len);
-
-        uint64_t file_len = 0;
-        read_exact(in, &file_len, sizeof(file_len));
-        std::string filename(file_len, '\0');
-        read_exact(in, filename.data(), file_len);
-
-        uint64_t file_size = 0;
-        read_exact(in, &file_size, sizeof(file_size));
-
-        std::filesystem::path base;
-        if (dir_name == "config")
-            base = config;
-        else if (dir_name == "graph")
-            base = graph;
-        else if (dir_name == "data")
-            base = data;
-        else
-            FAISS_THROW_IF_NOT_MSG(false, "Unknown SVS subdirectory name");
-
-        std::filesystem::path full_path = base / filename;
-        std::ofstream out(full_path, std::ios::binary);
-        FAISS_THROW_IF_NOT_MSG(out, "Failed to open temp SVS file for writing");
-
-        // Stream body in chunks
-        uint64_t remaining = file_size;
-        while (remaining > 0) {
-            size_t want = size_t(std::min<uint64_t>(remaining, buf.size()));
-            read_exact(in, buf.data(), want);
-            out.write(buf.data(), want);
-            FAISS_THROW_IF_NOT_MSG(out, "Short write to temp SVS file");
-            remaining -= want;
-        }
-    }
-}
-
-} // namespace svs_io
-
 } // namespace faiss
diff --git a/faiss/IndexSVS.h b/faiss/IndexSVS.h
index 33ac24396..769b2ada6 100644
--- a/faiss/IndexSVS.h
+++ b/faiss/IndexSVS.h
@@ -8,6 +8,7 @@
 #pragma once
 
 #include "faiss/Index.h"
+#include "faiss/impl/svs_io.h"
 
 #include <cstddef>
 #include <cstdint>
@@ -72,42 +73,4 @@ struct IndexSVS : Index {
     virtual void init_impl(idx_t n, const float* x);
 };
 
-// We provide some helpers for efficient I/O in the svs_io namespace
-// These can be excluded from the Python bindings
-namespace svs_io {
-// Bridges IOWriter to std::ostream (used for streaming payload out)
-struct WriterStreambuf : std::streambuf {
-    IOWriter* w; // not owning
-    explicit WriterStreambuf(IOWriter* w_);
-    ~WriterStreambuf() override; // out-of-line def in .cpp
-   protected:
-    std::streamsize xsputn(const char* s, std::streamsize n) override;
-    int overflow(int ch) override;
-};
-
-// Bridges IOReader to std::istream (used to read payload to EOF)
-struct ReaderStreambuf : std::streambuf {
-    IOReader* r;           // not owning
-    std::vector<char> buf; // ring buffer (default 1 MiB)
-    explicit ReaderStreambuf(IOReader* rr, size_t bsz = (1u << 20));
-    ~ReaderStreambuf() override; // out-of-line def in .cpp
-   protected:
-    int_type underflow() override;
-};
-
-/* temporary directory for SVS Vamana indices that tries to always clean up */
-struct SVSTempDirectory {
-    std::filesystem::path root;
-    std::filesystem::path config;
-    std::filesystem::path graph;
-    std::filesystem::path data;
-
-    SVSTempDirectory();
-    ~SVSTempDirectory();
-
-    void write_files_to_stream(std::ostream& out) const;
-    void write_stream_to_files(std::istream& in) const;
-};
-} // namespace svs_io
-
 } // namespace faiss
diff --git a/faiss/IndexSVSFlat.h b/faiss/IndexSVSFlat.h
index b61cf9175..fe6812cfd 100644
--- a/faiss/IndexSVSFlat.h
+++ b/faiss/IndexSVSFlat.h
@@ -15,6 +15,7 @@
 #include <vector>
 
 #include "faiss/Index.h"
+#include "faiss/impl/svs_io.h"
 
 #include "svs/core/distance.h"
 
diff --git a/faiss/impl/svs_io.cpp b/faiss/impl/svs_io.cpp
new file mode 100644
index 000000000..cc4cc9798
--- /dev/null
+++ b/faiss/impl/svs_io.cpp
@@ -0,0 +1,171 @@
+/*
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+
+#include <faiss/impl/svs_io.h>
+
+#include <algorithm>
+#include <cstdlib>
+#include <fstream>
+
+#include <faiss/impl/FaissAssert.h>
+
+namespace faiss {
+namespace svs_io {
+
+WriterStreambuf::WriterStreambuf(IOWriter* w_) : w(w_) {}
+
+WriterStreambuf::~WriterStreambuf() = default;
+
+std::streamsize WriterStreambuf::xsputn(const char* s, std::streamsize n) {
+    if (n <= 0)
+        return 0;
+    size_t wrote = (*w)(s, 1, static_cast<size_t>(n));
+    return static_cast<std::streamsize>(wrote);
+}
+
+int WriterStreambuf::overflow(int ch) {
+    if (ch == traits_type::eof())
+        return 0;
+    char c = static_cast<char>(ch);
+    size_t wrote = (*w)(&c, 1, 1);
+    return wrote == 1 ? ch : traits_type::eof();
+}
+
+ReaderStreambuf::ReaderStreambuf(IOReader* rr)
+        : r(rr), buf(1 << 20 /* 1 MiB */) {
+    setg(buf.data(), buf.data(), buf.data());
+}
+
+ReaderStreambuf::~ReaderStreambuf() = default;
+
+std::streambuf::int_type ReaderStreambuf::underflow() {
+    if (gptr() < egptr()) {
+        return traits_type::to_int_type(*gptr());
+    }
+    size_t got = (*r)(buf.data(), 1, buf.size());
+    if (got == 0) {
+        return traits_type::eof(); 
+    }
+    setg(buf.data(), buf.data(), buf.data() + got);
+    return traits_type::to_int_type(*gptr());
+}
+
+SVSTempDirectory::SVSTempDirectory() {
+    root = std::filesystem::temp_directory_path() /
+            ("faiss_svs_" + std::to_string(std::rand()));
+    config = root / "config";
+    graph = root / "graph";
+    data = root / "data";
+
+    std::filesystem::create_directories(config);
+    std::filesystem::create_directories(graph);
+    std::filesystem::create_directories(data);
+}
+
+SVSTempDirectory::~SVSTempDirectory() {
+    std::error_code ec;
+    std::filesystem::remove_all(root, ec);
+}
+
+static inline void read_exact(std::istream& in, void* p, size_t n) {
+    char* c = static_cast<char*>(p);
+    size_t got = 0;
+    while (got < n) {
+        in.read(c + got, n - got);
+        std::streamsize r = in.gcount();
+        if (r <= 0) {
+            FAISS_THROW_IF_NOT_MSG(false, "Unexpected EOF while reading");
+        }
+        got += size_t(r);
+    }
+}
+
+void SVSTempDirectory::write_files_to_stream(std::ostream& out) const {
+    for (const auto& dir : {config, graph, data}) {
+        const std::string dir_name = dir.filename().string();
+        for (const auto& entry : std::filesystem::directory_iterator(dir)) {
+            const std::string filename = entry.path().filename().string();
+
+            const uint64_t dir_len = dir_name.size();
+            const uint64_t file_len = filename.size();
+            const uint64_t file_size = std::filesystem::file_size(entry.path());
+
+            out.write(reinterpret_cast<const char*>(&dir_len), sizeof(dir_len));
+            out.write(dir_name.data(), dir_len);
+
+            out.write(
+                    reinterpret_cast<const char*>(&file_len), sizeof(file_len));
+            out.write(filename.data(), file_len);
+
+            out.write(
+                    reinterpret_cast<const char*>(&file_size),
+                    sizeof(file_size));
+
+            std::ifstream in(entry.path(), std::ios::binary);
+            FAISS_THROW_IF_NOT_MSG(
+                    in, "Failed to open temp SVS file for reading");
+
+            out << in.rdbuf();
+        }
+    }
+}
+
+void SVSTempDirectory::write_stream_to_files(std::istream& in) const {
+    constexpr size_t BUFSZ = 1 << 20; // 1 MiB
+    std::vector<char> buf(BUFSZ);
+
+    for (;;) {
+        uint64_t dir_len = 0;
+
+        // Try to read next record. If we're at clean EOF (no bytes), stop.
+        in.read(reinterpret_cast<char*>(&dir_len), sizeof(dir_len));
+        if (!in) {
+            // No bytes read? clean EOF. Partial? error.
+            if (in.eof() && in.gcount() == 0)
+                return;
+            FAISS_THROW_IF_NOT_MSG(false, "Corrupt stream: partial header");
+        }
+
+        std::string dir_name(dir_len, '\0');
+        read_exact(in, dir_name.data(), dir_len);
+
+        uint64_t file_len = 0;
+        read_exact(in, &file_len, sizeof(file_len));
+        std::string filename(file_len, '\0');
+        read_exact(in, filename.data(), file_len);
+
+        uint64_t file_size = 0;
+        read_exact(in, &file_size, sizeof(file_size));
+
+        std::filesystem::path base;
+        if (dir_name == "config")
+            base = config;
+        else if (dir_name == "graph")
+            base = graph;
+        else if (dir_name == "data")
+            base = data;
+        else
+            FAISS_THROW_IF_NOT_MSG(false, "Unknown SVS subdirectory name");
+
+        std::filesystem::path full_path = base / filename;
+        std::ofstream out(full_path, std::ios::binary);
+        FAISS_THROW_IF_NOT_MSG(out, "Failed to open temp SVS file for writing");
+
+        // Stream body in chunks
+        uint64_t remaining = file_size;
+        while (remaining > 0) {
+            size_t want = size_t(std::min<uint64_t>(remaining, buf.size()));
+            read_exact(in, buf.data(), want);
+            out.write(buf.data(), want);
+            FAISS_THROW_IF_NOT_MSG(out, "Short write to temp SVS file");
+            remaining -= want;
+        }
+    }
+}
+
+} // namespace svs_io
+} // namespace faiss
diff --git a/faiss/impl/svs_io.h b/faiss/impl/svs_io.h
new file mode 100644
index 000000000..2b56641f6
--- /dev/null
+++ b/faiss/impl/svs_io.h
@@ -0,0 +1,57 @@
+/*
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+
+#pragma once
+
+#include <filesystem>
+#include <iostream>
+#include <streambuf>
+#include <vector>
+
+#include <faiss/impl/io.h>
+
+namespace faiss {
+namespace svs_io {
+
+// Bridges IOWriter to std::ostream (used for streaming payload out)
+struct WriterStreambuf : std::streambuf {
+    IOWriter* w;
+    explicit WriterStreambuf(IOWriter* w_);
+    ~WriterStreambuf() override;
+
+   protected:
+    std::streamsize xsputn(const char* s, std::streamsize n) override;
+    int overflow(int ch) override;
+};
+
+// Bridges IOReader to std::istream (used to read payload to EOF)
+struct ReaderStreambuf : std::streambuf {
+    IOReader* r;
+    std::vector<char> buf;
+    explicit ReaderStreambuf(IOReader* rr);
+    ~ReaderStreambuf() override;
+
+   protected:
+    int_type underflow() override;
+};
+
+/* temporary directory for SVS indices that tries to always clean up */
+struct SVSTempDirectory {
+    std::filesystem::path root;
+    std::filesystem::path config;
+    std::filesystem::path graph;
+    std::filesystem::path data;
+
+    SVSTempDirectory();
+    ~SVSTempDirectory();
+
+    void write_files_to_stream(std::ostream& out) const;
+    void write_stream_to_files(std::istream& in) const;
+};
+
+} // namespace svs_io
+} // namespace faiss
-- 
2.39.5 (Apple Git-154)


From 42adb071dc0e6422fa06e8c9572b217c81069053 Mon Sep 17 00:00:00 2001
From: Andreas Huber <andreas.huber@intel.com>
Date: Thu, 14 Aug 2025 03:12:47 -0700
Subject: [PATCH 32/38] cleanup includes and fwd decl

---
 faiss/IndexSVS.cpp        | 11 +++++------
 faiss/IndexSVS.h          | 17 ++---------------
 faiss/IndexSVSFlat.cpp    |  3 +--
 faiss/IndexSVSFlat.h      | 11 +++--------
 faiss/IndexSVSLVQ.cpp     |  5 +++--
 faiss/IndexSVSLVQ.h       |  2 +-
 faiss/IndexSVSLeanVec.cpp |  9 ++++++---
 faiss/IndexSVSLeanVec.h   |  2 +-
 8 files changed, 22 insertions(+), 38 deletions(-)

diff --git a/faiss/IndexSVS.cpp b/faiss/IndexSVS.cpp
index 1558c190e..573e4f670 100644
--- a/faiss/IndexSVS.cpp
+++ b/faiss/IndexSVS.cpp
@@ -5,13 +5,12 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include "faiss/IndexSVS.h"
-#include "faiss/Index.h"
-#include "faiss/MetricType.h"
-#include "faiss/impl/io.h"
+#include <faiss/IndexSVS.h>
 
-#include "svs/core/data.h"
-#include "svs/orchestrators/dynamic_vamana.h"
+#include <svs/core/data.h>
+#include <svs/orchestrators/dynamic_vamana.h>
+
+#include <faiss/MetricType.h>
 
 namespace faiss {
 
diff --git a/faiss/IndexSVS.h b/faiss/IndexSVS.h
index 769b2ada6..cb7f00dc0 100644
--- a/faiss/IndexSVS.h
+++ b/faiss/IndexSVS.h
@@ -7,30 +7,17 @@
 
 #pragma once
 
-#include "faiss/Index.h"
-#include "faiss/impl/svs_io.h"
+#include <faiss/Index.h>
+#include <faiss/impl/svs_io.h>
 
 #include <cstddef>
-#include <cstdint>
-#include <filesystem>
 #include <numeric>
-#include <streambuf>
-#include <utility>
 #include <vector>
 
-namespace faiss {
-struct IOReader;
-struct IOWriter;
-} // namespace faiss
-
 namespace svs {
 class DynamicVamana;
 }
 
-namespace faiss {
-struct IOWriter;
-}
-
 namespace faiss {
 
 struct IndexSVS : Index {
diff --git a/faiss/IndexSVSFlat.cpp b/faiss/IndexSVSFlat.cpp
index 20b56c602..df8fa7d09 100644
--- a/faiss/IndexSVSFlat.cpp
+++ b/faiss/IndexSVSFlat.cpp
@@ -5,13 +5,12 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/Index.h>
-#include <faiss/IndexSVS.h>
 #include <faiss/IndexSVSFlat.h>
 
 #include <faiss/impl/FaissAssert.h>
 #include <svs/core/data.h>
 #include <svs/core/query_result.h>
+
 #include <svs/orchestrators/exhaustive.h>
 
 namespace faiss {
diff --git a/faiss/IndexSVSFlat.h b/faiss/IndexSVSFlat.h
index fe6812cfd..75a391798 100644
--- a/faiss/IndexSVSFlat.h
+++ b/faiss/IndexSVSFlat.h
@@ -7,17 +7,12 @@
 
 #pragma once
 
-#include <filesystem>
 #include <iostream>
-#include <memory>
-#include <numeric>
-#include <variant>
-#include <vector>
 
-#include "faiss/Index.h"
-#include "faiss/impl/svs_io.h"
+#include <svs/core/distance.h>
 
-#include "svs/core/distance.h"
+#include <faiss/Index.h>
+#include <faiss/impl/svs_io.h>
 
 namespace svs {
 class Flat;
diff --git a/faiss/IndexSVSLVQ.cpp b/faiss/IndexSVSLVQ.cpp
index 871e94682..41f2c66c5 100644
--- a/faiss/IndexSVSLVQ.cpp
+++ b/faiss/IndexSVSLVQ.cpp
@@ -5,10 +5,11 @@
  * LICENSE file in the root directory of this source tree.
  */
 
+#include <faiss/IndexSVSLVQ.h>
+
 #include <variant>
 
-#include "faiss/IndexSVSLVQ.h"
-#include "svs/orchestrators/dynamic_vamana.h"
+#include <svs/orchestrators/dynamic_vamana.h>
 namespace faiss {
 
 IndexSVSLVQ::IndexSVSLVQ(idx_t d, MetricType metric, LVQLevel lvq_level)
diff --git a/faiss/IndexSVSLVQ.h b/faiss/IndexSVSLVQ.h
index 49a7d1dbf..90b150e1f 100644
--- a/faiss/IndexSVSLVQ.h
+++ b/faiss/IndexSVSLVQ.h
@@ -9,7 +9,7 @@
 
 #include <faiss/IndexSVS.h>
 
-#include "svs/extensions/vamana/lvq.h"
+#include <svs/extensions/vamana/lvq.h>
 
 namespace faiss {
 
diff --git a/faiss/IndexSVSLeanVec.cpp b/faiss/IndexSVSLeanVec.cpp
index 7321b77d7..7c6c03cfe 100644
--- a/faiss/IndexSVSLeanVec.cpp
+++ b/faiss/IndexSVSLeanVec.cpp
@@ -6,10 +6,13 @@
  */
 
 #include <faiss/IndexSVSLeanVec.h>
+
 #include <variant>
-#include "faiss/impl/FaissAssert.h"
-#include "svs/core/medioid.h"
-#include "svs/orchestrators/dynamic_vamana.h"
+
+#include <svs/core/medioid.h>
+#include <svs/orchestrators/dynamic_vamana.h>
+
+#include <faiss/impl/FaissAssert.h>
 
 namespace faiss {
 
diff --git a/faiss/IndexSVSLeanVec.h b/faiss/IndexSVSLeanVec.h
index b216a13f9..9c5eccab1 100644
--- a/faiss/IndexSVSLeanVec.h
+++ b/faiss/IndexSVSLeanVec.h
@@ -9,7 +9,7 @@
 
 #include <faiss/IndexSVS.h>
 
-#include "svs/extensions/vamana/leanvec.h"
+#include <svs/extensions/vamana/leanvec.h>
 
 namespace faiss {
 
-- 
2.39.5 (Apple Git-154)


From 3378077284dcb38b159e45be530be3ed63d96378 Mon Sep 17 00:00:00 2001
From: Andreas Huber <andreas.huber@intel.com>
Date: Thu, 14 Aug 2025 03:19:30 -0700
Subject: [PATCH 33/38] rename FAISS_USE_SVS -> FAISS_ENABLE_SVS

---
 CMakeLists.txt              |  2 +-
 faiss/CMakeLists.txt        | 20 ++++++++++----------
 faiss/impl/index_read.cpp   |  6 +++---
 faiss/impl/index_write.cpp  |  6 +++---
 faiss/index_factory.cpp     | 10 +++++-----
 faiss/python/CMakeLists.txt | 18 +++++++++---------
 faiss/python/swigfaiss.swig | 10 +++++-----
 faiss/utils/utils.cpp       |  2 +-
 tests/CMakeLists.txt        |  2 +-
 tutorial/cpp/CMakeLists.txt |  2 +-
 10 files changed, 39 insertions(+), 39 deletions(-)

diff --git a/CMakeLists.txt b/CMakeLists.txt
index b88b457de..a10e77d9d 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -68,7 +68,7 @@ option(FAISS_ENABLE_PYTHON "Build Python extension." ON)
 option(FAISS_ENABLE_C_API "Build C API." OFF)
 option(FAISS_ENABLE_EXTRAS "Build extras like benchmarks and demos" ON)
 option(FAISS_USE_LTO "Enable Link-Time optimization" OFF)
-option(FAISS_USE_SVS "Enable SVS (Intel(R) Scalable Vector Search) integration." ON)
+option(FAISS_ENABLE_SVS "Enable SVS (Intel(R) Scalable Vector Search) integration." ON)
 
 if(FAISS_ENABLE_GPU)
   if(FAISS_ENABLE_ROCM)
diff --git a/faiss/CMakeLists.txt b/faiss/CMakeLists.txt
index 74fc511bd..a1f234671 100644
--- a/faiss/CMakeLists.txt
+++ b/faiss/CMakeLists.txt
@@ -100,7 +100,7 @@ set(FAISS_SRC
   utils/distances_fused/simdlib_based.cpp
 )
 
-if(FAISS_USE_SVS)
+if(FAISS_ENABLE_SVS)
   list(APPEND FAISS_SRC
     IndexSVSFlat.cpp
     IndexSVS.cpp
@@ -251,7 +251,7 @@ set(FAISS_HEADERS
   utils/hamming_distance/avx512-inl.h
 )
 
-if(FAISS_USE_SVS)
+if(FAISS_ENABLE_SVS)
   list(APPEND FAISS_HEADERS
     IndexSVSFlat.h
     IndexSVS.h
@@ -339,7 +339,7 @@ if(NOT WIN32)
   endif()
 endif()
 
-if(FAISS_USE_SVS)
+if(FAISS_ENABLE_SVS)
   include(FetchContent)
   set(SVS_URL "https://github.com/intel/ScalableVectorSearch/releases/download/v0.0.9/svs-shared-library-0.0.9.tar.gz")
   FetchContent_Declare(
@@ -368,7 +368,7 @@ target_include_directories(faiss_avx512_spr PUBLIC
 # Handle `#include <faiss/foo.h>`.
 target_include_directories(faiss_sve PUBLIC
   $<BUILD_INTERFACE:${PROJECT_SOURCE_DIR}>)
-if(FAISS_USE_SVS)
+if(FAISS_ENABLE_SVS)
   # Handle `#include <svs/foo.h>`.
   target_include_directories(faiss PUBLIC
     $<BUILD_INTERFACE:${svs_SOURCE_DIR}/include>)
@@ -387,12 +387,12 @@ if(WIN32)
   target_compile_definitions(faiss_sve PRIVATE FAISS_MAIN_LIB)
 endif()
 
-if(FAISS_USE_SVS)
-  target_compile_definitions(faiss PRIVATE FAISS_USE_SVS)
-  target_compile_definitions(faiss_avx2 PRIVATE FAISS_USE_SVS)
-  target_compile_definitions(faiss_avx512 PRIVATE FAISS_USE_SVS)
-  target_compile_definitions(faiss_avx512_spr PRIVATE FAISS_USE_SVS)
-  target_compile_definitions(faiss_sve PRIVATE FAISS_USE_SVS)
+if(FAISS_ENABLE_SVS)
+  target_compile_definitions(faiss PRIVATE FAISS_ENABLE_SVS)
+  target_compile_definitions(faiss_avx2 PRIVATE FAISS_ENABLE_SVS)
+  target_compile_definitions(faiss_avx512 PRIVATE FAISS_ENABLE_SVS)
+  target_compile_definitions(faiss_avx512_spr PRIVATE FAISS_ENABLE_SVS)
+  target_compile_definitions(faiss_sve PRIVATE FAISS_ENABLE_SVS)
 endif()
 
 if(WIN32)
diff --git a/faiss/impl/index_read.cpp b/faiss/impl/index_read.cpp
index 64ccd9270..41e0be8e9 100644
--- a/faiss/impl/index_read.cpp
+++ b/faiss/impl/index_read.cpp
@@ -45,7 +45,7 @@
 #include <faiss/IndexRaBitQ.h>
 #include <faiss/IndexRefine.h>
 #include <faiss/IndexRowwiseMinMax.h>
-#ifdef FAISS_USE_SVS
+#ifdef FAISS_ENABLE_SVS
 #include <faiss/IndexSVS.h>
 #include <faiss/IndexSVSFlat.h>
 #include <faiss/IndexSVSLVQ.h>
@@ -1249,7 +1249,7 @@ Index* read_index(IOReader* f, int io_flags) {
         read_InvertedLists(ivrq, f, io_flags);
         idx = ivrq;
     }
-#ifdef FAISS_USE_SVS
+#ifdef FAISS_ENABLE_SVS
     else if (
             h == fourcc("ILVQ") || h == fourcc("ISVL") || h == fourcc("ISVD")) {
         IndexSVS* svs;
@@ -1296,7 +1296,7 @@ Index* read_index(IOReader* f, int io_flags) {
         svs->deserialize_impl(is);
         idx = svs;
     }
-#endif // FAISS_USE_SVS
+#endif // FAISS_ENABLE_SVS
     else {
         FAISS_THROW_FMT(
                 "Index type 0x%08x (\"%s\") not recognized",
diff --git a/faiss/impl/index_write.cpp b/faiss/impl/index_write.cpp
index 56b982121..a977c4908 100644
--- a/faiss/impl/index_write.cpp
+++ b/faiss/impl/index_write.cpp
@@ -43,7 +43,7 @@
 #include <faiss/IndexRaBitQ.h>
 #include <faiss/IndexRefine.h>
 #include <faiss/IndexRowwiseMinMax.h>
-#ifdef FAISS_USE_SVS
+#ifdef FAISS_ENABLE_SVS
 #include <faiss/IndexSVS.h>
 #include <faiss/IndexSVSFlat.h>
 #include <faiss/IndexSVSLVQ.h>
@@ -888,7 +888,7 @@ void write_index(const Index* idx, IOWriter* f, int io_flags) {
         WRITE1(ivrq->qb);
         write_InvertedLists(ivrq->invlists, f);
     }
-#ifdef FAISS_USE_SVS
+#ifdef FAISS_ENABLE_SVS
     else if (const IndexSVS* svs = dynamic_cast<const IndexSVS*>(idx)) {
         // The SVS implementation will write its contents to three directories,
         // which we will read back here for writing to the actual output file.
@@ -951,7 +951,7 @@ void write_index(const Index* idx, IOWriter* f, int io_flags) {
         svs->serialize_impl(os);
         os.flush();
     }
-#endif // FAISS_USE_SVS
+#endif // FAISS_ENABLE_SVS
     else {
         FAISS_THROW_MSG("don't know how to serialize this type of index");
     }
diff --git a/faiss/index_factory.cpp b/faiss/index_factory.cpp
index 60f358802..900a9a431 100644
--- a/faiss/index_factory.cpp
+++ b/faiss/index_factory.cpp
@@ -50,7 +50,7 @@
 #include <faiss/IndexBinaryHash.h>
 #include <faiss/IndexBinaryIVF.h>
 
-#ifdef FAISS_USE_SVS
+#ifdef FAISS_ENABLE_SVS
 #include <faiss/IndexSVS.h>
 #include <faiss/IndexSVSLVQ.h>
 #include <faiss/IndexSVSLeanVec.h>
@@ -543,7 +543,7 @@ IndexNSG* parse_IndexNSG(
     return nullptr;
 }
 
-#ifdef FAISS_USE_SVS
+#ifdef FAISS_ENABLE_SVS
 /***************************************************************
  * Parse IndexSVS
  */
@@ -601,7 +601,7 @@ IndexSVS* parse_IndexSVS(const std::string code_string, int d, MetricType mt) {
 
     return nullptr;
 }
-#endif // FAISS_USE_SVS
+#endif // FAISS_ENABLE_SVS
 
 /***************************************************************
  * Parse basic indexes
@@ -888,7 +888,7 @@ std::unique_ptr<Index> index_factory_sub(
         return std::unique_ptr<Index>(index);
     }
 
-#ifdef FAISS_USE_SVS
+#ifdef FAISS_ENABLE_SVS
     if (re_match(description, "SVS([_].*)?", sm)) {
         // We also accept empty code string
         std::string code_string =
@@ -907,7 +907,7 @@ std::unique_ptr<Index> index_factory_sub(
                 description.c_str());
         return std::unique_ptr<Index>(index);
     }
-#endif // FAISS_USE_SVS
+#endif // FAISS_ENABLE_SVS
 
     // NSG variants (it was unclear in the old version that the separator was a
     // "," so we support both "_" and ",")
diff --git a/faiss/python/CMakeLists.txt b/faiss/python/CMakeLists.txt
index 7aeb6e1f5..70db9c26d 100644
--- a/faiss/python/CMakeLists.txt
+++ b/faiss/python/CMakeLists.txt
@@ -33,9 +33,9 @@ macro(configure_swigfaiss source)
       SWIG_FLAGS -DSWIGWIN
     )
   endif()
-  if(FAISS_USE_SVS)
+  if(FAISS_ENABLE_SVS)
     set_property(SOURCE ${source} APPEND PROPERTY
-      SWIG_FLAGS -DFAISS_USE_SVS
+      SWIG_FLAGS -DFAISS_ENABLE_SVS
     )
   endif()
   if(FAISS_ENABLE_GPU)
@@ -210,13 +210,13 @@ else()
   target_compile_options(faiss_example_external_module PRIVATE /bigobj)
 endif()
 
-if(FAISS_USE_SVS)
-  target_compile_definitions(swigfaiss PRIVATE FAISS_USE_SVS)
-  target_compile_definitions(swigfaiss_avx2 PRIVATE FAISS_USE_SVS)
-  target_compile_definitions(swigfaiss_avx512 PRIVATE FAISS_USE_SVS)
-  target_compile_definitions(swigfaiss_avx512_spr PRIVATE FAISS_USE_SVS)
-  target_compile_definitions(swigfaiss_sve PRIVATE FAISS_USE_SVS)
-  target_compile_definitions(faiss_example_external_module PRIVATE FAISS_USE_SVS)
+if(FAISS_ENABLE_SVS)
+  target_compile_definitions(swigfaiss PRIVATE FAISS_ENABLE_SVS)
+  target_compile_definitions(swigfaiss_avx2 PRIVATE FAISS_ENABLE_SVS)
+  target_compile_definitions(swigfaiss_avx512 PRIVATE FAISS_ENABLE_SVS)
+  target_compile_definitions(swigfaiss_avx512_spr PRIVATE FAISS_ENABLE_SVS)
+  target_compile_definitions(swigfaiss_sve PRIVATE FAISS_ENABLE_SVS)
+  target_compile_definitions(faiss_example_external_module PRIVATE FAISS_ENABLE_SVS)
 endif()
 
 if(FAISS_ENABLE_GPU)
diff --git a/faiss/python/swigfaiss.swig b/faiss/python/swigfaiss.swig
index f0c45fed3..9c00e9f62 100644
--- a/faiss/python/swigfaiss.swig
+++ b/faiss/python/swigfaiss.swig
@@ -194,7 +194,7 @@ typedef uint64_t size_t;
 #include <faiss/IndexRaBitQ.h>
 #include <faiss/IndexIVFRaBitQ.h>
 
-#ifdef FAISS_USE_SVS
+#ifdef FAISS_ENABLE_SVS
 #include <faiss/IndexSVS.h>
 #include <faiss/IndexSVSFlat.h>
 #include <faiss/IndexSVSLVQ.h>
@@ -687,7 +687,7 @@ struct faiss::simd16uint16 {};
 
 %include <faiss/utils/approx_topk/mode.h>
 
-#ifdef FAISS_USE_SVS
+#ifdef FAISS_ENABLE_SVS
 /* Hide SVS I/O helpers */
 %ignore faiss::svs_io::ReaderStreambuf;
 %ignore faiss::svs_io::WriterStreambuf;
@@ -697,7 +697,7 @@ struct faiss::simd16uint16 {};
 %include  <faiss/IndexSVSFlat.h>
 %include  <faiss/IndexSVSLVQ.h>
 %include  <faiss/IndexSVSLeanVec.h>
-#endif // FAISS_USE_SVS
+#endif // FAISS_ENABLE_SVS
 
 #ifdef GPU_WRAPPER
 
@@ -845,12 +845,12 @@ struct faiss::simd16uint16 {};
     DOWNCAST ( IndexRandom )
     DOWNCAST ( IndexRowwiseMinMax )
     DOWNCAST ( IndexRowwiseMinMaxFP16 )
-#ifdef FAISS_USE_SVS
+#ifdef FAISS_ENABLE_SVS
     DOWNCAST ( IndexSVSFlat )
     DOWNCAST ( IndexSVSLeanVec )
     DOWNCAST ( IndexSVSLVQ )
     DOWNCAST ( IndexSVS )
-#endif // FAISS_USE_SVS
+#endif // FAISS_ENABLE_SVS
 #ifdef GPU_WRAPPER
 #ifdef FAISS_ENABLE_CUVS
     DOWNCAST_GPU ( GpuIndexCagra )
diff --git a/faiss/utils/utils.cpp b/faiss/utils/utils.cpp
index 44764de03..7f4df7019 100644
--- a/faiss/utils/utils.cpp
+++ b/faiss/utils/utils.cpp
@@ -124,7 +124,7 @@ std::string get_compile_options() {
     options += "GENERIC ";
 #endif
 
-#ifdef FAISS_USE_SVS
+#ifdef FAISS_ENABLE_SVS
     options += "SVS ";
 #endif
 
diff --git a/tests/CMakeLists.txt b/tests/CMakeLists.txt
index a6f868b05..37efba875 100644
--- a/tests/CMakeLists.txt
+++ b/tests/CMakeLists.txt
@@ -40,7 +40,7 @@ set(FAISS_TEST_SRC
   test_zerocopy.cpp
 )
 
-if(FAISS_USE_SVS)
+if(FAISS_ENABLE_SVS)
   list(APPEND FAISS_TEST_SRC test_svs.cpp)
 endif()
 
diff --git a/tutorial/cpp/CMakeLists.txt b/tutorial/cpp/CMakeLists.txt
index a37e542d0..fb0f9f17c 100644
--- a/tutorial/cpp/CMakeLists.txt
+++ b/tutorial/cpp/CMakeLists.txt
@@ -30,7 +30,7 @@ target_link_libraries(8-PQFastScanRefine PRIVATE faiss)
 add_executable(9-RefineComparison EXCLUDE_FROM_ALL 9-RefineComparison.cpp)
 target_link_libraries(9-RefineComparison PRIVATE faiss)
 
-if(FAISS_USE_SVS)
+if(FAISS_ENABLE_SVS)
   add_executable(10-SVS EXCLUDE_FROM_ALL 10-SVS.cpp)
   target_link_libraries(10-SVS PRIVATE faiss)
 
-- 
2.39.5 (Apple Git-154)


From 363ec051923f613fe367f4746c7839a16427d3e5 Mon Sep 17 00:00:00 2001
From: Aaron Lin <aaron.dl.lin@intel.com>
Date: Fri, 15 Aug 2025 14:38:52 -0700
Subject: [PATCH 34/38] Swith SVS threading to OpenMP

---
 faiss/CMakeLists.txt       |  3 ++-
 faiss/IndexSVS.cpp         |  9 ++++++---
 faiss/IndexSVS.h           |  1 -
 faiss/IndexSVSFlat.cpp     |  6 ++++--
 faiss/IndexSVSFlat.h       |  1 -
 faiss/IndexSVSLVQ.cpp      | 11 +++++++----
 faiss/IndexSVSLeanVec.cpp  | 14 +++++++++-----
 faiss/impl/index_read.cpp  |  2 --
 faiss/impl/index_write.cpp |  2 --
 tutorial/python/10-SVS.py  |  1 -
 10 files changed, 28 insertions(+), 22 deletions(-)

diff --git a/faiss/CMakeLists.txt b/faiss/CMakeLists.txt
index a1f234671..d1b05e14f 100644
--- a/faiss/CMakeLists.txt
+++ b/faiss/CMakeLists.txt
@@ -341,7 +341,7 @@ endif()
 
 if(FAISS_ENABLE_SVS)
   include(FetchContent)
-  set(SVS_URL "https://github.com/intel/ScalableVectorSearch/releases/download/v0.0.9/svs-shared-library-0.0.9.tar.gz")
+  set(SVS_URL "https://github.com/intel/ScalableVectorSearch/releases/download/v0.0.8-dev/svs-shared-library-0.0.8-20250815.tar.gz")
   FetchContent_Declare(
       svs
       URL "${SVS_URL}"
@@ -349,6 +349,7 @@ if(FAISS_ENABLE_SVS)
   FetchContent_MakeAvailable(svs)
   list(APPEND CMAKE_PREFIX_PATH "${svs_SOURCE_DIR}")
   find_package(svs REQUIRED)
+  target_compile_options(svs::svs INTERFACE "-DSVS_ENABLE_OMP=1")
 
   target_link_libraries(faiss PUBLIC svs::svs svs::svs_shared_library)
 endif()
diff --git a/faiss/IndexSVS.cpp b/faiss/IndexSVS.cpp
index 573e4f670..8d67d9f28 100644
--- a/faiss/IndexSVS.cpp
+++ b/faiss/IndexSVS.cpp
@@ -86,7 +86,8 @@ void IndexSVS::search(
 void IndexSVS::init_impl(idx_t n, const float* x) {
     std::vector<size_t> labels(n);
     auto data = svs::data::SimpleData<float>(n, d);
-    auto threadpool = svs::threads::as_threadpool(num_threads);
+    auto threadpool = svs::threads::ThreadPoolHandle(
+            svs::threads::OMPThreadPool(omp_get_max_threads()));
 
     svs::threads::parallel_for(
             threadpool,
@@ -146,6 +147,8 @@ void IndexSVS::deserialize_impl(std::istream& in) {
     // Write stream to files that can be read by DynamicVamana::assemble()
     svs_io::SVSTempDirectory tmp;
     tmp.write_stream_to_files(in);
+    auto threadpool = svs::threads::ThreadPoolHandle(
+            svs::threads::OMPThreadPool(omp_get_max_threads()));
 
     switch (metric_type) {
         case METRIC_INNER_PRODUCT:
@@ -154,7 +157,7 @@ void IndexSVS::deserialize_impl(std::istream& in) {
                     svs::GraphLoader(tmp.graph.string()),
                     svs::VectorDataLoader<float>(tmp.data.string()),
                     svs::distance::DistanceIP(),
-                    num_threads));
+                    std::move(threadpool)));
             break;
         case METRIC_L2:
             impl = new svs::DynamicVamana(svs::DynamicVamana::assemble<float>(
@@ -162,7 +165,7 @@ void IndexSVS::deserialize_impl(std::istream& in) {
                     svs::GraphLoader(tmp.graph.string()),
                     svs::VectorDataLoader<float>(tmp.data.string()),
                     svs::distance::DistanceL2(),
-                    num_threads));
+                    std::move(threadpool)));
             break;
         default:
             FAISS_ASSERT(!"not supported SVS distance");
diff --git a/faiss/IndexSVS.h b/faiss/IndexSVS.h
index cb7f00dc0..3f3377ece 100644
--- a/faiss/IndexSVS.h
+++ b/faiss/IndexSVS.h
@@ -21,7 +21,6 @@ class DynamicVamana;
 namespace faiss {
 
 struct IndexSVS : Index {
-    size_t num_threads = 1;
     size_t graph_max_degree = 64;
     float alpha = 1.2;
     size_t search_window_size = 10;
diff --git a/faiss/IndexSVSFlat.cpp b/faiss/IndexSVSFlat.cpp
index df8fa7d09..3e78fd44b 100644
--- a/faiss/IndexSVSFlat.cpp
+++ b/faiss/IndexSVSFlat.cpp
@@ -69,7 +69,8 @@ void IndexSVSFlat::search(
 
 void IndexSVSFlat::init_impl(idx_t n, const float* x) {
     auto data = svs::data::SimpleData<float>(n, d);
-    auto threadpool = svs::threads::as_threadpool(num_threads);
+    auto threadpool = svs::threads::ThreadPoolHandle(
+            svs::threads::OMPThreadPool(omp_get_max_threads()));
     ntotal = n;
 
     svs::threads::parallel_for(
@@ -113,7 +114,8 @@ void IndexSVSFlat::deserialize_impl(std::istream& in) {
     svs_io::SVSTempDirectory tmp;
     tmp.write_stream_to_files(in);
 
-    auto threadpool = svs::threads::as_threadpool(num_threads);
+    auto threadpool = svs::threads::ThreadPoolHandle(
+            svs::threads::OMPThreadPool(omp_get_max_threads()));
 
     switch (metric_type) {
         case METRIC_INNER_PRODUCT:
diff --git a/faiss/IndexSVSFlat.h b/faiss/IndexSVSFlat.h
index 75a391798..9afa93679 100644
--- a/faiss/IndexSVSFlat.h
+++ b/faiss/IndexSVSFlat.h
@@ -23,7 +23,6 @@ namespace faiss {
 struct IndexSVSFlat : Index {
     // sequential labels
     size_t nlabels{0};
-    size_t num_threads = 1;
 
     IndexSVSFlat() = default;
     IndexSVSFlat(idx_t d, MetricType metric = METRIC_L2);
diff --git a/faiss/IndexSVSLVQ.cpp b/faiss/IndexSVSLVQ.cpp
index 41f2c66c5..e655ab525 100644
--- a/faiss/IndexSVSLVQ.cpp
+++ b/faiss/IndexSVSLVQ.cpp
@@ -20,7 +20,8 @@ void IndexSVSLVQ::init_impl(idx_t n, const float* x) {
     const auto data =
             svs::data::SimpleDataView<float>(const_cast<float*>(x), n, d);
     std::vector<size_t> labels(n);
-    auto threadpool = svs::threads::as_threadpool(num_threads);
+    auto threadpool = svs::threads::ThreadPoolHandle(
+            svs::threads::OMPThreadPool(omp_get_max_threads()));
 
     std::variant<
             std::monostate,
@@ -107,6 +108,8 @@ void IndexSVSLVQ::deserialize_impl(std::istream& in) {
     // Write stream to files that can be read by DynamicVamana::assemble()
     svs_io::SVSTempDirectory tmp;
     tmp.write_stream_to_files(in);
+    auto threadpool = svs::threads::ThreadPoolHandle(
+            svs::threads::OMPThreadPool(omp_get_max_threads()));
 
     std::variant<svs::DistanceIP, svs::DistanceL2> svs_distance;
     switch (metric_type) {
@@ -132,7 +135,7 @@ void IndexSVSLVQ::deserialize_impl(std::istream& in) {
                                                 storage_type_4x0>(
                                                 tmp.data.string()),
                                         svs_distance,
-                                        num_threads));
+                                        std::move(threadpool)));
                         break;
                     case LVQLevel::LVQ_4x4:
                         impl = new svs::DynamicVamana(
@@ -143,7 +146,7 @@ void IndexSVSLVQ::deserialize_impl(std::istream& in) {
                                                 storage_type_4x4>(
                                                 tmp.data.string()),
                                         svs_distance,
-                                        num_threads));
+                                        std::move(threadpool)));
                         break;
                     case LVQLevel::LVQ_4x8:
                         impl = new svs::DynamicVamana(
@@ -154,7 +157,7 @@ void IndexSVSLVQ::deserialize_impl(std::istream& in) {
                                                 storage_type_4x8>(
                                                 tmp.data.string()),
                                         svs_distance,
-                                        num_threads));
+                                        std::move(threadpool)));
                         break;
                     default:
                         FAISS_ASSERT(!"not supported SVS LVQ level");
diff --git a/faiss/IndexSVSLeanVec.cpp b/faiss/IndexSVSLeanVec.cpp
index 7c6c03cfe..6d584e82a 100644
--- a/faiss/IndexSVSLeanVec.cpp
+++ b/faiss/IndexSVSLeanVec.cpp
@@ -29,7 +29,8 @@ IndexSVSLeanVec::IndexSVSLeanVec(
 void IndexSVSLeanVec::train(idx_t n, const float* x) {
     const auto data =
             svs::data::SimpleDataView<float>(const_cast<float*>(x), n, d);
-    auto threadpool = svs::threads::as_threadpool(num_threads);
+    auto threadpool = svs::threads::ThreadPoolHandle(
+            svs::threads::OMPThreadPool(omp_get_max_threads()));
     auto means = svs::utils::compute_medioid(data, threadpool);
     auto matrix =
             svs::leanvec::compute_leanvec_matrix<svs::Dynamic, svs::Dynamic>(
@@ -56,7 +57,8 @@ void IndexSVSLeanVec::init_impl(idx_t n, const float* x) {
     const auto data =
             svs::data::SimpleDataView<float>(const_cast<float*>(x), n, d);
     std::vector<size_t> labels(n);
-    auto threadpool = svs::threads::as_threadpool(num_threads);
+    auto threadpool = svs::threads::ThreadPoolHandle(
+            svs::threads::OMPThreadPool(omp_get_max_threads()));
 
     std::variant<
             std::monostate,
@@ -158,6 +160,8 @@ void IndexSVSLeanVec::deserialize_impl(std::istream& in) {
     // Write stream to files that can be read by DynamicVamana::assemble()
     svs_io::SVSTempDirectory tmp;
     tmp.write_stream_to_files(in);
+    auto threadpool = svs::threads::ThreadPoolHandle(
+            svs::threads::OMPThreadPool(omp_get_max_threads()));
 
     std::variant<svs::DistanceIP, svs::DistanceL2> svs_distance;
     switch (metric_type) {
@@ -183,7 +187,7 @@ void IndexSVSLeanVec::deserialize_impl(std::istream& in) {
                                                 storage_type_4x4>(
                                                 tmp.data.string()),
                                         svs_distance,
-                                        num_threads));
+                                        std::move(threadpool)));
                         break;
                     case LeanVecLevel::LeanVec_4x8:
                         impl = new svs::DynamicVamana(
@@ -194,7 +198,7 @@ void IndexSVSLeanVec::deserialize_impl(std::istream& in) {
                                                 storage_type_4x8>(
                                                 tmp.data.string()),
                                         svs_distance,
-                                        num_threads));
+                                        std::move(threadpool)));
                         break;
                     case LeanVecLevel::LeanVec_8x8:
                         impl = new svs::DynamicVamana(
@@ -205,7 +209,7 @@ void IndexSVSLeanVec::deserialize_impl(std::istream& in) {
                                                 storage_type_8x8>(
                                                 tmp.data.string()),
                                         svs_distance,
-                                        num_threads));
+                                        std::move(threadpool)));
                         break;
                     default:
                         FAISS_ASSERT(!"not supported SVS LVQ level");
diff --git a/faiss/impl/index_read.cpp b/faiss/impl/index_read.cpp
index 41e0be8e9..8b632330e 100644
--- a/faiss/impl/index_read.cpp
+++ b/faiss/impl/index_read.cpp
@@ -1262,7 +1262,6 @@ Index* read_index(IOReader* f, int io_flags) {
         }
 
         read_index_header(svs, f);
-        READ1(svs->num_threads);
         READ1(svs->graph_max_degree);
         READ1(svs->alpha);
         READ1(svs->search_window_size);
@@ -1288,7 +1287,6 @@ Index* read_index(IOReader* f, int io_flags) {
         // SVS Flat
         IndexSVSFlat* svs = new IndexSVSFlat();
         read_index_header(svs, f);
-        READ1(svs->num_threads);
 
         faiss::BufferedIOReader br(f);
         faiss::svs_io::ReaderStreambuf rbuf(&br);
diff --git a/faiss/impl/index_write.cpp b/faiss/impl/index_write.cpp
index a977c4908..b825b26e4 100644
--- a/faiss/impl/index_write.cpp
+++ b/faiss/impl/index_write.cpp
@@ -912,7 +912,6 @@ void write_index(const Index* idx, IOWriter* f, int io_flags) {
 
         WRITE1(h);
         write_index_header(svs, f);
-        WRITE1(svs->num_threads);
         WRITE1(svs->graph_max_degree);
         WRITE1(svs->alpha);
         WRITE1(svs->search_window_size);
@@ -941,7 +940,6 @@ void write_index(const Index* idx, IOWriter* f, int io_flags) {
         uint32_t h = fourcc("ISVF");
         WRITE1(h);
         write_index_header(idx, f);
-        WRITE1(svs->num_threads);
 
         // payload (stream to file)
         faiss::BufferedIOWriter bwr(f);
diff --git a/tutorial/python/10-SVS.py b/tutorial/python/10-SVS.py
index 85c19dd69..ea594043a 100644
--- a/tutorial/python/10-SVS.py
+++ b/tutorial/python/10-SVS.py
@@ -16,7 +16,6 @@ xq[:, 0] += np.arange(nq) / 1000.
 
 import faiss                        # make faiss available
 index = faiss.IndexSVS(d)           # build the index (DynamicVamana, float32)
-index.num_threads = 72
 
 # index = faiss.IndexSVSFlat(d)     # build the SVSFlat index
 # index = faiss.IndexSVSLVQ(d)      # build the SVSLVQ index, quantization parameters
-- 
2.39.5 (Apple Git-154)


From 00dd505e6e65c7f7c01c580c2d8a9144b046d8c9 Mon Sep 17 00:00:00 2001
From: Andreas Huber <andreas.huber@intel.com>
Date: Mon, 18 Aug 2025 03:22:15 -0700
Subject: [PATCH 35/38] fix tests

---
 tests/test_svs.cpp | 2 --
 tests/test_svs.py  | 8 --------
 2 files changed, 10 deletions(-)

diff --git a/tests/test_svs.cpp b/tests/test_svs.cpp
index 432bfdafa..f3638f416 100644
--- a/tests/test_svs.cpp
+++ b/tests/test_svs.cpp
@@ -66,7 +66,6 @@ void write_and_read_index(T& index, const std::vector<float>& xb, size_t n) {
     ASSERT_NE(loaded->impl, nullptr);
     EXPECT_EQ(loaded->d, index.d);
     EXPECT_EQ(loaded->metric_type, index.metric_type);
-    EXPECT_EQ(loaded->num_threads, index.num_threads);
     EXPECT_EQ(loaded->graph_max_degree, index.graph_max_degree);
     EXPECT_EQ(loaded->alpha, index.alpha);
     EXPECT_EQ(loaded->search_window_size, index.search_window_size);
@@ -158,7 +157,6 @@ TEST_F(SVSIOTest, WriteAndReadIndexSVSFlat) {
     EXPECT_EQ(loaded->d, index.d);
     EXPECT_EQ(loaded->nlabels, index.nlabels);
     EXPECT_EQ(loaded->metric_type, index.metric_type);
-    EXPECT_EQ(loaded->num_threads, index.num_threads);
 
     delete loaded;
 }
diff --git a/tests/test_svs.py b/tests/test_svs.py
index 11ca2c22e..09b8dbfe9 100644
--- a/tests/test_svs.py
+++ b/tests/test_svs.py
@@ -80,8 +80,6 @@ class TestSVSAdapter(unittest.TestCase):
         """Test FAISS serialization system works with SVS indices"""
         index = self._create_instance()
 
-        index.num_threads = 2
-
         index.add(self.xb)
         D_before, I_before = index.search(self.xq, 4)
 
@@ -94,7 +92,6 @@ class TestSVSAdapter(unittest.TestCase):
         self.assertEqual(loaded.d, self.d)
         self.assertEqual(loaded.ntotal, self.nb)
         self.assertEqual(loaded.metric_type, index.metric_type)
-        self.assertEqual(loaded.num_threads, index.num_threads)
 
         # Verify functionality is preserved
         D_after, I_after = loaded.search(self.xq, 4)
@@ -211,7 +208,6 @@ class TestSVSVamanaParameters(unittest.TestCase):
         index = self._create_instance()
 
         # Set non-default values for all parameters
-        index.num_threads = 4
         index.graph_max_degree = 32
         index.alpha = 1.5
         index.search_window_size = 20
@@ -222,7 +218,6 @@ class TestSVSVamanaParameters(unittest.TestCase):
         index.use_full_search_history = False
 
         # Verify all parameters are set correctly
-        self.assertEqual(index.num_threads, 4)
         self.assertEqual(index.graph_max_degree, 32)
         self.assertAlmostEqual(index.alpha, 1.5, places=6)
         self.assertEqual(index.search_window_size, 20)
@@ -237,7 +232,6 @@ class TestSVSVamanaParameters(unittest.TestCase):
         index = self._create_instance()
 
         # Verify default values match C++ header
-        self.assertEqual(index.num_threads, 1)
         self.assertEqual(index.graph_max_degree, 64)
         self.assertAlmostEqual(index.alpha, 1.2, places=6)
         self.assertEqual(index.search_window_size, 10)
@@ -252,7 +246,6 @@ class TestSVSVamanaParameters(unittest.TestCase):
         index = self._create_instance()
 
         # Set distinctive non-default values
-        index.num_threads = 8
         index.graph_max_degree = 48
         index.alpha = 1.8
         index.search_window_size = 15
@@ -272,7 +265,6 @@ class TestSVSVamanaParameters(unittest.TestCase):
 
         # Verify all parameters are preserved
         self.assertIsInstance(loaded, self.target_class)
-        self.assertEqual(loaded.num_threads, 8)
         self.assertEqual(loaded.graph_max_degree, 48)
         self.assertAlmostEqual(loaded.alpha, 1.8, places=6)
         self.assertEqual(loaded.search_window_size, 15)
-- 
2.39.5 (Apple Git-154)


From 4f83fd07c9c50efbca622ef0ff4655feaec5b71a Mon Sep 17 00:00:00 2001
From: Andreas Huber <andreas.huber@intel.com>
Date: Tue, 19 Aug 2025 08:08:52 -0700
Subject: [PATCH 36/38] fix avx and sve builds

---
 faiss/CMakeLists.txt | 16 ++++++++++++++++
 1 file changed, 16 insertions(+)

diff --git a/faiss/CMakeLists.txt b/faiss/CMakeLists.txt
index d1b05e14f..a9cef2274 100644
--- a/faiss/CMakeLists.txt
+++ b/faiss/CMakeLists.txt
@@ -352,6 +352,10 @@ if(FAISS_ENABLE_SVS)
   target_compile_options(svs::svs INTERFACE "-DSVS_ENABLE_OMP=1")
 
   target_link_libraries(faiss PUBLIC svs::svs svs::svs_shared_library)
+  target_link_libraries(faiss_avx2 PUBLIC svs::svs svs::svs_shared_library)
+  target_link_libraries(faiss_avx512 PUBLIC svs::svs svs::svs_shared_library)
+  target_link_libraries(faiss_avx512_spr PUBLIC svs::svs svs::svs_shared_library)
+  target_link_libraries(faiss_sve PUBLIC svs::svs svs::svs_shared_library)
 endif()
 
 # Handle `#include <faiss/foo.h>`.
@@ -373,6 +377,18 @@ if(FAISS_ENABLE_SVS)
   # Handle `#include <svs/foo.h>`.
   target_include_directories(faiss PUBLIC
     $<BUILD_INTERFACE:${svs_SOURCE_DIR}/include>)
+  # Handle `#include <svs/foo.h>`.
+  target_include_directories(faiss_avx2 PUBLIC
+    $<BUILD_INTERFACE:${svs_SOURCE_DIR}/include>)
+  # Handle `#include <svs/foo.h>`.
+  target_include_directories(faiss_avx512 PUBLIC
+    $<BUILD_INTERFACE:${svs_SOURCE_DIR}/include>)
+  # Handle `#include <svs/foo.h>`.
+  target_include_directories(faiss_avx512_spr PUBLIC
+    $<BUILD_INTERFACE:${svs_SOURCE_DIR}/include>)
+  # Handle `#include <svs/foo.h>`.
+  target_include_directories(faiss_sve PUBLIC
+    $<BUILD_INTERFACE:${svs_SOURCE_DIR}/include>)
 endif()
 
 set_target_properties(faiss faiss_avx2 faiss_avx512 faiss_avx512_spr faiss_sve PROPERTIES
-- 
2.39.5 (Apple Git-154)


From d264256dd2fa67cfc9e1800fcd1954549e8ea7eb Mon Sep 17 00:00:00 2001
From: Aaron Lin <aaron.dl.lin@intel.com>
Date: Wed, 20 Aug 2025 14:42:15 -0700
Subject: [PATCH 37/38] update svs version for omp bug fix

---
 faiss/CMakeLists.txt | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/faiss/CMakeLists.txt b/faiss/CMakeLists.txt
index a9cef2274..f6b70538f 100644
--- a/faiss/CMakeLists.txt
+++ b/faiss/CMakeLists.txt
@@ -341,7 +341,7 @@ endif()
 
 if(FAISS_ENABLE_SVS)
   include(FetchContent)
-  set(SVS_URL "https://github.com/intel/ScalableVectorSearch/releases/download/v0.0.8-dev/svs-shared-library-0.0.8-20250815.tar.gz")
+  set(SVS_URL "https://github.com/intel/ScalableVectorSearch/releases/download/v1.0.0-dev/svs-shared-library-1.0.0-NIGHTLY-20250820.tar.gz")
   FetchContent_Declare(
       svs
       URL "${SVS_URL}"
-- 
2.39.5 (Apple Git-154)


From 32d5063840011ba56ccf76b0bd88fc78d3d0e2e5 Mon Sep 17 00:00:00 2001
From: Aaron Lin <aaron.dl.lin@intel.com>
Date: Thu, 21 Aug 2025 14:35:01 -0700
Subject: [PATCH 38/38] support svs factory format

---
 faiss/CMakeLists.txt                          |  12 +-
 faiss/{IndexSVS.cpp => IndexSVSVamana.cpp}    |  22 +--
 faiss/{IndexSVS.h => IndexSVSVamana.h}        |  12 +-
 ...{IndexSVSLVQ.cpp => IndexSVSVamanaLVQ.cpp} |  26 ++--
 faiss/{IndexSVSLVQ.h => IndexSVSVamanaLVQ.h}  |  15 +-
 ...SLeanVec.cpp => IndexSVSVamanaLeanVec.cpp} |  29 ++--
 ...exSVSLeanVec.h => IndexSVSVamanaLeanVec.h} |  15 +-
 faiss/impl/index_read.cpp                     |  22 +--
 faiss/impl/index_write.cpp                    |  14 +-
 faiss/impl/svs_io.cpp                         |   2 +-
 faiss/index_factory.cpp                       | 129 ++++++++++++------
 faiss/python/__init__.py                      |   2 +-
 faiss/python/swigfaiss.swig                   |  18 +--
 tests/test_svs.cpp                            |  42 +++---
 .../cpp/{10-SVS.cpp => 10-SVS-Vamana.cpp}     |   6 +-
 .../{11-SVSLVQ.cpp => 11-SVS-Vamana-LVQ.cpp}  |   4 +-
 ...SLeanVec.cpp => 12-SVS-Vamana-LeanVec.cpp} |   4 +-
 tutorial/cpp/CMakeLists.txt                   |  12 +-
 tutorial/python/10-SVS.py                     |  31 +++--
 19 files changed, 244 insertions(+), 173 deletions(-)
 rename faiss/{IndexSVS.cpp => IndexSVSVamana.cpp} (89%)
 rename faiss/{IndexSVS.h => IndexSVSVamana.h} (85%)
 rename faiss/{IndexSVSLVQ.cpp => IndexSVSVamanaLVQ.cpp} (91%)
 rename faiss/{IndexSVSLVQ.h => IndexSVSVamanaLVQ.h} (77%)
 rename faiss/{IndexSVSLeanVec.cpp => IndexSVSVamanaLeanVec.cpp} (91%)
 rename faiss/{IndexSVSLeanVec.h => IndexSVSVamanaLeanVec.h} (80%)
 rename tutorial/cpp/{10-SVS.cpp => 10-SVS-Vamana.cpp} (94%)
 rename tutorial/cpp/{11-SVSLVQ.cpp => 11-SVS-Vamana-LVQ.cpp} (95%)
 rename tutorial/cpp/{12-SVSLeanVec.cpp => 12-SVS-Vamana-LeanVec.cpp} (94%)

diff --git a/faiss/CMakeLists.txt b/faiss/CMakeLists.txt
index f6b70538f..932bc0178 100644
--- a/faiss/CMakeLists.txt
+++ b/faiss/CMakeLists.txt
@@ -103,9 +103,9 @@ set(FAISS_SRC
 if(FAISS_ENABLE_SVS)
   list(APPEND FAISS_SRC
     IndexSVSFlat.cpp
-    IndexSVS.cpp
-    IndexSVSLVQ.cpp
-    IndexSVSLeanVec.cpp
+    IndexSVSVamana.cpp
+    IndexSVSVamanaLVQ.cpp
+    IndexSVSVamanaLeanVec.cpp
     impl/svs_io.cpp
   )
 endif()
@@ -254,9 +254,9 @@ set(FAISS_HEADERS
 if(FAISS_ENABLE_SVS)
   list(APPEND FAISS_HEADERS
     IndexSVSFlat.h
-    IndexSVS.h
-    IndexSVSLVQ.h
-    IndexSVSLeanVec.h
+    IndexSVSVamana.h
+    IndexSVSVamanaLVQ.h
+    IndexSVSVamanaLeanVec.h
   )
 endif()
 
diff --git a/faiss/IndexSVS.cpp b/faiss/IndexSVSVamana.cpp
similarity index 89%
rename from faiss/IndexSVS.cpp
rename to faiss/IndexSVSVamana.cpp
index 8d67d9f28..fae3368eb 100644
--- a/faiss/IndexSVS.cpp
+++ b/faiss/IndexSVSVamana.cpp
@@ -5,7 +5,7 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/IndexSVS.h>
+#include <faiss/IndexSVSVamana.h>
 
 #include <svs/core/data.h>
 #include <svs/orchestrators/dynamic_vamana.h>
@@ -14,20 +14,22 @@
 
 namespace faiss {
 
-IndexSVS::IndexSVS() : Index{} {}
+IndexSVSVamana::IndexSVSVamana() : Index{} {}
 
-IndexSVS::IndexSVS(idx_t d, MetricType metric) : Index(d, metric) {
+IndexSVSVamana::IndexSVSVamana(idx_t d, size_t degree, MetricType metric)
+        : Index(d, metric), graph_max_degree{degree} {
+    prune_to = graph_max_degree < 4 ? graph_max_degree : graph_max_degree - 4;
     alpha = metric == METRIC_L2 ? 1.2f : 0.95f;
 }
 
-IndexSVS::~IndexSVS() {
+IndexSVSVamana::~IndexSVSVamana() {
     if (impl) {
         delete impl;
         impl = nullptr;
     }
 }
 
-void IndexSVS::add(idx_t n, const float* x) {
+void IndexSVSVamana::add(idx_t n, const float* x) {
     if (!impl) {
         init_impl(n, x);
         return;
@@ -50,7 +52,7 @@ void IndexSVS::add(idx_t n, const float* x) {
     impl->add_points(data, labels);
 }
 
-void IndexSVS::reset() {
+void IndexSVSVamana::reset() {
     if (impl) {
         delete impl;
         impl = nullptr;
@@ -58,7 +60,7 @@ void IndexSVS::reset() {
     ntotal = 0;
 }
 
-void IndexSVS::search(
+void IndexSVSVamana::search(
         idx_t n,
         const float* x,
         idx_t k,
@@ -83,7 +85,7 @@ void IndexSVS::search(
     impl->search(results, queries, sp);
 }
 
-void IndexSVS::init_impl(idx_t n, const float* x) {
+void IndexSVSVamana::init_impl(idx_t n, const float* x) {
     std::vector<size_t> labels(n);
     auto data = svs::data::SimpleData<float>(n, d);
     auto threadpool = svs::threads::ThreadPoolHandle(
@@ -130,7 +132,7 @@ void IndexSVS::init_impl(idx_t n, const float* x) {
     }
 }
 
-void IndexSVS::serialize_impl(std::ostream& out) const {
+void IndexSVSVamana::serialize_impl(std::ostream& out) const {
     FAISS_THROW_IF_NOT_MSG(
             impl, "Cannot serialize: SVS index not initialized.");
 
@@ -140,7 +142,7 @@ void IndexSVS::serialize_impl(std::ostream& out) const {
     tmp.write_files_to_stream(out);
 }
 
-void IndexSVS::deserialize_impl(std::istream& in) {
+void IndexSVSVamana::deserialize_impl(std::istream& in) {
     FAISS_THROW_IF_MSG(
             impl, "Cannot deserialize: SVS index already initialized.");
 
diff --git a/faiss/IndexSVS.h b/faiss/IndexSVSVamana.h
similarity index 85%
rename from faiss/IndexSVS.h
rename to faiss/IndexSVSVamana.h
index 3f3377ece..1a9e1a61f 100644
--- a/faiss/IndexSVS.h
+++ b/faiss/IndexSVSVamana.h
@@ -20,21 +20,21 @@ class DynamicVamana;
 
 namespace faiss {
 
-struct IndexSVS : Index {
-    size_t graph_max_degree = 64;
+struct IndexSVSVamana : Index {
+    size_t graph_max_degree;
+    size_t prune_to;
     float alpha = 1.2;
     size_t search_window_size = 10;
     size_t search_buffer_capacity = 10;
     size_t construction_window_size = 40;
     size_t max_candidate_pool_size = 200;
-    size_t prune_to = 60;
     bool use_full_search_history = true;
 
-    IndexSVS();
+    IndexSVSVamana();
 
-    IndexSVS(idx_t d, MetricType metric = METRIC_L2);
+    IndexSVSVamana(idx_t d, size_t degree, MetricType metric = METRIC_L2);
 
-    virtual ~IndexSVS() override;
+    virtual ~IndexSVSVamana() override;
 
     void add(idx_t n, const float* x) override;
 
diff --git a/faiss/IndexSVSLVQ.cpp b/faiss/IndexSVSVamanaLVQ.cpp
similarity index 91%
rename from faiss/IndexSVSLVQ.cpp
rename to faiss/IndexSVSVamanaLVQ.cpp
index e655ab525..be663cf8a 100644
--- a/faiss/IndexSVSLVQ.cpp
+++ b/faiss/IndexSVSVamanaLVQ.cpp
@@ -5,17 +5,21 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/IndexSVSLVQ.h>
+#include <faiss/IndexSVSVamanaLVQ.h>
 
 #include <variant>
 
 #include <svs/orchestrators/dynamic_vamana.h>
 namespace faiss {
 
-IndexSVSLVQ::IndexSVSLVQ(idx_t d, MetricType metric, LVQLevel lvq_level)
-        : IndexSVS(d, metric), lvq_level{lvq_level} {}
+IndexSVSVamanaLVQ::IndexSVSVamanaLVQ(
+        idx_t d,
+        size_t degree,
+        MetricType metric,
+        LVQLevel lvq_level)
+        : IndexSVSVamana(d, degree, metric), lvq_level{lvq_level} {}
 
-void IndexSVSLVQ::init_impl(idx_t n, const float* x) {
+void IndexSVSVamanaLVQ::init_impl(idx_t n, const float* x) {
     // TODO: support ConstSimpleDataView in SVS shared/static lib
     const auto data =
             svs::data::SimpleDataView<float>(const_cast<float*>(x), n, d);
@@ -31,15 +35,15 @@ void IndexSVSLVQ::init_impl(idx_t n, const float* x) {
             compressed_data;
 
     switch (lvq_level) {
-        case LVQLevel::LVQ_4x0:
+        case LVQLevel::LVQ4x0:
             compressed_data = storage_type_4x0::compress(
                     data, threadpool, 0, blocked_alloc_type{});
             break;
-        case LVQLevel::LVQ_4x4:
+        case LVQLevel::LVQ4x4:
             compressed_data = storage_type_4x4::compress(
                     data, threadpool, 0, blocked_alloc_type{});
             break;
-        case LVQLevel::LVQ_4x8:
+        case LVQLevel::LVQ4x8:
             compressed_data = storage_type_4x8::compress(
                     data, threadpool, 0, blocked_alloc_type{});
             break;
@@ -101,7 +105,7 @@ void IndexSVSLVQ::init_impl(idx_t n, const float* x) {
             compressed_data);
 }
 
-void IndexSVSLVQ::deserialize_impl(std::istream& in) {
+void IndexSVSVamanaLVQ::deserialize_impl(std::istream& in) {
     FAISS_THROW_IF_MSG(
             impl, "Cannot deserialize: SVS index already initialized.");
 
@@ -126,7 +130,7 @@ void IndexSVSLVQ::deserialize_impl(std::istream& in) {
     std::visit(
             [&](auto&& svs_distance) {
                 switch (lvq_level) {
-                    case LVQLevel::LVQ_4x0:
+                    case LVQLevel::LVQ4x0:
                         impl = new svs::DynamicVamana(
                                 svs::DynamicVamana::assemble<float>(
                                         tmp.config.string(),
@@ -137,7 +141,7 @@ void IndexSVSLVQ::deserialize_impl(std::istream& in) {
                                         svs_distance,
                                         std::move(threadpool)));
                         break;
-                    case LVQLevel::LVQ_4x4:
+                    case LVQLevel::LVQ4x4:
                         impl = new svs::DynamicVamana(
                                 svs::DynamicVamana::assemble<float>(
                                         tmp.config.string(),
@@ -148,7 +152,7 @@ void IndexSVSLVQ::deserialize_impl(std::istream& in) {
                                         svs_distance,
                                         std::move(threadpool)));
                         break;
-                    case LVQLevel::LVQ_4x8:
+                    case LVQLevel::LVQ4x8:
                         impl = new svs::DynamicVamana(
                                 svs::DynamicVamana::assemble<float>(
                                         tmp.config.string(),
diff --git a/faiss/IndexSVSLVQ.h b/faiss/IndexSVSVamanaLVQ.h
similarity index 77%
rename from faiss/IndexSVSLVQ.h
rename to faiss/IndexSVSVamanaLVQ.h
index 90b150e1f..c05e57095 100644
--- a/faiss/IndexSVSLVQ.h
+++ b/faiss/IndexSVSVamanaLVQ.h
@@ -7,15 +7,15 @@
 
 #pragma once
 
-#include <faiss/IndexSVS.h>
+#include <faiss/IndexSVSVamana.h>
 
 #include <svs/extensions/vamana/lvq.h>
 
 namespace faiss {
 
-enum LVQLevel { LVQ_4x0, LVQ_4x4, LVQ_4x8 };
+enum LVQLevel { LVQ4x0, LVQ4x4, LVQ4x8 };
 
-struct IndexSVSLVQ : IndexSVS {
+struct IndexSVSVamanaLVQ : IndexSVSVamana {
     using blocked_alloc_type =
             svs::data::Blocked<svs::lib::Allocator<std::byte>>;
 
@@ -28,13 +28,14 @@ struct IndexSVSLVQ : IndexSVS {
     using storage_type_4x8 = svs::quantization::lvq::
             LVQDataset<4, 8, svs::Dynamic, strategy_type_4, blocked_alloc_type>;
 
-    IndexSVSLVQ() = default;
-    IndexSVSLVQ(
+    IndexSVSVamanaLVQ() = default;
+    IndexSVSVamanaLVQ(
             idx_t d,
+            size_t degree,
             MetricType metric = METRIC_L2,
-            LVQLevel lvq_level = LVQLevel::LVQ_4x4);
+            LVQLevel lvq_level = LVQLevel::LVQ4x4);
 
-    ~IndexSVSLVQ() override = default;
+    ~IndexSVSVamanaLVQ() override = default;
 
     void init_impl(idx_t n, const float* x) override;
 
diff --git a/faiss/IndexSVSLeanVec.cpp b/faiss/IndexSVSVamanaLeanVec.cpp
similarity index 91%
rename from faiss/IndexSVSLeanVec.cpp
rename to faiss/IndexSVSVamanaLeanVec.cpp
index 6d584e82a..22953abee 100644
--- a/faiss/IndexSVSLeanVec.cpp
+++ b/faiss/IndexSVSVamanaLeanVec.cpp
@@ -5,7 +5,7 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/IndexSVSLeanVec.h>
+#include <faiss/IndexSVSVamanaLeanVec.h>
 
 #include <variant>
 
@@ -16,17 +16,18 @@
 
 namespace faiss {
 
-IndexSVSLeanVec::IndexSVSLeanVec(
+IndexSVSVamanaLeanVec::IndexSVSVamanaLeanVec(
         idx_t d,
+        size_t degree,
         MetricType metric,
         size_t leanvec_dims,
         LeanVecLevel leanvec_level)
-        : IndexSVS(d, metric), leanvec_level{leanvec_level} {
+        : IndexSVSVamana(d, degree, metric), leanvec_level{leanvec_level} {
     leanvec_d = leanvec_dims == 0 ? d / 2 : leanvec_dims;
     is_trained = false;
 }
 
-void IndexSVSLeanVec::train(idx_t n, const float* x) {
+void IndexSVSVamanaLeanVec::train(idx_t n, const float* x) {
     const auto data =
             svs::data::SimpleDataView<float>(const_cast<float*>(x), n, d);
     auto threadpool = svs::threads::ThreadPoolHandle(
@@ -43,12 +44,12 @@ void IndexSVSLeanVec::train(idx_t n, const float* x) {
     is_trained = true;
 }
 
-void IndexSVSLeanVec::reset() {
+void IndexSVSVamanaLeanVec::reset() {
     is_trained = false;
-    IndexSVS::reset();
+    IndexSVSVamana::reset();
 }
 
-void IndexSVSLeanVec::init_impl(idx_t n, const float* x) {
+void IndexSVSVamanaLeanVec::init_impl(idx_t n, const float* x) {
     FAISS_THROW_IF_NOT_MSG(
             is_trained,
             "Cannot initialize SVS LeanVec index without training first.");
@@ -68,7 +69,7 @@ void IndexSVSLeanVec::init_impl(idx_t n, const float* x) {
             compressed_data;
 
     switch (leanvec_level) {
-        case LeanVecLevel::LeanVec_4x4:
+        case LeanVecLevel::LeanVec4x4:
             compressed_data = storage_type_4x4::reduce(
                     data,
                     leanvec_matrix,
@@ -77,7 +78,7 @@ void IndexSVSLeanVec::init_impl(idx_t n, const float* x) {
                     svs::lib::MaybeStatic<svs::Dynamic>(leanvec_d),
                     blocked_alloc_type{});
             break;
-        case LeanVecLevel::LeanVec_4x8:
+        case LeanVecLevel::LeanVec4x8:
             compressed_data = storage_type_4x8::reduce(
                     data,
                     leanvec_matrix,
@@ -86,7 +87,7 @@ void IndexSVSLeanVec::init_impl(idx_t n, const float* x) {
                     svs::lib::MaybeStatic<svs::Dynamic>(leanvec_d),
                     blocked_alloc_type{});
             break;
-        case LeanVecLevel::LeanVec_8x8:
+        case LeanVecLevel::LeanVec8x8:
             compressed_data = storage_type_8x8::reduce(
                     data,
                     leanvec_matrix,
@@ -153,7 +154,7 @@ void IndexSVSLeanVec::init_impl(idx_t n, const float* x) {
             compressed_data);
 }
 
-void IndexSVSLeanVec::deserialize_impl(std::istream& in) {
+void IndexSVSVamanaLeanVec::deserialize_impl(std::istream& in) {
     FAISS_THROW_IF_MSG(
             impl, "Cannot deserialize: SVS index already initialized.");
 
@@ -178,7 +179,7 @@ void IndexSVSLeanVec::deserialize_impl(std::istream& in) {
     std::visit(
             [&](auto&& svs_distance) {
                 switch (leanvec_level) {
-                    case LeanVecLevel::LeanVec_4x4:
+                    case LeanVecLevel::LeanVec4x4:
                         impl = new svs::DynamicVamana(
                                 svs::DynamicVamana::assemble<float>(
                                         tmp.config.string(),
@@ -189,7 +190,7 @@ void IndexSVSLeanVec::deserialize_impl(std::istream& in) {
                                         svs_distance,
                                         std::move(threadpool)));
                         break;
-                    case LeanVecLevel::LeanVec_4x8:
+                    case LeanVecLevel::LeanVec4x8:
                         impl = new svs::DynamicVamana(
                                 svs::DynamicVamana::assemble<float>(
                                         tmp.config.string(),
@@ -200,7 +201,7 @@ void IndexSVSLeanVec::deserialize_impl(std::istream& in) {
                                         svs_distance,
                                         std::move(threadpool)));
                         break;
-                    case LeanVecLevel::LeanVec_8x8:
+                    case LeanVecLevel::LeanVec8x8:
                         impl = new svs::DynamicVamana(
                                 svs::DynamicVamana::assemble<float>(
                                         tmp.config.string(),
diff --git a/faiss/IndexSVSLeanVec.h b/faiss/IndexSVSVamanaLeanVec.h
similarity index 80%
rename from faiss/IndexSVSLeanVec.h
rename to faiss/IndexSVSVamanaLeanVec.h
index 9c5eccab1..f7d7d780c 100644
--- a/faiss/IndexSVSLeanVec.h
+++ b/faiss/IndexSVSVamanaLeanVec.h
@@ -7,15 +7,15 @@
 
 #pragma once
 
-#include <faiss/IndexSVS.h>
+#include <faiss/IndexSVSVamana.h>
 
 #include <svs/extensions/vamana/leanvec.h>
 
 namespace faiss {
 
-enum LeanVecLevel { LeanVec_4x4, LeanVec_4x8, LeanVec_8x8 };
+enum LeanVecLevel { LeanVec4x4, LeanVec4x8, LeanVec8x8 };
 
-struct IndexSVSLeanVec : IndexSVS {
+struct IndexSVSVamanaLeanVec : IndexSVSVamana {
     using blocked_alloc_type =
             svs::data::Blocked<svs::lib::Allocator<std::byte>>;
     using storage_type_4x4 = svs::leanvec::LeanDataset<
@@ -37,15 +37,16 @@ struct IndexSVSLeanVec : IndexSVS {
             svs::Dynamic,
             blocked_alloc_type>;
 
-    IndexSVSLeanVec() = default;
+    IndexSVSVamanaLeanVec() = default;
 
-    IndexSVSLeanVec(
+    IndexSVSVamanaLeanVec(
             idx_t d,
+            size_t degree,
             MetricType metric = METRIC_L2,
             size_t leanvec_dims = 0,
-            LeanVecLevel leanvec_level = LeanVecLevel::LeanVec_4x4);
+            LeanVecLevel leanvec_level = LeanVecLevel::LeanVec4x4);
 
-    ~IndexSVSLeanVec() override = default;
+    ~IndexSVSVamanaLeanVec() override = default;
 
     void reset() override;
 
diff --git a/faiss/impl/index_read.cpp b/faiss/impl/index_read.cpp
index 8b632330e..5e33baa61 100644
--- a/faiss/impl/index_read.cpp
+++ b/faiss/impl/index_read.cpp
@@ -46,10 +46,10 @@
 #include <faiss/IndexRefine.h>
 #include <faiss/IndexRowwiseMinMax.h>
 #ifdef FAISS_ENABLE_SVS
-#include <faiss/IndexSVS.h>
 #include <faiss/IndexSVSFlat.h>
-#include <faiss/IndexSVSLVQ.h>
-#include <faiss/IndexSVSLeanVec.h>
+#include <faiss/IndexSVSVamana.h>
+#include <faiss/IndexSVSVamanaLVQ.h>
+#include <faiss/IndexSVSVamanaLeanVec.h>
 #endif
 #include <faiss/IndexScalarQuantizer.h>
 #include <faiss/MetaIndexes.h>
@@ -1252,13 +1252,15 @@ Index* read_index(IOReader* f, int io_flags) {
 #ifdef FAISS_ENABLE_SVS
     else if (
             h == fourcc("ILVQ") || h == fourcc("ISVL") || h == fourcc("ISVD")) {
-        IndexSVS* svs;
+        // Vamana
+        IndexSVSVamana* svs;
         if (h == fourcc("ILVQ")) {
-            svs = new IndexSVSLVQ(); // LVQ
+            svs = new IndexSVSVamanaLVQ(); // Vamana LVQ
         } else if (h == fourcc("ISVL")) {
-            svs = new IndexSVSLeanVec(); // LeanVec
+            svs = new IndexSVSVamanaLeanVec(); // Vamana LeanVec
         } else if (h == fourcc("ISVD")) {
-            svs = new IndexSVS(); // uncompressed
+            svs = new IndexSVSVamana(); // public SVS datatypes including fp32,
+                                        // fp16, and SQ8
         }
 
         read_index_header(svs, f);
@@ -1271,11 +1273,11 @@ Index* read_index(IOReader* f, int io_flags) {
         READ1(svs->prune_to);
         READ1(svs->use_full_search_history);
         if (h == fourcc("ILVQ")) {
-            READ1(dynamic_cast<IndexSVSLVQ*>(svs)->lvq_level);
+            READ1(dynamic_cast<IndexSVSVamanaLVQ*>(svs)->lvq_level);
         }
         if (h == fourcc("ISVL")) {
-            READ1(dynamic_cast<IndexSVSLeanVec*>(svs)->leanvec_d);
-            READ1(dynamic_cast<IndexSVSLeanVec*>(svs)->leanvec_level);
+            READ1(dynamic_cast<IndexSVSVamanaLeanVec*>(svs)->leanvec_d);
+            READ1(dynamic_cast<IndexSVSVamanaLeanVec*>(svs)->leanvec_level);
         }
 
         faiss::BufferedIOReader br(f);
diff --git a/faiss/impl/index_write.cpp b/faiss/impl/index_write.cpp
index b825b26e4..b16a6d532 100644
--- a/faiss/impl/index_write.cpp
+++ b/faiss/impl/index_write.cpp
@@ -44,10 +44,10 @@
 #include <faiss/IndexRefine.h>
 #include <faiss/IndexRowwiseMinMax.h>
 #ifdef FAISS_ENABLE_SVS
-#include <faiss/IndexSVS.h>
 #include <faiss/IndexSVSFlat.h>
-#include <faiss/IndexSVSLVQ.h>
-#include <faiss/IndexSVSLeanVec.h>
+#include <faiss/IndexSVSVamana.h>
+#include <faiss/IndexSVSVamanaLVQ.h>
+#include <faiss/IndexSVSVamanaLeanVec.h>
 #endif
 #include <faiss/IndexScalarQuantizer.h>
 #include <faiss/MetaIndexes.h>
@@ -889,7 +889,9 @@ void write_index(const Index* idx, IOWriter* f, int io_flags) {
         write_InvertedLists(ivrq->invlists, f);
     }
 #ifdef FAISS_ENABLE_SVS
-    else if (const IndexSVS* svs = dynamic_cast<const IndexSVS*>(idx)) {
+    else if (
+            const IndexSVSVamana* svs =
+                    dynamic_cast<const IndexSVSVamana*>(idx)) {
         // The SVS implementation will write its contents to three directories,
         // which we will read back here for writing to the actual output file.
         // To avoid a full copy of the index in memory, we stream chunks.
@@ -900,8 +902,8 @@ void write_index(const Index* idx, IOWriter* f, int io_flags) {
         // assume EOF means end of binary SVS blobl.
 
         uint32_t h;
-        auto* lvq = dynamic_cast<const IndexSVSLVQ*>(svs);
-        auto* lean = dynamic_cast<const IndexSVSLeanVec*>(svs);
+        auto* lvq = dynamic_cast<const IndexSVSVamanaLVQ*>(svs);
+        auto* lean = dynamic_cast<const IndexSVSVamanaLeanVec*>(svs);
         if (lvq != nullptr) {
             h = fourcc("ILVQ"); // LVQ
         } else if (lean != nullptr) {
diff --git a/faiss/impl/svs_io.cpp b/faiss/impl/svs_io.cpp
index cc4cc9798..bbf9621e3 100644
--- a/faiss/impl/svs_io.cpp
+++ b/faiss/impl/svs_io.cpp
@@ -48,7 +48,7 @@ std::streambuf::int_type ReaderStreambuf::underflow() {
     }
     size_t got = (*r)(buf.data(), 1, buf.size());
     if (got == 0) {
-        return traits_type::eof(); 
+        return traits_type::eof();
     }
     setg(buf.data(), buf.data(), buf.data() + got);
     return traits_type::to_int_type(*gptr());
diff --git a/faiss/index_factory.cpp b/faiss/index_factory.cpp
index 900a9a431..0dea6d56d 100644
--- a/faiss/index_factory.cpp
+++ b/faiss/index_factory.cpp
@@ -51,9 +51,10 @@
 #include <faiss/IndexBinaryIVF.h>
 
 #ifdef FAISS_ENABLE_SVS
-#include <faiss/IndexSVS.h>
-#include <faiss/IndexSVSLVQ.h>
-#include <faiss/IndexSVSLeanVec.h>
+#include <faiss/IndexSVSFlat.h>
+#include <faiss/IndexSVSVamana.h>
+#include <faiss/IndexSVSVamanaLVQ.h>
+#include <faiss/IndexSVSVamanaLeanVec.h>
 #endif
 #include <string>
 
@@ -548,57 +549,107 @@ IndexNSG* parse_IndexNSG(
  * Parse IndexSVS
  */
 
-LVQLevel parse_lvq(const std::string lvq_string) {
-    if (lvq_string == "LVQ_4x0") {
-        return LVQLevel::LVQ_4x0;
+LVQLevel parse_lvq(const std::string& lvq_string) {
+    if (lvq_string == "LVQ4x0") {
+        return LVQLevel::LVQ4x0;
     }
-    if (lvq_string == "LVQ_4x4") {
-        return LVQLevel::LVQ_4x4;
+    if (lvq_string == "LVQ4x4") {
+        return LVQLevel::LVQ4x4;
     }
-    if (lvq_string == "LVQ_4x8") {
-        return LVQLevel::LVQ_4x8;
+    if (lvq_string == "LVQ4x8") {
+        return LVQLevel::LVQ4x8;
     }
     FAISS_ASSERT(!"not supported SVS LVQ level");
 }
 
-LeanVecLevel parse_leanvec(const std::string leanvec_string) {
-    if (leanvec_string == "LeanVec_4x4") {
-        return LeanVecLevel::LeanVec_4x4;
+LeanVecLevel parse_leanvec(const std::string& leanvec_string) {
+    if (leanvec_string == "LeanVec4x4") {
+        return LeanVecLevel::LeanVec4x4;
     }
-    if (leanvec_string == "LeanVec_4x8") {
-        return LeanVecLevel::LeanVec_4x8;
+    if (leanvec_string == "LeanVec4x8") {
+        return LeanVecLevel::LeanVec4x8;
     }
-    if (leanvec_string == "LeanVec_8x8") {
-        return LeanVecLevel::LeanVec_8x8;
+    if (leanvec_string == "LeanVec8x8") {
+        return LeanVecLevel::LeanVec8x8;
     }
     FAISS_ASSERT(!"not supported SVS Leanvec level");
 }
 
-IndexSVS* parse_IndexSVS(const std::string code_string, int d, MetricType mt) {
-    if (code_string.empty()) {
-        IndexSVS* svs = new IndexSVS(d, mt);
-        return svs;
-    }
+Index* parse_svs_datatype(
+        const std::string& index_type,
+        const std::string& arg_string,
+        const std::string& datatype_string,
+        int d,
+        MetricType mt) {
     std::smatch sm;
-    auto match = [&sm, &code_string](const std::string& pattern) {
-        return re_match(code_string, pattern, sm);
-    };
 
-    if (match("(LVQ_[0-9]+x[0-9]+)")) {
-        IndexSVSLVQ* slvq = new IndexSVSLVQ(d, mt, parse_lvq(sm[0].str()));
-        return slvq;
-    }
-    if (match("(LeanVec_[0-9]+x[0-9]+)([,]([0-9]+))?")) {
-        // We also accept empty leanvec dimension
+    // TODO: support SQ8, Float16
+    // TODO: support LVQ and LeanVec on Flat, IVF
+    if (datatype_string.empty()) {
+        if (index_type == "Vamana")
+            return new IndexSVSVamana(d, std::stoul(arg_string), mt);
+        if (index_type == "Flat")
+            return new IndexSVSFlat(d, mt);
+        FAISS_ASSERT(!"Unspported SVS index type");
+        // if(index_type == "IVF") return new IndexSVSIVF(d,
+        // std::stoul(arg_string), mt);
+    }
+    if (re_match(datatype_string, "(LVQ[0-9]+x[0-9]+)", sm)) {
+        if (index_type == "Vamana")
+            return new IndexSVSVamanaLVQ(
+                    d, std::stoul(arg_string), mt, parse_lvq(sm[0].str()));
+        FAISS_ASSERT(!"Unspported SVS index type for LVQ");
+        // if(index_type == "Flat") return new IndexSVSFlatLVQ(d, mt,
+        // parse_lvq(sm[0].str())); if(index_type == "IVF") return new
+        // IndexSVSIVFLVQ(d, std::stoul(arg_string), mt,
+        // parse_lvq(sm[0].str()));
+    }
+    if (re_match(datatype_string, "(LeanVec[0-9]+x[0-9]+)(_[0-9]+)?", sm)) {
         std::string leanvec_d_string =
                 sm[2].length() > 0 ? sm[2].str().substr(1) : "0";
-
         int leanvec_d = std::stoul(leanvec_d_string);
-        IndexSVSLeanVec* sleanvec = new IndexSVSLeanVec(
-                d, mt, leanvec_d, parse_leanvec(sm[1].str()));
-        return sleanvec;
+
+        if (index_type == "Vamana")
+            return new IndexSVSVamanaLeanVec(
+                    d,
+                    std::stoul(arg_string),
+                    mt,
+                    leanvec_d,
+                    parse_leanvec(sm[1].str()));
+        FAISS_ASSERT(!"Unspported SVS index type for LeanVec");
+        // if(index_type == "Flat")
+        // return new IndexSVSFlatLeanVec(
+        // d, mt, leanvec_d, parse_leanvec(sm[1].str()));
+        // if(index_type == "IVF")
+        // return new IndexSVSIVFLeanVec(
+        // d, std::stoul(arg_string), mt, leanvec_d,
+        // parse_leanvec(sm[1].str()));
     }
+    return nullptr;
+}
 
+Index* parse_IndexSVS(const std::string& code_string, int d, MetricType mt) {
+    std::smatch sm;
+    if (re_match(code_string, "Flat([,_].*)?", sm)) {
+        std::string datatype_string =
+                sm[1].length() > 0 ? sm[1].str().substr(1) : "";
+        return parse_svs_datatype("Flat", "", datatype_string, d, mt);
+    }
+    if (re_match(code_string, "Vamana([0-9]+)([,_].*)?", sm)) {
+        Index* index{nullptr};
+        std::string degree_string = sm[1].str();
+        std::string datatype_string =
+                sm[2].length() > 0 ? sm[2].str().substr(1) : "";
+        return parse_svs_datatype(
+                "Vamana", degree_string, datatype_string, d, mt);
+    }
+    if (re_match(code_string, "IVF([0-9]+)([,_].*)?", sm)) {
+        FAISS_ASSERT(!"Unspported SVS index type");
+        // std::string datatype_string =
+        // sm[1].length() > 0 ? sm[1].str().substr(1) : "";
+        // return parse_svs_datatype("IVF", num_cluster_string, datatype_string,
+        // d, mt);
+    }
     return nullptr;
 }
 #endif // FAISS_ENABLE_SVS
@@ -889,17 +940,15 @@ std::unique_ptr<Index> index_factory_sub(
     }
 
 #ifdef FAISS_ENABLE_SVS
-    if (re_match(description, "SVS([_].*)?", sm)) {
-        // We also accept empty code string
-        std::string code_string =
-                sm[1].length() > 0 ? sm[1].str().substr(1) : "";
+    if (re_match(description, "SVS([,_].*)", sm)) {
+        std::string code_string = sm[1].str().substr(1);
         if (verbose) {
             printf("parsing SVS string %s code_string=%s",
                    description.c_str(),
                    code_string.c_str());
         }
 
-        IndexSVS* index = parse_IndexSVS(code_string, d, metric);
+        Index* index = parse_IndexSVS(code_string, d, metric);
         FAISS_THROW_IF_NOT_FMT(
                 index,
                 "could not parse SVS code description %s in %s",
diff --git a/faiss/python/__init__.py b/faiss/python/__init__.py
index 5413a66b6..08bb160b2 100644
--- a/faiss/python/__init__.py
+++ b/faiss/python/__init__.py
@@ -219,7 +219,7 @@ add_ref_in_constructor(IDSelectorXOr, slice(2))
 add_ref_in_constructor(IndexIVFIndependentQuantizer, slice(3))
 
 if "SVS" in get_compile_options():
-    add_ref_in_constructor(IndexSVS, 0)
+    add_ref_in_constructor(IndexSVSVamana, 0)
     add_ref_in_constructor(IndexSVSFlat, 0)
 
 # seems really marginal...
diff --git a/faiss/python/swigfaiss.swig b/faiss/python/swigfaiss.swig
index 9c00e9f62..20fceaead 100644
--- a/faiss/python/swigfaiss.swig
+++ b/faiss/python/swigfaiss.swig
@@ -195,10 +195,10 @@ typedef uint64_t size_t;
 #include <faiss/IndexIVFRaBitQ.h>
 
 #ifdef FAISS_ENABLE_SVS
-#include <faiss/IndexSVS.h>
+#include <faiss/IndexSVSVamana.h>
 #include <faiss/IndexSVSFlat.h>
-#include <faiss/IndexSVSLVQ.h>
-#include <faiss/IndexSVSLeanVec.h>
+#include <faiss/IndexSVSVamanaLVQ.h>
+#include <faiss/IndexSVSVamanaLeanVec.h>
 #endif
 
 %}
@@ -693,10 +693,10 @@ struct faiss::simd16uint16 {};
 %ignore faiss::svs_io::WriterStreambuf;
 %ignore faiss::svs_io::SVSTempDirectory;
 
-%include  <faiss/IndexSVS.h>
+%include  <faiss/IndexSVSVamana.h>
 %include  <faiss/IndexSVSFlat.h>
-%include  <faiss/IndexSVSLVQ.h>
-%include  <faiss/IndexSVSLeanVec.h>
+%include  <faiss/IndexSVSVamanaLVQ.h>
+%include  <faiss/IndexSVSVamanaLeanVec.h>
 #endif // FAISS_ENABLE_SVS
 
 #ifdef GPU_WRAPPER
@@ -847,9 +847,9 @@ struct faiss::simd16uint16 {};
     DOWNCAST ( IndexRowwiseMinMaxFP16 )
 #ifdef FAISS_ENABLE_SVS
     DOWNCAST ( IndexSVSFlat )
-    DOWNCAST ( IndexSVSLeanVec )
-    DOWNCAST ( IndexSVSLVQ )
-    DOWNCAST ( IndexSVS )
+    DOWNCAST ( IndexSVSVamanaLeanVec )
+    DOWNCAST ( IndexSVSVamanaLVQ )
+    DOWNCAST ( IndexSVSVamana )
 #endif // FAISS_ENABLE_SVS
 #ifdef GPU_WRAPPER
 #ifdef FAISS_ENABLE_CUVS
diff --git a/tests/test_svs.cpp b/tests/test_svs.cpp
index f3638f416..b77b4e0ef 100644
--- a/tests/test_svs.cpp
+++ b/tests/test_svs.cpp
@@ -6,10 +6,10 @@
  */
 
 #include <faiss/Index.h>
-#include <faiss/IndexSVS.h>
+#include <faiss/IndexSVSVamana.h>
 #include <faiss/IndexSVSFlat.h>
-#include <faiss/IndexSVSLVQ.h>
-#include <faiss/IndexSVSLeanVec.h>
+#include <faiss/IndexSVSVamanaLVQ.h>
+#include <faiss/IndexSVSVamanaLeanVec.h>
 #include <faiss/index_io.h>
 #include <gtest/gtest.h>
 #include <type_traits>
@@ -74,13 +74,13 @@ void write_and_read_index(T& index, const std::vector<float>& xb, size_t n) {
     EXPECT_EQ(loaded->max_candidate_pool_size, index.max_candidate_pool_size);
     EXPECT_EQ(loaded->prune_to, index.prune_to);
     EXPECT_EQ(loaded->use_full_search_history, index.use_full_search_history);
-    if constexpr (std::is_same_v<std::decay_t<T>, faiss::IndexSVSLVQ>) {
-        auto* lvq_loaded = dynamic_cast<faiss::IndexSVSLVQ*>(loaded);
+    if constexpr (std::is_same_v<std::decay_t<T>, faiss::IndexSVSVamanaLVQ>) {
+        auto* lvq_loaded = dynamic_cast<faiss::IndexSVSVamanaLVQ*>(loaded);
         ASSERT_NE(lvq_loaded, nullptr);
         EXPECT_EQ(lvq_loaded->lvq_level, index.lvq_level);
     }
-    if constexpr (std::is_same_v<std::decay_t<T>, faiss::IndexSVSLeanVec>) {
-        auto* lvq_loaded = dynamic_cast<faiss::IndexSVSLeanVec*>(loaded);
+    if constexpr (std::is_same_v<std::decay_t<T>, faiss::IndexSVSVamanaLeanVec>) {
+        auto* lvq_loaded = dynamic_cast<faiss::IndexSVSVamanaLeanVec*>(loaded);
         ASSERT_NE(lvq_loaded, nullptr);
         EXPECT_EQ(lvq_loaded->leanvec_level, index.leanvec_level);
     }
@@ -89,48 +89,48 @@ void write_and_read_index(T& index, const std::vector<float>& xb, size_t n) {
 }
 
 TEST_F(SVSIOTest, WriteAndReadIndexSVS) {
-    faiss::IndexSVS index{d};
+    faiss::IndexSVSVamana index{d};
     write_and_read_index(index, test_data, n);
 }
 
 TEST_F(SVSIOTest, WriteAndReadIndexSVSLVQ4x0) {
-    faiss::IndexSVSLVQ index{d};
-    index.lvq_level = faiss::LVQLevel::LVQ_4x0;
+    faiss::IndexSVSVamanaLVQ index{d};
+    index.lvq_level = faiss::LVQLevel::LVQ4x0;
     write_and_read_index(index, test_data, n);
 }
 
 TEST_F(SVSIOTest, WriteAndReadIndexSVSLVQ4x4) {
-    faiss::IndexSVSLVQ index{d};
-    index.lvq_level = faiss::LVQLevel::LVQ_4x4;
+    faiss::IndexSVSVamanaLVQ index{d};
+    index.lvq_level = faiss::LVQLevel::LVQ4x4;
     write_and_read_index(index, test_data, n);
 }
 
 TEST_F(SVSIOTest, WriteAndReadIndexSVSLVQ4x8) {
-    faiss::IndexSVSLVQ index{d};
-    index.lvq_level = faiss::LVQLevel::LVQ_4x8;
+    faiss::IndexSVSVamanaLVQ index{d};
+    index.lvq_level = faiss::LVQLevel::LVQ4x8;
     write_and_read_index(index, test_data, n);
 }
 
-TEST_F(SVSIOTest, WriteAndReadIndexSVSLeanVec4x4) {
-    faiss::IndexSVSLeanVec index{
+TEST_F(SVSIOTest, WriteAndReadIndexSVSVamanaLeanVec4x4) {
+    faiss::IndexSVSVamanaLeanVec index{
             d, faiss::METRIC_L2, 0, faiss::LeanVecLevel::LeanVec_4x4};
     write_and_read_index(index, test_data, n);
 }
 
-TEST_F(SVSIOTest, WriteAndReadIndexSVSLeanVec4x8) {
-    faiss::IndexSVSLeanVec index{
+TEST_F(SVSIOTest, WriteAndReadIndexSVSVamanaLeanVec4x8) {
+    faiss::IndexSVSVamanaLeanVec index{
             d, faiss::METRIC_L2, 0, faiss::LeanVecLevel::LeanVec_4x8};
     write_and_read_index(index, test_data, n);
 }
 
-TEST_F(SVSIOTest, WriteAndReadIndexSVSLeanVec8x8) {
-    faiss::IndexSVSLeanVec index{
+TEST_F(SVSIOTest, WriteAndReadIndexSVSVamanaLeanVec8x8) {
+    faiss::IndexSVSVamanaLeanVec index{
             d, faiss::METRIC_L2, 0, faiss::LeanVecLevel::LeanVec_8x8};
     write_and_read_index(index, test_data, n);
 }
 
 TEST_F(SVSIOTest, LeanVecThrowsWithoutTraining) {
-    faiss::IndexSVSLeanVec index{
+    faiss::IndexSVSVamanaLeanVec index{
             64, faiss::METRIC_L2, 0, faiss::LeanVecLevel::LeanVec_4x4};
     ASSERT_THROW(index.add(100, test_data.data()), faiss::FaissException);
 }
diff --git a/tutorial/cpp/10-SVS.cpp b/tutorial/cpp/10-SVS-Vamana.cpp
similarity index 94%
rename from tutorial/cpp/10-SVS.cpp
rename to tutorial/cpp/10-SVS-Vamana.cpp
index c3f91cf4b..9da43cc6e 100644
--- a/tutorial/cpp/10-SVS.cpp
+++ b/tutorial/cpp/10-SVS-Vamana.cpp
@@ -10,7 +10,7 @@
 #include <cstdlib>
 #include <random>
 
-#include <faiss/IndexSVS.h>
+#include <faiss/IndexSVSVamana.h>
 #include <faiss/index_io.h>
 
 using idx_t = faiss::idx_t;
@@ -40,7 +40,7 @@ int main() {
 
     int k = 4;
 
-    faiss::IndexSVS index(d);
+    faiss::IndexSVSVamana index(d, 32);
     index.add(nb, xb);
 
     { // search xq
@@ -70,7 +70,7 @@ int main() {
     std::cout << "Persisting index to disk and reloading." << std::endl;
 
     faiss::write_index(&index, "/tmp/test_svs_index.faiss");
-    faiss::IndexSVS* reloaded = dynamic_cast<faiss::IndexSVS*>(
+    faiss::IndexSVSVamana* reloaded = dynamic_cast<faiss::IndexSVSVamana*>(
             faiss::read_index("/tmp/test_svs_index.faiss"));
     FAISS_THROW_IF_NOT_MSG(reloaded, "Failed to reload index from disk");
 
diff --git a/tutorial/cpp/11-SVSLVQ.cpp b/tutorial/cpp/11-SVS-Vamana-LVQ.cpp
similarity index 95%
rename from tutorial/cpp/11-SVSLVQ.cpp
rename to tutorial/cpp/11-SVS-Vamana-LVQ.cpp
index 30e03e454..e22c54901 100644
--- a/tutorial/cpp/11-SVSLVQ.cpp
+++ b/tutorial/cpp/11-SVS-Vamana-LVQ.cpp
@@ -10,7 +10,7 @@
 #include <cstdlib>
 #include <random>
 
-#include <faiss/IndexSVSLVQ.h>
+#include <faiss/IndexSVSVamanaLVQ.h>
 
 using idx_t = faiss::idx_t;
 
@@ -39,7 +39,7 @@ int main() {
 
     int k = 4;
 
-    faiss::IndexSVSLVQ index(d);
+    faiss::IndexSVSVamanaLVQ index(d, 64);
     index.add(nb, xb);
 
     { // search xq
diff --git a/tutorial/cpp/12-SVSLeanVec.cpp b/tutorial/cpp/12-SVS-Vamana-LeanVec.cpp
similarity index 94%
rename from tutorial/cpp/12-SVSLeanVec.cpp
rename to tutorial/cpp/12-SVS-Vamana-LeanVec.cpp
index 3b4f6f0ab..445a01c91 100644
--- a/tutorial/cpp/12-SVSLeanVec.cpp
+++ b/tutorial/cpp/12-SVS-Vamana-LeanVec.cpp
@@ -10,7 +10,7 @@
 #include <cstdlib>
 #include <random>
 
-#include <faiss/IndexSVSLeanVec.h>
+#include <faiss/IndexSVSVamanaLeanVec.h>
 
 using idx_t = faiss::idx_t;
 
@@ -39,7 +39,7 @@ int main() {
 
     int k = 4;
 
-    faiss::IndexSVSLeanVec index(d);
+    faiss::IndexSVSVamanaLeanVec index(d, 32);
     index.train(nb, xb);
     index.add(nb, xb);
 
diff --git a/tutorial/cpp/CMakeLists.txt b/tutorial/cpp/CMakeLists.txt
index fb0f9f17c..342d283d3 100644
--- a/tutorial/cpp/CMakeLists.txt
+++ b/tutorial/cpp/CMakeLists.txt
@@ -31,14 +31,14 @@ add_executable(9-RefineComparison EXCLUDE_FROM_ALL 9-RefineComparison.cpp)
 target_link_libraries(9-RefineComparison PRIVATE faiss)
 
 if(FAISS_ENABLE_SVS)
-  add_executable(10-SVS EXCLUDE_FROM_ALL 10-SVS.cpp)
-  target_link_libraries(10-SVS PRIVATE faiss)
+  add_executable(10-SVS-Vamana EXCLUDE_FROM_ALL 10-SVS-Vamana.cpp)
+  target_link_libraries(10-SVS-Vamana PRIVATE faiss)
 
-  add_executable(11-SVSLVQ EXCLUDE_FROM_ALL 11-SVSLVQ.cpp)
-  target_link_libraries(11-SVSLVQ PRIVATE faiss)
+  add_executable(11-SVS-Vamana-LVQ EXCLUDE_FROM_ALL 11-SVS-Vamana-LVQ.cpp)
+  target_link_libraries(11-SVS-Vamana-LVQ PRIVATE faiss)
 
-  add_executable(12-SVSLeanVec EXCLUDE_FROM_ALL 12-SVSLeanVec.cpp)
-  target_link_libraries(12-SVSLeanVec PRIVATE faiss)
+  add_executable(12-SVS-Vamana-LeanVec EXCLUDE_FROM_ALL 12-SVS-Vamana-LeanVec.cpp)
+  target_link_libraries(12-SVS-Vamana-LeanVec PRIVATE faiss)
 
   add_executable(13-tmp-svscomp EXCLUDE_FROM_ALL 13-tmp-svscomp.cpp)
   target_link_libraries(13-tmp-svscomp PRIVATE faiss)
diff --git a/tutorial/python/10-SVS.py b/tutorial/python/10-SVS.py
index ea594043a..a9d5ecb98 100644
--- a/tutorial/python/10-SVS.py
+++ b/tutorial/python/10-SVS.py
@@ -15,11 +15,7 @@ xq = np.random.random((nq, d)).astype('float32')
 xq[:, 0] += np.arange(nq) / 1000.
 
 import faiss                        # make faiss available
-index = faiss.IndexSVS(d)           # build the index (DynamicVamana, float32)
-
-# index = faiss.IndexSVSFlat(d)     # build the SVSFlat index
-# index = faiss.IndexSVSLVQ(d)      # build the SVSLVQ index, quantization parameters
-# index = faiss.IndexSVSLeanVec(d)   # build the SVSLeanVec index, quantization parameters
+index = faiss.IndexSVSVamana(d, 64)           # build the index (DynamicVamana, float32)
 
 print(index.is_trained)
 index.add(xb)                  # add vectors to the index
@@ -46,14 +42,27 @@ print(I[:5])                   # neighbors of the 5 first queries
 print(f"{k} nearest neighbors of the 5 last query vectors (after reloading)")
 print(I[-5:])                  # neighbors of the 5 last queries
 
-lvq_idx = faiss.IndexSVSLVQ(d, faiss.METRIC_L2, faiss.LVQ_4x8) # example of using SVS LVQ
-lvq_idx_fac = faiss.index_factory(d, 'SVS_LVQ_4x8', faiss.METRIC_L2) # example of using factory for SVS LVQ
-lvq_idx_fac.add(xb)
-lvq_idx_fac.search(xq, k)
+flat_idx_fac = faiss.index_factory(d, 'SVS,Flat', faiss.METRIC_L2) # example of using factory for SVS Flat
+flat_idx_fac.add(xb)
+flat_idx_fac.search(xq, k)
+
+uncompressed_idx_fac = faiss.index_factory(d, 'SVS,Vamana64', faiss.METRIC_L2) # example of using factory for SVS Vamana uncompressed
+uncompressed_idx_fac.add(xb)
+uncompressed_idx_fac.search(xq, k)
 
+lvq_idx = faiss.IndexSVSVamanaLVQ(d, faiss.METRIC_L2, faiss.LVQ4x8) # example of using SVS Vamana uncompressed
+lvq_idx_fac_2 = faiss.index_factory(d, 'SVS,Vamana32,LVQ4x4', faiss.METRIC_L2) # example of using factory for SVS Vamana LVQ
+lvq_idx_fac_2.add(xb)
+lvq_idx_fac_2.search(xq, k)
 
-leanvec_idx = faiss.IndexSVSLeanVec(d, faiss.METRIC_L2, 0, faiss.LeanVec_4x4) # example of using SVS LeanVec
-leanvec_idx_fac = faiss.index_factory(d, 'SVS_LeanVec_4x4,32', faiss.METRIC_L2) # example of using factory for SVS LeanVec
+
+leanvec_idx = faiss.IndexSVSVamanaLeanVec(d, faiss.METRIC_L2, 0, faiss.LeanVec4x4) # example of using SVS Vamana LeanVec
+leanvec_idx_fac = faiss.index_factory(d, 'SVS,Vamana32,LeanVec4x4', faiss.METRIC_L2) # example of using factory for SVS Vamana LeanVec
 leanvec_idx_fac.train(xb)
 leanvec_idx_fac.add(xb)
 leanvec_idx_fac.search(xq, k)
+
+leanvec_idx_fac2 = faiss.index_factory(d, 'SVS,Vamana64,LeanVec4x4_16', faiss.METRIC_L2) # example of using factory for SVS Vamana LeanVec. leanvec_dim is 16
+leanvec_idx_fac2.train(xb)
+leanvec_idx_fac2.add(xb)
+leanvec_idx_fac2.search(xq, k)
-- 
2.39.5 (Apple Git-154)

